#+TITLE: Finch vs Http4s, which is FPer
#+DATE: <2018-12-11 Tue>
#+AUTHOR: Jichao Ouyang

This is purely personal comparation from Functional Programming point of view, which only
consider composible, extensible, and joy of FP. performance and eco system are out of scope.

the explicit version comparing here is finch 0.26.1 and Http4s 0.20-M4

Definition:

- /composible/: how easy to build blocks from exsiting components
- /extensible/: how easy to add a new type
- /joy of FP/: how many FP knowledge are actually practiced

** Finch

*** composible: ğŸ ğŸ ğŸ ğŸ ğŸ
finch took full advantage of shapeless' product and coproduct to match routes
#+BEGIN_SRC scala
val getApples = get("apple") { Ok("ğŸğŸ")} 
val getApple = get("apple" :: path[Int]) { (id: Int) => Ok("ğŸ")}

val routes = getApples :+: getApple
#+END_SRC

=::= here is a product, means the path will match if there is an ="apple"= and a Int in the path =path[Int]=

=:+:= constructs a coproduct, which means either getApples or getApple matched route will match

*** extensible: ğŸ ğŸ
finch has lot of internal custom types, e.g. the magic happen behind the dsl above:
#+BEGIN_SRC scala
val getApples = get("apple") { Ok("ğŸğŸ")} 
#+END_SRC
is:

1. string "apple" will implicitly convert into =Endpoint[Unit]=
2. =get("apple")= will covert =Endpoint[Unit]= into function =Mapper[F, In] => Endpoint[F, Out]=
basically just =Cont=, taking Mapper as parameter and wrapping it self.
3. another implicit conversion will take place in =Ok("")=, from ~Output[String] => Mapper[F, String]~

if you didn't follow, that's fine, because there is so many implicit conversion and internal custom types
took place here.

but think about it, because all implicit conversion was well defined in finch internally
we've restrict to the types they provided.

for example my controller will acutally return me a Free Monad i.e. =Free[Program, Output[String]]=

how can I get it to work with the router?

#+BEGIN_SRC scala
val getApples = get("apple") { Free[Program, Output[String]].pure(Ok("ğŸğŸ"))} 
#+END_SRC

it won't compile because the implicit conversion expecting an =Output[_]= type

acutally it support =IO[_]=, =Output[_]=, =Response=

from [[https://github.com/finagle/finch/pull/1045][0.26.1]] it supports custom converter to convert any user custom type to IO
#+BEGIN_SRC scala
implicit val conv = new ToEffect[Free[Program, ?], IO] {
def apply[A](a: Free[Program, A]): IO[A] = ???
}
val getApples = get("apple") { Free[Program, Output[String]].pure(Ok("
#+END_SRC

but still, it's so many implicits magic happen behind and the journey wasn't so fun.


*** joy of FP: ğŸ ğŸ ğŸ

except some funs from shapeless there arn't actually any cats interop during composition of routes

while that could be much more beginer friendly though, user don't have to notice and have
any knowledge of cats before using finch



** Http4s
*** composible: ğŸ ğŸ ğŸ ğŸ ğŸ
while http4s take advantage of cats to achieve path matching
#+BEGIN_SRC scala
val getApples = HttpRoutes.of[IO] {
  case GET -> Root / "apple" => Ok("ğŸğŸ")
}
val getApple = HttpRoutes.of[IO] {
  case GET -> Root / "apple" / id => Ok("ğŸ")
}

val routes = getApples <+> getApple
#+END_SRC

what happen here is =HttpRoutes.of[IO] {...}= return a data type [[https://typelevel.org/cats/datatypes/kleisli.html][=Kleisli{OptionT{F, ?}, Request{F}, F{Response{F}}}=]]

=<+>= is [[https://typelevel.org/cats/typeclasses/semigroupk.html][combindK]] of ~SemigroupK[Kleisli[OptionT[F, ?], Request[F], ?]]~

you may already realize that nothing of above make any sense to you if you arn't
familiar with cats or scalaz.

It require some knowledge from cats, just like you should know some sort of
of shapeless to fully understand what the hell is =::= and =:+:=

/Kleisli/ is a generic data type representing a function like =A => F[B]=

so you could imagine that =Kleisli[OptionT[F, ?], Request[F], F[Response[F]]]= is just
=Request[F] => OptionT[F, F[Response[F]]]=

while =<+>= is very like =:+:=, it combine these Kleisli, but any of these match, it will
return that matched Kleisli

*** extensible: ğŸ ğŸ ğŸ ğŸ ğŸ


*** joy of FP: ğŸ ğŸ ğŸ ğŸ ğŸ
