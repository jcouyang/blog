#+TITLE: Functional Ruby
#+DATE: <2016-07-14 Thu>
#+AUTHOR: æ¬§é˜³ç»§è¶…
#+PROPERTY: header-args :results pp :exports both

#+BEGIN_CENTER

è¯é¢˜å·²å…¥é€‰ [[http://rubyconfchina2016.sxl.cn/][Rubyconf 2016]], æ²¡çœ‹æ‡‚çš„åŒå­¦ +ä¸æœæ¥æˆ˜+ æˆ‘ä»¬æˆéƒ½è§ ğŸ˜‰

- slides ğŸ‘‰ http://git.io/fprb
- cats.rb https://github.com/jcouyang/cats.rb
- hehe
#+END_CENTER

[[./images/data-port.gif]]

è¯´åˆ° ruby éƒ½ä¼šè§‰å¾—æ˜¯çº¯é¢å‘å¯¹è±¡è¯­è¨€ï¼Œæ‰€æœ‰ä¸œè¥¿éƒ½æ˜¯å¯¹è±¡ã€‚ä½†æ˜¯ï¼Œå‡½æ•°å¼ä¸é¢å‘å¯¹è±¡å¹¶æ— å†²çªï¼ˆä½ çœ‹çœ‹Scalaï¼‰ã€‚æœ€è¿‘ä¸€ä¸ªé¡¹ç›®ç”¨ ruby å†™äº†ä¸€ä¸ªéå¸¸å¸¸ç”¨çš„ feederï¼Œä¸€ä¸å°å¿ƒå†™å¾—å‡½æ•°å¼äº†äº›ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹fancyçš„rubyåˆ°åº•èƒ½å¹²äº›ä»€ä¹ˆfancyçš„å‡½æ•°å¼ã€‚

* COMMENT
#+BEGIN_SRC emacs-lisp
(require 'ob-ruby)
#+END_SRC

#+RESULTS:
: ob-ruby

* lambda
ä¸å‡ºæ‰€æ–™ï¼Œå‡½æ•°å¼ä¸€å®šè¦å…ˆæœ‰ lambdaï¼Œè·Ÿæ‰€æœ‰çš„ ruby å¯¹è±¡ä¸€æ ·ï¼Œlambda ä¹Ÿå°±æ˜¯ä¸€ä¸ªæ­£å¸¸çš„å¯¹è±¡
#+BEGIN_SRC ruby 
plus1 = ->(x) { x + 1 }
#+END_SRC

#+RESULTS:
: #<Proc:0x007fbaea988030@-:3 (lambda)>

æ˜æ˜¾ï¼Œlambda æ„é€ å‡ºä¸€ä¸ª Proc çš„å®ä¾‹ï¼Œå¦‚æœæˆ‘ä»¬è°ƒç”¨è¿™ä¸ª lambdaï¼Œæ•ˆæœè·Ÿ method æ²¡æœ‰ä»€ä¹ˆåŒºåˆ«ï¼š

#+BEGIN_SRC ruby 
plus1 = ->(x) { x + 1 }
plus1.(3)
#+END_SRC

#+RESULTS:
: 4

å¥½ç©çš„æ˜¯ï¼Œmethod ä¸èƒ½é«˜é˜¶
#+BEGIN_SRC ruby  :results pp
  def plus1 x
    x + 1
  end
  [1,2,3,4].map &plus1
#+END_SRC

: `plus1': wrong number of arguments (0 for 1) (ArgumentError)

å› ä¸º plus1 åœ¨å¼•ç”¨æ—¶å°±å·²ç»è°ƒç”¨äº†ï¼Œè§£é‡Šå™¨åœ¨è°ƒç”¨ =plus1= æ—¶å‘ç°å¹¶æ²¡æœ‰ä¼ å‚æ•°ï¼Œäºæ˜¯æŠ›å‡ºå‚æ•°ä¸åŒ¹é…é”™è¯¯ã€‚ç”±äºmethod å¼•ç”¨å³invokeï¼Œä½ æ°¸è¿œæ— æ³•å†™å‡ºé«˜é˜¶å‡½æ•°çš„æ•ˆæœã€‚

è€Œ lambda å°±å¯ä»¥ï¼š

#+BEGIN_SRC ruby  :results pp
plus1 = ->(x) { x + 1 }
[1,2,3,4].map &plus1
#+END_SRC

#+RESULTS:
: [2, 3, 4, 5]

* ç¥å¥‡çš„ =&=

è¿™é‡Œçš„ magic æ˜¯ =&= æŠŠ =plus1= å˜æˆ Block å‘ç»™æ•°ç»„äº†ï¼ŒBlock ä¹Ÿå°±æ˜¯æˆ‘ä»¬å¸¸è§çš„ ={}= ï¼Œç­‰ä»·äºï¼š
#+BEGIN_SRC ruby
[1,2,3,4].map {|x| x + 1}
#+END_SRC

ä¹Ÿç­‰ä»·äºï¼š
#+BEGIN_SRC ruby
[1,2,3,4].map &Proc.new{|x| x + 1 }
#+END_SRC

æ³¨æ„å¦‚æœæ²¡æœ‰ =&= ï¼Œè§£é‡Šå™¨æ— æ³•åˆ†è¾¨åˆ°åº•åœ¨è°ƒç”¨ =map= æ—¶ï¼ŒæŠŠ Proc å½“æˆæ­£å¸¸å‚æ•°ï¼Œè€Œä¸æ˜¯ block

å½“å¾—çŸ¥ =&= çš„é­”æ³•ä¹‹åï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“è§£é‡Š =&:symbol= è¿™ä¸ªè¯­æ³•ç³–
#+BEGIN_SRC ruby  :results pp
%w(ouyang jichao).map &:capitalize 
#+END_SRC

#+RESULTS:
: ["Ouyang", "Jichao"]

desuger å®Œå…¶å®å°±æ˜¯
#+BEGIN_SRC ruby
  %w(ouyang jichao).map &Proc.new(|x| x.send(:capitalize))
#+END_SRC

ä¸ºä»€ä¹ˆå¯ä»¥äº§ç”Ÿè¿™æ ·çš„è¯­æ³•ç³–ï¼Œæ˜¯ Symbol ç±»å‹æœ‰ =to_proc= æ–¹æ³•ï¼Œå½“ =&= å°è¯•å°†åé¢çš„ä¸œè¥¿å˜æˆ Proc ç±»å‹åä¼ ç»™ map å½“ Blockï¼Œ =to_proc= å°±æ˜¯ç”¨æ¥è½¬æ¢æˆ proc çš„æ–¹æ³•ã€‚

æ‰€ä»¥å°±æ˜¯ï¼š
#+BEGIN_SRC ruby  :results pp
  %w(ouyang jichao).map &:capitalize.to_proc
#+END_SRC

#+RESULTS:
: ["Ouyang", "Jichao"]

* ä¸ºä»€ä¹ˆ lambda æ˜¯ proc
è¯è¯´å›æ¥ï¼Œæ—¢ç„¶ lambda ä¹Ÿè¿”å› Proc å®ä¾‹ï¼Œ =Proc.new= ä¹Ÿè¿”å› Proc å®ä¾‹ï¼Œä¸ºä½•è¦è®¾è®¡è¿™ä¸¤ç§åŒ¿åå‡½æ•°å‘¢ï¼Ÿ

ç®€å•æ¥è¯´ï¼Œ Proc åªæ˜¯ä¸€æ®µä»£ç å—ï¼Œä½ å¯ä»¥æƒ³è±¡å¼•ç”¨çš„åœ°æ–¹ä¼šå˜æˆè¿™å—ä»£ç å—ï¼Œè€Œ lambda ä¸ä»…æ˜¯ä¸€å—ä»£ç å—ï¼Œè¡¨ç°å¾—æ›´åƒä¸€ä¸ªå‡½æ•°ã€‚å…·ä½“æ¥è®²ï¼Œå°±æ˜¯ return ä¸å‚æ•°æ£€æŸ¥ï¼š
** return
æ¥çœ‹ä¸ªè¯¡å¼‚çš„ï¼Œä¸‹é¢è¿™æ®µä»£ç æˆ‘ä»¬å¯èƒ½ä¼šæœŸæœ›æ˜¯è¿”å›ä¸€ä¸ªæ•°ç»„ï¼Œåªæ˜¯ =jichao= ä¼šå˜æˆ =lulu= è€Œå·²

#+BEGIN_SRC ruby  :results pp
%w(ouyang jichao).map { |x| return 'lulu' if x == 'jichao'; x}
#+END_SRC

#+RESULTS:
: "lulu"

æ˜¾ç„¶ return ä¹‹åçš„ä»£ç å°±å†ä¹Ÿèµ°ä¸åˆ°äº†ï¼Œæ•´ä¸ªmapä¼šç›´æ¥è¿”å›

ä½†æ˜¯å¦‚æœä½ ç”¨ lambda è€Œä¸æ˜¯æ™®é€š Procï¼Œä½ ä¼šå‘ç°
#+BEGIN_SRC ruby  :results pp
%w(ouyang jichao).map &->(x){ return 'lulu' if x == 'jichao'; x}
#+END_SRC

#+RESULTS:
: ["ouyang", "lulu"]

å—’å“’ï¼Œè¾“å‡ºæˆ‘ä»¬çš„æœŸæœ›äº†ï¼Œlambda çš„è¡¨ç°è·Ÿä¸€ä¸ªæ™®é€šå‡½æ•°æ˜¯ä¸€æ ·çš„ï¼Œå‡½æ•°çš„ return å½“ç„¶ä¸ä¼šå¯¼è‡´è°ƒç”¨è€…çš„è¿”å›ã€‚

** å‚æ•°æ£€æŸ¥
ç¡®åˆ‡çš„è¯´æ˜¯å‚æ•°å…ƒæ•° arity çš„æ£€æŸ¥ï¼Œæ¯”å¦‚éšä¾¿å®šä¹‰ä¸€ä¸ªmethodï¼Œå¦‚æœä½ ç»™çš„å‚æ•°å…ƒæ•°ä¸åŒ¹é…ï¼Œä¼šå¾—åˆ°ä¸€ä¸ªå¼‚å¸¸
#+BEGIN_SRC ruby 
def heheda who
  "heheda #{who}"
end
heheda
#+END_SRC

: `heheda': wrong number of arguments (0 for 1) (ArgumentError)

å› ä¸ºå®šä¹‰çš„æ˜¯ä¸€å…ƒçš„å‡½æ•°ï¼Œè°ƒç”¨æ—¶å¹¶æ²¡æœ‰ç»™ä»»ä½•å‚æ•°ï¼Œå°±æŒ‚äº†

ä½†æ˜¯ Proc æ˜¯ä¸ä¼šç®¡è¿™ä¸ªçš„
#+BEGIN_SRC ruby  :results pp
heheda = Proc.new{|who| p "heheda #{who}"}
heheda.()
#+END_SRC

#+RESULTS:
: "heheda "

Proc å®Œå…¨ä¸ä¼šç†ä¼šå‚æ•°ï¼Œå¦‚æœbindingèƒ½æ‰¾åˆ°ï¼Œå°±ç”¨äº†ï¼Œå¦‚æœæ²¡æœ‰ï¼Œä¹Ÿç»§ç»­è¿è¡Œã€‚

lambdaï¼Œåˆ™æ›´åƒä¸€ä¸ªmethod
#+BEGIN_SRC ruby 
heheda = lambda {|who| p "heheda #{who}"}
heheda.()
#+END_SRC

: `block in main': wrong number of arguments (0 for 1) (ArgumentError)

* é—­åŒ…
é€šå¸¸é¢å‘å¯¹è±¡çš„æ•æ‰ä¸€ä¸ªç»‘å®šé€šå¸¸ä¼šé€šè¿‡ =@=
#+BEGIN_SRC ruby
class HeHe
def initialize who
  @who = who
end
def heheda
  "heheda #{@who}"
end
end
#+END_SRC

=HeHe= å¯¹ who è¿›è¡Œäº†å°è£…ï¼Œå¦‚æœéœ€è¦è®¿é—® =who= éœ€è¦é€šè¿‡ =heheda= æ–¹æ³•ã€‚

åŒæ ·çš„ä¸œè¥¿ï¼Œåœ¨å‡½æ•°å¼å«é—­åŒ…ï¼Œé€šè¿‡é—­åŒ…æˆ‘ä»¬ä¾ç„¶èƒ½æ‰¾åˆ°é—­åŒ…å†…çš„ç»‘å®š
#+BEGIN_SRC ruby 
who = 'jichao'
heheda = ->(){ "heheda #{who}" }
def hehedaToOuyang &heheda
  who = 'ouyang'
  heheda.()
end
hehedaToOuyang &heheda
#+END_SRC

#+RESULTS:
: "heheda jichao"

æ³¨æ„çœ‹ heheda æ‰¾åˆ°çš„ç»‘å®šä¸æ˜¯ç¦»ä»–è°ƒç”¨æœ€è¿‘çš„ =who=, è€Œæ˜¯å½“åˆå®šä¹‰çš„ ~who=jichao~

æ‰€ä»¥è·Ÿé¢å‘å¯¹è±¡ä¸€æ ·ï¼Œ =heheda= å®Œç¾çš„å°è£…äº† =who= ,è°ƒç”¨è€…å³æ— æ³•ç›´æ¥è·å–åˆ°ä»–ç»‘å®šçš„ =who= , ä¹Ÿæ— æ³•é‡æ–°ç»™ä»–æ–°çš„ç»‘å®š

* pattern matching
ruby æ”¯æŒç®€å•çš„å‡ ç§æ¨¡å¼åŒ¹é…

** destructure
#+BEGIN_SRC ruby
first, *middle_and_last = ['Phillip', 'Jay', 'Fry']
p first, middle_and_last
#+END_SRC

#+RESULTS:
| Phillip | (Jay Fry) |

destructuring ä¸€ä¸ªæ•°ç»„å¦‚æ­¤ç®€å•ï¼Œä½†æ˜¯hashå°±ä¸è¿™ä¹ˆå®¹æ˜“ï¼Œå¥½åœ¨ï¼Œæ–¹æ³•çš„å‚æ•°ä¼šè‡ªå¸¦ destructureçš„åŠŸèƒ½ï¼š
#+BEGIN_SRC ruby
  fry = {first: 'Phillip', middle: 'Jay', last: 'Fry'}
  def printFirstName first:, **rest
    p first, rest
  end
printFirstName fry
#+END_SRC

#+RESULTS:
| Phillip | (:middle=> Jay :last=> Fry) |

è¿™ç©æ„ ruby å«å®ƒ keyword arguments, =first:= ä¼šåŒ¹é… =fry= ä¸­çš„ =first= å¹¶å°†å€¼ç»‘å®šåˆ° =first= ï¼Œ =**rest= ç»‘å®šå‰©ä¸‹çš„æ‰€æœ‰ä¸œè¥¿ã€‚

æ•°ç»„ä¹Ÿå¯ä»¥è¿™æ ·æï¼š

#+BEGIN_SRC ruby -r -n
fry = ['Phillip', 'Jay', 'Fry']
def printFirstName first, *rest
p first, rest
end
printFirstName *fry (ref:star)
#+END_SRC

#+RESULTS:
| Phillip | (Jay Fry) |

è¦æ³¨æ„ç¬¬[[(star)]]è¡Œ, è°ƒç”¨æ—¶è®°å¾—ç»™æ•°ç»„åŠ  =*=, è¿™æ ·è§£é‡Šå™¨æ‰çŸ¥é“ä¸æ˜¯æŠŠæ•´ä¸ª fry æ‰”ç»™ =printFirstName= å½“å‚æ•°ï¼Œè€Œæ˜¯æŠŠ fry çš„å†…å®¹æ‰”è¿‡å»å½“å‚æ•°ã€‚

** case when
ruby ä¸­çš„ case[fn:1] å¯ä»¥æå®šå››ç§æ¨¡å¼åŒ¹é…

*** å€¼
è¿™ä¸ªå¾ˆç®€å•ï¼Œåº”è¯¥éƒ½æœ‰ç”¨è¿‡
#+BEGIN_SRC ruby
  me = 'ouyang'
  case me
  when 'ouyang' 
    "hehe #{me}"
  else 'hehe jichao'
  end
#+END_SRC

#+RESULTS:
: hehe ouyang

*** ç±»å‹
#+BEGIN_SRC ruby
  class Me
    def initialize name
      @name = name
    end

    def heheda
      "heheda #{@name}"
    end
  end

  me = Me.new 'ouyang'

  case me
  when Me
    me.heheda
  else
    'hehedale'
  end
#+END_SRC

: "heheda ouyang"

*** è¡¨è¾¾å¼
è·Ÿ =if else= ä¸€æ ·ç”¨
#+BEGIN_SRC ruby
require 'ostruct'
  me = OpenStruct.new(name: 'jichao', first_name: 'ouyang')
  case
  when me.name == 'jichao'
    "hehe #{me}"
  else 'gewuen'
  end
#+END_SRC

#+RESULTS:
: hehe #<OpenStruct name="jichao", first_name="ouyang">

*** lambda ï¼ˆaka guardï¼‰
#+BEGIN_SRC ruby
require 'ostruct'
  me = OpenStruct.new(name: 'jichao', first_name: 'ouyang')
  case me
  when ->(who){who.name=='jichao'}
    "hehe #{me}"
  end
#+END_SRC

#+RESULTS:
: hehe #<OpenStruct name="jichao", first_name="ouyang">

*** /æ­£åˆ™/
#+BEGIN_SRC ruby
case 'jichao ouyang'
when /ouyang/
"heheda"
end
#+END_SRC

#+RESULTS:
: heheda

*** å…¶å®åªæ˜¯ä¸ªç®€å•çš„è¯­æ³•ç³–
case when å¹¶ä¸æ˜¯magicï¼Œå…¶å®åªæ˜¯ if else çš„è¯­æ³•ç³–, æ¯”å¦‚ä¸Šé¢è¯´çš„æ­£åˆ™
#+BEGIN_SRC ruby
  if(/ouyang/ === 'jichao')
    "heheda"
  end
#+END_SRC

æ‰€ä»¥ magic åˆ™æ˜¯æ‰€æœ‰ when çš„å¯¹è±¡éƒ½å®ç°äº† ~===~ æ–¹æ³•è€Œå·²
- å€¼ï¼š ~object.===~ ä¼šä»£ç†åˆ° ~==~
- ç±»å‹ï¼š ~Module.===~ ä¼šçœ‹æ˜¯å¦æ˜¯å…¶ instance
- æ­£åˆ™ï¼š ~regex.===~ å¦‚æœåŒ¹é…è¿”å› true
- è¡¨è¾¾å¼ï¼šå–å†³äºè¡¨è¾¾å¼è¿”å›çš„å€¼çš„ ~===~ æ–¹æ³•
- lambdaï¼š ~proc.===~ ä¼šè¿è¡Œ lambda æˆ–è€… proc

è¿™æ ·ï¼Œæˆ‘ä»¬å¯ä»¥éšæ„ç»™ä»»ä½•ç±»åŠ ä¸Š ~===~ æ–¹æ³•, ä¸ä»…å¦‚æ­¤ï¼Œå®ç°ä¸€ä¸ªæŠ½è±¡æ•°æ®ç±»å‹ï¼ˆADTï¼‰ä¼šå˜å¾—æ˜¯åˆ†ç®€å•

* ä¸€ä¸ªç®€å•çš„ä¾‹å­
ä¸€ä¸ªç®€å•çš„ feeder æµç¨‹å¤§æ¦‚æ˜¯ï¼Œä»ä¸€ä¸ªæˆ–å¤šä¸ªæ•°æ®æºè·å–æ•°æ®å¹¶ feed åˆ°ä¸€ä¸ªåœ°æ–¹ï¼ˆDB, S3, ElasticSearchä¹‹ç±»)ã€‚é€šå¸¸æ˜¯ä¸€ä¸ªå®šæœŸçš„ä»»åŠ¡ï¼Œæ¯”å¦‚æ²¡å¤šä¹…å°± feed é‚£ä¹ˆä¸€æ¬¡ã€‚

ä½œä¸ºå®šæœŸè·‘çš„ä»»åŠ¡ï¼Œæˆ‘ä»¬éœ€è¦ç›‘æ§ä¸¤ä¸ªæ–¹é¢
- feed å¤±è´¥äº†å¤šå°‘
- feeder è·‘äº†æ²¡

ä¸ç®¡æ˜¯ä»€ä¹ˆå½¢å¼ï¼Œç›‘æ§éƒ½ä¸åº”è¯¥è·Ÿæˆ‘ä»¬çš„ä¸šåŠ¡æåˆ°ä¸€èµ·å»ï¼Œæ¯”å¦‚
** ä¸€ä¸ªç®€å•çš„ Either Monad[fn:2]
åˆ›å»ºä¸€ä¸ªåˆšå¥½å¤Ÿç”¨çš„ Either éå¸¸ç®€å•
*** Functor
#+BEGIN_SRC ruby :eval no
    module Either
      def initialize v
        @v = v
      end

      def map
        case self
        when Right
          Right.new(yield @v)
        else
          self
        end
      end
      alias :fmap :map
#+END_SRC
*** Monad
#+BEGIN_SRC ruby :eval no
  def bind
    case self
    when Right
      yield @v
    else
      self
    end
  end

  alias :chain :bind
  alias :flat_map :bind
#+END_SRC
*** ä¸€ä¸ªå¥½çœ‹çš„ inspect
#+BEGIN_SRC ruby :eval no
    def inspect
      case self
      when Left
        "#<Left value=#{@v}>"
      else
        "#<Right value=#{@v}>"
      end
    end
  end
#+END_SRC
*** è”åˆç±»å‹ Left | Right
åœ¨å®ç°äº† Either æ¥å£ä¹‹å,æˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“çš„å®ç°  Left | Right
#+BEGIN_SRC ruby :eval no
  class Left
    include Either
    def initialize v=nil
      @v=v
    end
  
    def == other
      case other
      when Left
        other.left_map { |v| return v == @v }
      else
        false
      end
    end
  end

  class Right
    include Either
    def == other
      case other
      when Right
        other.map { |v| return v == @v }
      else
        false
      end
    end
  end
#+END_SRC

è¿™ä¸ªEitheréå¸¸è½»é‡, æˆ‘è¿˜æ˜¯æŠŠå®ƒæŠ½æˆgemä»¥ä¾¿å•ç‹¬ç®¡ç†, ä¸å…¶ä»–ä¸€äº› Maybe å’Œ Free ä¸€å—æ”¶åˆ° [[https://github.com/jcouyang/cats.rb][cats.rb]] ä¸­.

** ç”¨ Either åšæ§åˆ¶æµ
#+BEGIN_SRC ruby -n -r :eval no 
  def run
    list_of_error_or_detail =
      listof_error_or_id.map do |error_or_id| # <- (ref:listof_error_or_id)
      error_or_id.flat_map do |id| # <- (ref:error_or_id)
        error_or_detail_of(id) # <- (ref:error_or_detail)
      end
    end
    list_of_error_or_detail.map { |error_or_detail| error_or_saved error_or_detail} # <- (ref:error_or_saved)
  end
#+END_SRC

1. [[(listof_error_or_id)][=listof_error_or_id=]] æ˜¯ä¸€ä¸ª IO, å»æŸä¸ªåœ°æ–¹æ‹¿ä¸€ä¸² id, æˆ–è€…è¿”å›ä¸€ä¸²é”™è¯¯, æ‰€ä»¥ç±»å‹æ˜¯ =[Either error id]=
2. æ‰€ä»¥ [[(error_or_id)][=error_or_id=]] çš„ç±»å‹æ˜¯ =Either error id=, =flat_map= å¯ä»¥æŠŠ =id= å–å‡ºæ¥, å¦‚æœæœ‰çš„è¯
3. å–å‡ºæ¥çš„ =id= äº¤ç»™ [[(error_or_detail)][=error_or_detail_of=]], è¯¥å‡½æ•°ä¹Ÿæ˜¯ IO, å¤æ‚è·å¾—å¯¹åº” id çš„ è¯¦ç»†ä¿¡æ¯, æ˜¯IOå°±æœ‰å¯èƒ½ä¼šæœ‰é”™è¯¯, æ‰€ä»¥è¿”å›å€¼ç±»å‹ä¹Ÿæ˜¯ =Either error detail=
4. è¿™æ—¶, å¦‚æœæ˜¯ç”¨ =fmap= è½¬æ¢å®Œæˆåä¼šå˜æˆä¸€ä¸ª =Either error (Either error detail)=. ä½†æ˜¾ç„¶æˆ‘ä»¬ä¸éœ€è¦åµŒå¥—è¿™ä¹ˆå¤šå±‚, =flat= ä¸€äº›ä¼šå˜æˆ =Either error detail=
5. åé¢çš„ save å‡½æ•°ä¹Ÿæ˜¯ç±»ä¼¼çš„ IO æ“ä½œ, è¿”å› =Either error saved=

é‚£ä¹ˆæˆ‘ä»¬çš„ä¸šåŠ¡é€»è¾‘çš„æµç¨‹èµ°å®Œäº†ï¼Œè¯¥è´Ÿè´£ç›‘æ§çš„é€»è¾‘äº†ï¼Œæ³¨æ„ç°åœ¨ run çš„è¿”å›å€¼ç±»å‹æ˜¯ =Either[Error, [Either[Error, Data]]]=

#+BEGIN_SRC ruby :eval no
  failures, success = run.partition {|lr| !lr.is_a? Right}
  error_msg = failures.map do |failure|
    failure.left_map &:message
  end.join "\n"
  logger.error "processing failure #{failues.length}:\n#{error_msg}" unless error_msg.blank?
  logger.info "processing success #{success.length}: #{success}"
#+END_SRC

* actor model å¤šçº¿ç¨‹
å½“ä½ çš„æ•°æ®å¤„ç†éƒ½æ˜¯å‡½æ•°å¼çš„ä¹‹åï¼Œæˆ–è€…è¯´ immutableï¼Œåº”ç”¨å¤šçº¿ç¨‹å°†æ˜¯ååˆ†ç®€å•è€Œä¸”å®‰å…¨çš„äº‹æƒ…, ä¸‹é¢ä¹Ÿæ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œä½¿ç”¨ [[https://github.com/celluloid/celluloid][Celluloid]] æŠŠæˆ‘ä»¬çš„ feeder æ”¹æˆå¤šçº¿ç¨‹

** pmap
#+BEGIN_SRC ruby :eval no
require "celluloid/autostart"
module Enumerable
  def pmap(&block)
    futures = map { |elem| Celluloid::Future.new(elem, &block) }
    futures.map(&:value)
  end
end
#+END_SRC

ä½ æ‡‚çš„ï¼ŒæŠŠæˆ‘ä»¬feederçš„ =map= éƒ½æ¢æˆ =pmap= ,å¤šçº¿ç¨‹å°±è¿™ä¹ˆç®€å•

* Footnotes

[fn:2] http://hackage.haskell.org/package/base-4.8.2.0/docs/src/Data.Either.html#Either

[fn:1] http://docs.ruby-lang.org/en/2.2.0/syntax/control_expressions_rdoc.html#label-case+Expression
