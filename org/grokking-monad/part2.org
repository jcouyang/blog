#+TITLE: èŒƒç•´è®ºå®Œå…¨è£…é€¼æ‰‹å†Œ(äºŒ) / Grokking Monad
#+Date: <2017-02-10 Fri>
#+AUTHOR: æ¬§é˜³ç»§è¶…
#+OPTIONS: ^:t
#+MACRO: ruby @@html:<ruby>$1<rt>$2</rt></ruby>@@

- [[./index.org][ç¬¬ä¸€éƒ¨åˆ†ï¼šèŒƒç•´è®º]]
- *[[./part2.org][ç¬¬äºŒéƒ¨åˆ†ï¼šé£Ÿç”¨çŒ«å‘¢]]* ğŸ‘ˆ

ç¬¬ä¸€éƒ¨åˆ†ç†è®ºéƒ¨åˆ†éƒ½è®²å®Œäº†ï¼Œ å¦‚æœä½ è¯»åˆ°è¿™é‡Œè¿˜æ²¡æœ‰è¢«è¿™äº›åŠç‚¸å¤©çš„æ¦‚å¿µædazeï¼Œæ¥ä¸‹æ¥å¯ä»¥çœ‹çœ‹å®ƒåˆ°åº•è·Ÿæˆ‘ä»¬ç¼–ç¨‹æœ‰é¸Ÿå…³ç³»å‘¢ï¼Ÿ

ç¬¬äºŒéƒ¨åˆ†å°†ä»‹ç»ç”±è¿™äº›æ¦‚å¿µäº§ç”Ÿçš„ä¸€äº›å®ç”¨çš„monad instancesï¼Œè¿™äº› monad éƒ½é€šè¿‡åŒæ ·çš„æŠ½è±¡æ–¹å¼ï¼Œè§£å†³äº†åˆ†ç¦»è®¡ç®—ä¸å‰¯ä½œç”¨çš„å·¥ä½œã€‚

æœ€åï¼Œæˆ‘ä»¬è¿˜å¯ä»¥åƒ IO monad ä¸€æ ·ï¼Œé€šè¿‡ free æˆ–è€… Eff è‡ªå®šä¹‰è‡ªå·±çš„è®¡ç®—ï¼Œå’Œå¯èƒ½å¸¦å‰¯ä½œç”¨çš„è§£é‡Šå™¨ã€‚

* TODO ç¬¬äºŒéƒ¨åˆ†ï¼š{{{ruby(é£Ÿç”¨çŒ«å‘¢, Practical Monads)}}}
ä¸€äº›æœ‰ç”¨çš„ Monad instances
** COMMENT Applicative
*** Alternative
*** Arrow
*** Bifunctor

** Identity
è¿™å¯èƒ½æ˜¯æœ€ç®€å•çš„ monad äº†ã€‚ä¸åŒ…å«ä»»ä½•è®¡ç®—
#+BEGIN_SRC haskell
newtype Identity a = Identity { runIdentity :: a } 
#+END_SRC
è¿™é‡Œä½¿ç”¨ =newtype= è€Œä¸æ˜¯ =data= æ˜¯å› ä¸º =Identity= ä¸ =runIdentity= æ˜¯ isomorphic çš„ã€‚

#+BEGIN_SRC haskell
Identity :: a -> Identity a
runIdentity :: Identity a -> a
#+END_SRC

** Maybe
è¿™æ˜¯ä¸€ä¸ªå†ç®€å•çš„ Monadï¼Œé¦–å…ˆï¼Œéœ€è¦å®šä¹‰è¿™ä¸ªä¸€ä¸ª {{{ruby(ä»£æ•°æ•°æ®ç±»å‹, Algebra Data Type(ADT))}}}
#+BEGIN_SRC haskell
data Maybe a = Just a | Nothing
#+END_SRC
Haskellä¸­å®šä¹‰ä¸€ä¸ªADTååˆ†ç®€å•ï¼Œä¸åƒScalaé‚£ä¹ˆå•°å—¦ã€‚å·¦è¾¹æ˜¯ç±»å‹ï¼Œå³è¾¹æœ‰ç±»å‹æ„é€ å™¨ï¼Œä½ ä¼šå‘ç°æœ‰ä¸€æ ¹ç«–çº¿ =|= ï¼Œ å®ƒåˆ†éš”ç€ä¸¤ä¸ªæ„é€ å™¨
- Just a
- Nothing
å…¶ä¸­ a ï¼ˆä¸€å®šè¦å°å†™ï¼‰å¯ä»¥æ˜¯ä»»æ„ç±»å‹

æ‰€ä»¥ =Just 1= ä¼šå¾—åˆ°ä¸€ä¸ª =Num a => Mabye a= ç±»å‹ï¼ˆæ„æ€å°±æ˜¯ =Maybe a= ä½†æ˜¯ =a= çš„ç±»å‹çº¦æŸä¸º =Num= ï¼‰ï¼Œ =Nothing= ä¹Ÿä¼šå¾—åˆ°ä¸€ä¸ª =Maybe a= åªä¸è¿‡ =a= æ²¡æœ‰ç±»å‹çº¦æŸã€‚

æ€»ä¹‹æˆ‘ä»¬æœ‰äº†æ„é€ å™¨å¯ä»¥æ„é€ å‡º Maybe ç±»å‹ï¼Œè€Œè¿™ä¸ªç±»å‹èƒ½åšçš„äº‹æƒ…ï¼Œå°±è¦å–å†³å®ƒå®ç°äº†å“ªäº› class çš„ instance äº†ã€‚


** Either

*** /Coproduct/
æ³¨æ„åˆ°ä¸¤ä¸ªæ„é€ å™¨çš„ç±»å‹åˆ†åˆ«ä¸º
- Just:: a -> Maybe a
- Nothing:: Maybe a

*** 
æ¯”å¦‚ï¼š Monad
#+BEGIN_SRC haskell
  instance Monad Maybe where
    Just a >>= f = f a
    Nothing >>= f = Nothing
#+END_SRC

** Validate
** Reader
ç»™ä¸€ä¸ªcomputationå–‚æ•°æ®
è¾“å…¥ r
asks å¯ä»¥é€šè¿‡å‡½æ•° r->a å¾—åˆ°ä¸€ä¸ª Reader r a monad
#+BEGIN_SRC haskell
asks :: (r -> a) -> Reader r a
runReader :: Reader r a -> r -> a

import Control.Monad.Reader

data MyContext = MyContext
  { foo :: String
  , bar :: Int
  } deriving (Show)

computation :: Reader MyContext (Maybe String)
computation = do
  n <- asks bar
  x <- asks foo
  if n > 0
    then return (Just x)
    else return Nothing

ex1 :: Maybe String
ex1 = runReader computation $ MyContext "hello" 1

ex2 :: Maybe String
ex2 = runReader computation $ MyContext "haskell" 0
#+END_SRC
** Writter
é™¤äº†è¿”å›å€¼ï¼Œcomputationä¼šå†™ä¸€äº›é¢å¤–çš„æ•°æ®

è¿”å›å€¼ä¼šæ˜¯ä¸€ä¸ªè¿™æ · =(result, log)= çš„ tuple

é™åˆ¶æ˜¯ log çš„ç±»å‹å¿…é¡»æ˜¯ä¸ª monoid

#+BEGIN_SRC haskell
example  = do
  tell [1..3]
  tell [3..5]
  return "foo"

output :: (String, [Int])
output = runWriter example
-- ("foo", [1, 2, 3, 3, 4, 5])
#+END_SRC
** State

** RWS
** Expection
** Monad Transform
** Cont
** MonadPlus
** MonadFix
** ST
** Free Monad
** Eff

** References
- https://wiki.haskell.org/All_About_Monads
