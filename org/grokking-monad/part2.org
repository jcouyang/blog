#+TITLE: èŒƒç•´è®ºå®Œå…¨è£…é€¼æ‰‹å†Œ(äºŒ) / Grokking Monad
#+Date: <2017-02-10 Fri>
#+AUTHOR: æ¬§é˜³ç»§è¶…
#+OPTIONS: ^:t
#+MACRO: ruby @@html:<ruby>$1<rt>$2</rt></ruby>@@

- [[./index.org][ç¬¬ä¸€éƒ¨åˆ†ï¼šèŒƒç•´è®º]]
- *[[./part2.org][ç¬¬äºŒéƒ¨åˆ†ï¼šé£Ÿç”¨çŒ«å‘¢]]* ğŸ‘ˆ

ç¬¬ä¸€éƒ¨åˆ†ç†è®ºéƒ¨åˆ†éƒ½è®²å®Œäº†ï¼Œ å¦‚æœä½ è¯»åˆ°è¿™é‡Œè¿˜æ²¡æœ‰è¢«è¿™äº›åŠç‚¸å¤©çš„æ¦‚å¿µædazeï¼Œæ¥ä¸‹æ¥å¯ä»¥çœ‹çœ‹å®ƒåˆ°åº•è·Ÿæˆ‘ä»¬ç¼–ç¨‹æœ‰é¸Ÿå…³ç³»å‘¢ï¼Ÿ

ç¬¬äºŒéƒ¨åˆ†å°†ä»‹ç»ç”±è¿™äº›æ¦‚å¿µäº§ç”Ÿçš„ä¸€äº›å®ç”¨çš„monad instancesï¼Œè¿™äº› monad éƒ½é€šè¿‡åŒæ ·çš„æŠ½è±¡æ–¹å¼ï¼Œè§£å†³äº†åˆ†ç¦»è®¡ç®—ä¸å‰¯ä½œç”¨çš„å·¥ä½œã€‚

æœ€åï¼Œæˆ‘ä»¬è¿˜å¯ä»¥åƒ IO monad ä¸€æ ·ï¼Œé€šè¿‡ free æˆ–è€… Eff è‡ªå®šä¹‰è‡ªå·±çš„è®¡ç®—ï¼Œå’Œå¯èƒ½å¸¦å‰¯ä½œç”¨çš„è§£é‡Šå™¨ã€‚
* COMMENT
#+BEGIN_SRC emacs-lisp
(require 'ob-haskell)
#+END_SRC

#+RESULTS:
: ob-haskell

* TODO ç¬¬äºŒéƒ¨åˆ†ï¼š{{{ruby(é£Ÿç”¨çŒ«å‘¢, Practical Monads)}}}
ä¸€äº›æœ‰ç”¨çš„ Monad instances
** COMMENT Applicative
*** Alternative
*** Arrow
*** Bifunctor

** Identity
è¿™å¯èƒ½æ˜¯æœ€ç®€å•çš„ monad äº†ã€‚ä¸åŒ…å«ä»»ä½•è®¡ç®—
#+BEGIN_SRC haskell
newtype Identity a = Identity { runIdentity :: a } 
#+END_SRC
è¿™é‡Œä½¿ç”¨ =newtype= è€Œä¸æ˜¯ =data= æ˜¯å› ä¸º =Identity= ä¸ =runIdentity= æ˜¯ isomorphic ï¼ˆåŒæ„ï¼Œå¿˜äº†çš„è¯å›å»ç¿»ç¬¬ä¸€éƒ¨åˆ†ï¼‰

#+BEGIN_SRC haskell
Identity :: a -> Identity a
runIdentity :: Identity a -> a
#+END_SRC

æ‰€ä»¥ ~runIdentity . Identity = id~ ï¼Œæ‰€ä»¥ä»–ä»¬æ˜¯åŒæ„çš„ã€‚

å·¦è¾¹çš„ =Identity= æ˜¯ç±»å‹æ„é€ å™¨, æ¥æ”¶ç±»å‹ =a= è¿”å› =Identity a= ç±»å‹

å¦‚æœ a æ˜¯ Intï¼Œé‚£ä¹ˆå°±å¾—åˆ°ä¸€ä¸ª =Identity Int= ç±»å‹ã€‚

å³è¾¹çš„ =Identity= æ˜¯æ•°æ®æ„é€ å™¨ï¼Œä¹Ÿå°±æ˜¯æ„é€ å€¼ï¼Œæ¯”å¦‚ =Identity 1= ä¼šæ„é€ å‡ºä¸€ä¸ªå€¼ï¼Œå…¶ç±»å‹ä¸º =Identity Int=

å¤§æ‹¬å·æ¯”è¾ƒè¯¡å¼‚ï¼Œå¯ä»¥æƒ³è±¡æˆç»™ =a= ä¸€ä¸ª keyï¼ŒåŒè¿‡è¿™ä¸ª key å¯ä»¥æŠŠ a å–å‡ºæ¥ï¼Œæ¯”å¦‚
#+BEGIN_SRC haskell
runIdentity (Identity 1)
#+END_SRC
ä¼šè¿”å› 1

Identity å¯ä»¥å®ç° Functor å’Œ Monadï¼Œå°±å¾—åˆ° Identity functor å’Œ Identity monad
#+BEGIN_SRC haskell
  instance Functor Identity where
    fmap f (Identity a) = Identity (f a)

  instance Monad Identity where
    return a = Identity a
    Identity a >>= f = f a
#+END_SRC

å¯ä»¥çœ‹åˆ° Identity å³æ˜¯æ„é€ å™¨ï¼Œä¹Ÿæ˜¯è§£æ„å™¨ï¼Œåœ¨æ¨¡å¼åŒ¹é…æ˜¯å¯ä»¥ destructure å€¼ã€‚ä¾‹å¦‚ä¸Šé¢Functor å®ç°ä¸­çš„ =fmap f (Identity a)= , å‡å¦‚fmapçš„æ˜¯ =Identity 1=, é‚£ä¹ˆè¿™ä¸ªæ¨¡å¼åŒ¹é…åˆ° =(Identity a)= æ—¶ä¼šæŠŠ =1= æ”¾åˆ° =a= çš„ä½ç½®ã€‚

Identity çœ‹èµ·æ¥ä»€ä¹ˆä¹Ÿæ²¡æœ‰å¹²ï¼Œå°±è·Ÿ identity å‡½æ•°ä¸€æ ·ï¼Œä½†æ˜¯åœ¨åé¢è®²åˆ° State monadæ—¶ä½ ä¼šå‘ç°ä»–çš„ä»·å€¼ã€‚

** Maybe
è¿™æ˜¯ä¸€ä¸ªè¶…çº§ç®€å•çš„ Monadï¼Œé¦–å…ˆï¼Œéœ€è¦å®šä¹‰è¿™ä¸ªä¸€ä¸ª {{{ruby(ä»£æ•°æ•°æ®ç±»å‹, Algebra Data Type(ADT))}}}
#+BEGIN_SRC haskell
data Maybe a = Just a | Nothing
#+END_SRC
Haskellä¸­å®šä¹‰ä¸€ä¸ªADTååˆ†ç®€å•ï¼Œä¸åƒScalaé‚£ä¹ˆå•°å—¦ã€‚å·¦è¾¹æ˜¯ç±»å‹æ„é€ å™¨ï¼Œå³è¾¹æœ‰æ•°æ®æ„é€ å™¨ï¼Œä½ ä¼šå‘ç°æœ‰ä¸€æ ¹ç«–çº¿ =|= ï¼Œ å®ƒåˆ†éš”ç€ä¸¤ä¸ªæ„é€ å™¨
- Just
- Nothing
å…¶ä¸­ a ï¼ˆä¸€å®šè¦å°å†™ï¼‰å¯ä»¥æ˜¯ä»»æ„ç±»å‹

æ‰€ä»¥ =Just 1= ä¼šå¾—åˆ°ä¸€ä¸ª =Num a => Mabye a= ç±»å‹ï¼ˆæ„æ€å°±æ˜¯ =Maybe a= ä½†æ˜¯ =a= çš„ç±»å‹çº¦æŸä¸º =Num= ï¼‰ï¼Œ =Nothing= ä¹Ÿä¼šå¾—åˆ°ä¸€ä¸ª =Maybe a= åªä¸è¿‡ =a= æ²¡æœ‰ç±»å‹çº¦æŸã€‚

æ€»ä¹‹æˆ‘ä»¬æœ‰äº†æ„é€ å™¨å¯ä»¥æ„é€ å‡º Maybe ç±»å‹ï¼Œè€Œè¿™ä¸ªç±»å‹èƒ½åšçš„äº‹æƒ…ï¼Œå°±è¦å–å†³å®ƒå®ç°äº†å“ªäº› class çš„ instance äº†ã€‚æ¯”å¦‚å®ƒå¯ä»¥æ˜¯ä¸€ä¸ª Functor
#+BEGIN_SRC haskell
  instance Functor Maybe where
    fmap f (Just a) = Just (f a)
#+END_SRC

#+CAPTION: fmap :: (a -> b) -> f a -> f b
https://www.evernote.com/l/ABeKvGaM2S1LV5QzdmQv_U98pCX164j7-2MB/image.png

ç„¶åï¼Œè¿˜å®ç° Monad
#+BEGIN_SRC haskell
  instance Monad Maybe where
    return a = Just a
    (Just a) >>= f = f a
    Nothing >>= f = Nothing
#+END_SRC

#+CAPTION: è¿˜è®°å¾—ç¬¬ä¸€éƒ¨åˆ†æåˆ°çš„ Kleisli èŒƒç•´å—ï¼Ÿ
https://www.evernote.com/l/ABfAhPgWI_5Awbov_2gLY_BcB9CwKyIJZjYB/image.png

Maybe æœ‰ç”¨åœ¨äºèƒ½åˆé€‚çš„å¤„ç† /{{{ruby(åå‡½æ•°, Partial Function)}}}/ çš„è¿”å›å€¼ã€‚åå‡½æ•°ç›¸å¯¹äº{{{ruby(å…¨å‡½æ•°, Total Function)}}}ï¼Œæ˜¯æŒ‡åªèƒ½å¯¹éƒ¨åˆ†è¾“å…¥è¿”å›è¾“å‡ºçš„å‡½æ•°ã€‚

æ¯”å¦‚ä¸€ä¸ªå–æ•°ç»„æŸä¸€ä½ä¸Šçš„å€¼çš„å‡½æ•°ï¼Œå°±æ˜¯åå‡½æ•°ï¼Œå› ä¸ºå‡è®¾ä½ æƒ³å–ç¬¬4ä½çš„å€¼ï¼Œä½†ä¸æ˜¯æ‰€æœ‰æ•°ç»„é•¿åº¦éƒ½å¤§äº4ï¼Œå°±ä¼šæœ‰è·å–ä¸äº†çš„å°´å°¬æƒ…å†µã€‚
#+BEGIN_SRC haskell
[1,2,3] !! 4
#+END_SRC

å¦‚æœä½¿ç”¨ Maybe æŠŠåå‡½æ•°å¤„ç†ä¸äº†çš„è¾“å…¥éƒ½è¿”å›æˆ Nothingï¼Œè¿™æ ·ç»“æœä¾ç„¶ä¿æŒ Maybe ç±»å‹ï¼Œä¸å½±å“åé¢çš„è®¡ç®—ã€‚

** Either

Either çš„å®šä¹‰ä¹Ÿå¾ˆç®€å•
#+BEGIN_SRC haskell
data Either a b = Left a | Right b
#+END_SRC

*** Product & Coproduct
çœ‹è¿‡ç¬¬ä¸€éƒ¨åˆ†åº”è¯¥è¿˜èƒ½è®°å¾—æœ‰ä¸€ä¸ªä¸œè¥¿å« Duelï¼Œæ‰€ä»¥è§åˆ°å¦‚æœèŒƒç•´ä¸Šæœ‰ Coproduct é‚£ä¹ˆè‚¯å®šåœ¨duelèŒƒç•´ä¸Šä¼šæœ‰åŒæ ·çš„ä¸œè¥¿å« Productã€‚

é‚£ä¹ˆæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ä»€ä¹ˆæ˜¯ Coproduct

#+CAPTION: Coproduct
https://www.evernote.com/l/ABeCtsXrN7xCWqa7bsNAU0eVQVTDdkRKqVEB/image.png

åƒè¿™æ ·ï¼Œèƒ½é€šè¿‡ä¸¤ä¸ªç®­å¤´åˆ°è¾¾åŒä¸€ä¸ªä¸œè¥¿ï¼Œå°±æ˜¯ Coproductã€‚è¿™é‡Œç®­å¤´ =Left= èƒ½è®© =a= åˆ° =Either a b= ï¼Œ ç®­å¤´ =Right= ä¹Ÿèƒ½è®© =b= åˆ°è¾¾ =Either a b=

æœ‰æ„æ€çš„æ˜¯è¿˜è‚¯å®šå­˜åœ¨ä¸€ä¸ª Coproduct å’Œ ç®­å¤´ï¼Œä½¿å¾—ä¸‹å›¾æˆç«‹
https://www.evernote.com/l/ABfP9Sz8diJFxoXCJpjHeo_gF5JAmsiFvPYB/image.png

ç®­å¤´åè¿‡æ¥ï¼Œå°±æ˜¯ Product, æ¯”å¦‚ Tuple

#+CAPTION: Product
https://www.evernote.com/l/ABea91BEgH5OH41WorLYjqichYC0rmVCAXMB/image.png

Tuple çš„ =fst= ç®­å¤´èƒ½è®© =(a, b)= åˆ°è¾¾ =a= å¯¹è±¡ï¼Œè€Œç®­å¤´ =snd= èƒ½è®©å…¶åˆ°è¾¾ =b= å¯¹è±¡ã€‚

*** Either Monad
ç¡®åˆ‡çš„è¯´ï¼ŒEither ä¸æ˜¯ monadï¼Œ =Either a= æ‰æ˜¯ã€‚è¿˜è®°å¾— monad çš„ class å®šä¹‰å—ï¼Ÿ
#+BEGIN_SRC haskell
class Endofunctor m => Monad m where
  eta :: a -> (m a)
  mu :: m m a -> m a
#+END_SRC
æ‰€ä»¥ m å¿…é¡»æ˜¯ä¸ª Endofunctorï¼Œä¹Ÿå°±æ˜¯è¦æ»¡è¶³Functor
#+BEGIN_SRC haskell
class Functor t where
  fmap :: (a -> b) -> (t a -> t b)
#+END_SRC
t a çš„ kind æ˜¯ *ï¼Œæ‰€ä»¥ t å¿…é¡»æ˜¯ kind * -> *
ä¹Ÿå°±æ˜¯è¯´ï¼Œm å¿…é¡»æ˜¯æ¥æ”¶ä¸€ä¸ªç±»å‹å‚æ•°çš„ç±»å‹æ„é€ å™¨

è€Œ Either çš„ kind æ˜¯ * -> * -> *, Either a æ‰æ˜¯ * -> *

æ‰€ä»¥åªèƒ½å®šä¹‰ Either a çš„ Monad
#+BEGIN_SRC haskell
  instance Monad (Either a) where
    Left  l >>= _ = Left l
    Right r >>= k = k r
#+END_SRC

å¾ˆæ˜æ˜¾çš„ï¼Œ>>= ä»»ä½•å‡½æ•°åˆ°{{{ruby(å·¦è¾¹, Left)}}} éƒ½ä¸ä¼šæ”¹å˜ï¼Œåªæœ‰ >>= å³è¾¹æ‰èƒ½äº§ç”Ÿæ–°çš„è®¡ç®—ã€‚

** TODO Validate
** Reader
Reader çš„ä½œç”¨æ˜¯ç»™ä¸€ä¸ªè®¡ç®—å–‚æ•°æ®ã€‚

åœ¨æè¿°è®¡ç®—çš„æ—¶å€™ï¼Œå¹¶ä¸éœ€è¦å…³å¿ƒè¾“å…¥æ—¶ä»€ä¹ˆï¼Œåªéœ€è¦ asks å°±å¯ä»¥æ‹¿åˆ°è¾“å…¥å€¼

è€ŒçœŸæ­£çš„è¾“å…¥ï¼Œä¼šåœ¨è¿è¡Œè®¡ç®—æ—¶ç»™äºˆã€‚

è·Ÿ Identity ä¸€æ ·ï¼Œæˆ‘ä»¬ç”¨ newtype æ¥å®šä¹‰ä¸€ä¸ªåŒæ„çš„ Reader ç±»å‹
#+BEGIN_SRC haskell
newtype Reader e a = Reader { runReader :: (e -> a) }
#+END_SRC

å…¶ä¸­
- e æ˜¯è¾“å…¥
- a æ˜¯ç»“æœ
- æ„é€  Reader ç±»å‹éœ€è¦ç¡®å®š è¾“å…¥çš„ç±»å‹ e ä¸è¾“å‡ºçš„ç±»å‹ a
- =runReader= çš„ç±»å‹æ˜¯ =runReader:: (Reader e a) -> (e -> a)=

ä¹Ÿå°±æ˜¯è¯´åœ¨æè¿°å®Œä¸€ä¸ª Reader çš„è®¡ç®—åï¼Œä½¿ç”¨ runReader å¯ä»¥å¾—åˆ°ä¸€ä¸ª e -> a çš„å‡½æ•°ï¼Œä½¿ç”¨è¿™ä¸ªå‡½æ•°ï¼Œå°±å¯ä»¥æ¥æ”¶è¾“å…¥ï¼Œé€šè¿‡æ„é€ å¥½çš„è®¡ç®—ï¼Œç®—å‡ºç»“æœ a è¿”å›ã€‚

é‚£ä¹ˆï¼Œè®©æˆ‘ä»¬æ¥å®ç° Reader çš„ monad instanceï¼Œå°±å¯ä»¥æè¿°ä¸€ä¸ªå¯ä»¥ ask çš„è®¡ç®—äº†ã€‚

#+BEGIN_SRC haskell
instance Monad (Reader e) where 
    return a         = Reader $ \_ -> a 
    (Reader g) >>= f = Reader $ \e -> runReader (f (g e)) e
#+END_SRC

è·ŸEitherä¸€æ ·ï¼Œæˆ‘ä»¬åªèƒ½å®šä¹‰ Reader e çš„ monad instanceã€‚

æ³¨æ„è¿™é‡Œçš„ 
- f ç±»å‹æ˜¯ =(a -> Reader e a)=
- g å…¶å®å°±æ˜¯æ˜¯ destructure å‡ºæ¥çš„ runReaderï¼Œä¹Ÿå°±æ˜¯ e -> a
- æ‰€ä»¥ (g e) è¿”å› a
- f (g e) å°±æ˜¯ =Reader e a=
- å† run ä¸€æŠŠæœ€åå¾—åˆ° a

#+CAPTION: f å‡½æ•°ï¼Œæ¥æ”¶ a è¿”å›ä¸€ä¸ª ä» e åˆ° a çš„ Reader
https://www.evernote.com/l/ABeL9xOcX7VNmJdaq49OSQf0ejRLsz_EWZ0B/image.png

è®©æˆ‘ä»¬æ¥çœ‹çœ‹å¦‚ä½•ä½¿ç”¨ Reader
#+BEGIN_SRC haskell
  import Control.Monad.Reader

  data Environment = Env
    { fistName :: String
    , lastName :: String
    } deriving (Show)

  helloworld :: Reader Environment String
  helloworld = do
    f <- asks firstName
    l <- asks lastName
    return "Hello " ++ f ++ l

  runHelloworld :: String
  runHelloworld = runReader helloworld $ Env "Jichao" "Ouyang"
#+END_SRC

è¿™æ®µä»£ç å¾ˆç®€å•ï¼Œhelloworld è´Ÿè´£æ‰“æ‹›å‘¼ï¼Œä¹Ÿå°±æ˜¯åœ¨åå­—å‰é¢åŠ ä¸ª "Hello"ï¼Œè€Œè·Ÿè°æ‰“æ‹›å‘¼ï¼Œè¿™ä¸ªå‡½æ•°å¹¶ä¸å…³å¿ƒï¼Œè€Œå•çº¯çš„æ˜¯å‘ Environment {{{ruby(é—®,asks)}}} å°±å¥½ã€‚

#+CAPTION: asks å¯ä»¥å°† e -> a çš„å‡½æ•°å˜æ¢æˆ Reader e a
https://www.evernote.com/l/ABejjs0RksRL_LOo2jgoUk1bT54BBfMCqNAB/image.png

åœ¨è¿è¡Œæ—¶ï¼Œå¯ä»¥æä¾›ç»™ Reader çš„è¾“å…¥ Env fistname lastnameã€‚
https://www.evernote.com/l/ABc5cVh6zMND1KHY42FYTyRWzdfPcP4YYdEB/image.png

*** do notation
è¿™å¯èƒ½æ˜¯ä½ ç¬¬ä¸€æ¬¡è§åˆ° =do= å’Œ =<-=. å¦‚æœä¸æ˜¯ï¼Œéšæ„è·³è¿‡è¿™èŠ‚ã€‚

- do ä¸­æ‰€æœ‰ <- çš„å³è¾¹éƒ½æ˜¯ =Reader Environment String= ç±»å‹
- do ä¸­çš„ return è¿”å›ç±»å‹ä¹Ÿå¿…é¡»ä¸º  =Reader Environment String=
- =asks firstName= è¿”å›çš„æ˜¯ =Reader Environment String= ç±»å‹ï¼Œ =<-= å¯ä»¥ç†è§£æˆå§ monad =Reader Environment= çš„å†…å®¹æ”¾åˆ°å·¦è¾¹çš„ f, æ‰€ä»¥ f çš„ç±»å‹æ˜¯ Stringã€‚

çœ‹èµ·æ¥åƒå‘½ä»¤å¼çš„è¯­å¥ï¼Œå…¶å®åªæ˜¯ ~>>=~ çš„è¯­æ³•ç³–ï¼Œä½†æ˜¯æ˜æ˜¾ç”¨doå¯è¯»æ€§è¦é«˜å¾ˆå¤šã€‚
#+BEGIN_SRC haskell
  helloworld = (asks firstName) >>=
    \f -> (asks lastName) >>=
         \l -> return "Hello " ++ f ++ l
#+END_SRC


** Writer

é™¤äº†è¿”å›å€¼ï¼Œè®¡ç®—ä¼šéœ€è¦äº§ç”Ÿä¸€äº›é¢å¤–çš„æ•°æ®ï¼Œæ¯”å¦‚ log

æ­¤æ—¶å°±éœ€è¦ä¸€ä¸ª Writterï¼Œå…¶è¿”å›å€¼ä¼šæ˜¯ä¸€ä¸ªè¿™æ · =(result, log)= çš„ tuple

é™åˆ¶æ˜¯ log çš„ç±»å‹å¿…é¡»æ˜¯ä¸ª {{{ruby(å«å¹ºåŠç¾¤,monoid)}}}

#+BEGIN_SRC haskell
example :: Writer String String
example  = do
  tell "How are you?"
  tell "I'm fine thank you, and you?"
  return "Hehe Da~"

output :: (String, String)
output = runWriter example
-- ("Hehe Da~", "How are you?I'm fine thank you, and you?")
#+END_SRC

Writer çš„å®šä¹‰æ›´ç®€å•
#+BEGIN_SRC haskell
newtype Writer l a = Writer { runWriter :: (a,l) } 
#+END_SRC
é‡Œé¢åªæ˜¯ä¸€ä¸ª tuple è€Œå·²
- w æ˜¯ log
- a æ˜¯ è¿”å›å€¼

çœ‹çœ‹å¦‚ä½•å®ç° Writer monad
#+BEGIN_SRC haskell
  instance (Monoid w) => Monad (Writer w) where 
      return a             = Writer (a,mempty) 
      (Writer (a,l)) >>= f = let (a',l') = runWriter $ f a in
                             Writer (a',l `mappend` l')
#+END_SRC

- return ä¸ä¼šæœ‰ä»»ä½• logï¼Œl æ˜¯ monoid çš„ mempty
- f çš„ç±»å‹ä¸º =a -> Writer l a=
- =runWriter $ f a= è¿”å› =(a, l)=

https://www.evernote.com/l/ABeB64fSK2BO27_IffFrMrIYjglJrp5rb5sB/image.png

æ‰€ä»¥åœ¨ >>= æ—¶ï¼Œæˆ‘ä»¬å…ˆæŠŠ f a è¿”å›çš„ Writer runäº†ï¼Œç„¶åæŠŠä¸¤æ¬¡ log =mappend= èµ·æ¥ã€‚

https://www.evernote.com/l/ABeLJJ_cN0JJa5PqDPVlKk4Tt0oAvBKnxf4B/image.png

** State
è·Ÿåå­—å°±çœ‹å¾—å‡ºæ¥ State monad æ˜¯ä¸ºäº†å¤„ç†çŠ¶æ€ã€‚è™½ç„¶å‡½æ•°å¼ç¼–ç¨‹ä¸åº”è¯¥æœ‰çŠ¶æ€ï¼Œä¸ç„¶ä¼šå¼•ç”¨é€æ˜æ€§ã€‚ä½†æ˜¯ï¼Œstate monadå¹¶ä¸æ˜¯åœ¨è®¡ç®—è¿‡ç¨‹ä¸­ä¿®æ”¹çŠ¶æ€ï¼Œè€Œæ˜¯é€šè¿‡æè¿°è¿™ç§å˜åŒ–ï¼Œç„¶åéœ€è¦æ—¶åœ¨è¿è¡Œè¿”å›æœ€ç»ˆç»“æœã€‚è¿™ä¸€ç‚¹è·Ÿ Reader å’Œ Writer è¿™ä¸¤ä¸ªçœ‹èµ·æ¥æ˜¯å‰¯ä½œç”¨çš„ IO æ˜¯ä¸€æ ·çš„ã€‚

å…ˆçœ‹ä¸‹ State ç±»å‹çš„å®šä¹‰
#+BEGIN_SRC haskell
newtype State s a = State { runState :: s -> (a, s) }
#+END_SRC

å¯ä»¥çœ‹åˆ° State åªåŒ…å«ä¸€ä¸ª ä»æ—§çŠ¶æ€ s åˆ°æ–°çŠ¶æ€ s å’Œè¿”å›å€¼ a çš„ Tuple çš„å‡½æ•°ã€‚

é€šè¿‡å®ç° Monadï¼ŒState å°±å¯ä»¥å®ç°å‘½ä»¤å¼ç¼–ç¨‹ä¸­çš„å˜é‡çš„åŠŸèƒ½ã€‚
#+BEGIN_SRC haskell
  instance Monad (State s) where 
    return a        = State $ \s -> (a,s)
    (State x) >>= f = State $ \s -> let (v,s') = x s in
                                   runState (f v) s'
#+END_SRC
return å¾ˆç®€å•ï¼Œå°±ä¸ç”¨è§£é‡Šäº†ã€‚

https://www.evernote.com/l/ABdBcGXH7T9FDoePyOg564ey9Kg7kndHtNUB/image.png

x ç±»å‹æ˜¯ =s -> (a, s)= ,æ‰€ä»¥ x s ä¹‹åä¼šè¿”å› ç»“æœå’ŒçŠ¶æ€ã€‚ä¹Ÿå°±æ˜¯è¿è¡Œå½“å‰ Stateï¼ŒæŠŠç»“æœ v ä¼ ç»™å‡½æ•° fï¼Œè¿”å›çš„ State å†æ¥ç€ä¸Šæ¬¡çŠ¶æ€è¿è¡Œã€‚

#+CAPTION: State x >>= f årunStateçš„æ•°æ®æµï¼ˆå•Šå•Šå•Šï¼Œç”»æ­ªäº†ï¼Œæ„Ÿè§‰éœ€è¦è„‰åŠ¨ä¸€ä¸‹ï¼‰
https://www.evernote.com/l/ABdHal0u69ZNBqHpPWJp-Dc6KC_yvQ1t3tsB/image.png

ä½¿ç”¨èµ·æ¥ä¹Ÿå¾ˆæ–¹ä¾¿ï¼ŒState æä¾› =get= =put= =moidfy= ä¸‰ä¸ªæ–¹ä¾¿çš„å‡½æ•°å¯ä»¥ç”Ÿæˆä¿®æ”¹çŠ¶æ€çš„State monad

#+BEGIN_SRC haskell :results output
  import Control.Monad.Trans.State.Strict
  test :: State Int Int
  test = do
    a <- get
    modify (+1)
    b <- get
    return (a + b)
  
  main = print $ show $ runState test 3
  -- (7, 4)
#+END_SRC

** RWS
** Expection
** Monad Transform
** Cont
** MonadPlus
** MonadFix
** ST
** Free Monad
** Eff

** References
- https://wiki.haskell.org/All_About_Monads
