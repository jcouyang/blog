#+TITLE: èŒƒç•´è®ºå®Œå…¨è£…é€¼æ‰‹å†Œ / Grokking Monad
#+Date: <2017-02-10 Fri>
#+AUTHOR: æ¬§é˜³ç»§è¶…
#+OPTIONS: ^:t
#+MACRO: ruby @@html:<ruby>$1<rt>$2</rt></ruby>@@

- *[[./index.org][ç¬¬ä¸€éƒ¨åˆ†ï¼šèŒƒç•´è®º]]* ğŸ‘ˆ
- [[./part2.org][ç¬¬äºŒéƒ¨åˆ†ï¼šé£Ÿç”¨çŒ«å‘¢]]

å¾ˆå¤šäººéƒ½ä¸æ˜ç™½ä»€ä¹ˆæ˜¯Monadï¼Œå¹¶ä¸æ˜¯å› ä¸ºä¸ä¼šç”¨ï¼Œä¸çŸ¥è§‰å¯èƒ½å°±åœ¨ç”¨æŸç§ monadã€‚\\
å®šä¹‰å’Œä½¿ç”¨èµ·æ¥å…¶å®ä¸éš¾ï¼Œå›°æƒ‘çš„å¤§å¤šåº”è¯¥æ˜¯åé¢çš„è¿™å †ç†è®º-- èŒƒç•´è®ºã€‚å½“ç„¶ï¼Œæˆ‘ä¹Ÿæ²¡å­¦è¿‡èŒƒç•´è®ºï¼Œåªæ˜¯ç•¥å¾®çœ‹å¾—æ‡‚å†™Haskellç½¢äº†ã€‚

æˆ‘åœ¨ä¹¦ä¸­[[https://book.douban.com/subject/26883736/][å†™è¿‡ä¸€ç« ]]æ¥è§£é‡Šï¼ŒæŸäººä¹Ÿå°è¯•è¿‡å¾ˆ[[http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html][å†™åšå®¢è§£é‡Š]]ï¼Œæ¯”å¦‚ä¸ºäº†é™ä½é—¨æ§›ç”¨JSæ¥ï¼Œé‚£Haskell/Scalaçš„äººå‡ºæ¥å–·ä½ ä»¬å‰ç«¯è¿™äº›ä¸æ‡‚å‡½æ•°å¼çš„æ¸£æ¸£ä¹±æå‡ºæ¥çš„ä¸œè¥¿æ ¹æœ¬å°±ä¸æ˜¯ monadã€‚

æˆ‘ä¹Ÿç”»è¿‡ä¸€äº›å›¾æ¥è§£é‡Šï¼Œåˆä¼šè¢«å«Œå¼ƒç”»é£ä¸å¥½ã€‚ä½†æ˜¯ï¼Œä½œä¸ºçµé­‚ç”»å¸ˆï¼Œæˆ‘åª +æ˜¯è§‰å¾—è‡ªå·±èŒèŒçš„å•Š+ åœ¨ä¹ç”»çš„çµé­‚æ˜¯å¦èƒ½å¤Ÿç»™ä½ ä¸€ç‚¹å¯å‘ã€‚å¥½å§ï¼Œè®²è¿™ä¹ˆå­¦æœ¯çš„ä¸œè¥¿ï¼Œè¿˜æ˜¯ç”¨dotæ¥ç”»å§ï¼Œçœ‹èµ·æ¥å¥½æ­£è§„å‘¢ã€‚

å¥½äº†ï¼Œå®‰å…¨å¸¦ç³»å¥½ï¼Œæˆ‘çœŸçš„è¦å¼€è½¦äº†ã€‚ä¸ºäº† +é˜²æ­¢é„™è§†é“¾é¡¶ç«¯çš„è¯­è¨€ç”¨æˆ·ä»¬å–·å†å«Œå¼ƒ+ è§£é‡Šçš„ä¸åˆ°ä½ï¼Œå°±ç”¨ Haskell å¥½äº†ï¼ˆè™½ç„¶haskellä¹Ÿæ²¡åˆ°é„™è§†é“¾é¡¶ï¼‰ï¼Œå…¶å®ä¹Ÿä¸éš¾è§£é‡Šæ¸…æ¥š +æ‰æ€ª+ ã€‚

è¿™é‡Œé¢å¾ˆå¤šå¾ˆè£…é€¼çš„å•è¯ï¼Œå®ƒä»¬éƒ½æ˜¯ /æ–œä½“/ ï¼Œå°±ç®—æ²¡çœ‹æ‡‚ï¼ŒæŠŠè¿™äº›è¯è®°ä½ä¹Ÿè¶³å¤Ÿ{{{ruby(è£…ä¸€é˜µå­é€¼äº†,ä¹°ä¸€é˜µå­èŒäº†)}}}ã€‚

* COMMENT
#+BEGIN_SRC emacs-lisp
(require 'ob-dot)
#+END_SRC

#+RESULTS:
: ob-dot

* ç¬¬ä¸€éƒ¨åˆ†ï¼š{{{ruby(èŒƒç•´è®º,Catergory Theory)}}}
** /Category/
#+INDEX: Catergory
#+INDEX: èŒƒç•´

ä¸€ä¸ª /{{{ruby(èŒƒç•´,Category)}}}/ åŒ…å«ä¸¤ä¸ªç©æ„
- ä¸œè¥¿ =O= ï¼ˆObjectï¼‰
- ä¸¤ä¸ªä¸œè¥¿çš„å…³ç³»ï¼Œç®­å¤´ =~>= ï¼ˆ /{{{ruby(æ€å°„,Morphism)}}}/ ï¼‰

ä¸€äº›å±æ€§
- ä¸€å®šæœ‰ä¸€ä¸ªå« id çš„ç®­å¤´ï¼Œä¹Ÿå«åš 1
- ç®­å¤´å¯ä»¥ /{{{ruby(ç»„åˆ, compose)}}}/

æ©ï¼Œå°±æ˜¯è¿™ä¹ˆç®€å•

#+BEGIN_SRC dot :file images/category.svg :exports results
  digraph {
          label="Category"
          rankdir=RL
          a -> b [label=g]
          b -> c [label=f]
          a -> a [label=id]
          b -> b [label=id]
          c -> c [label=id]
          a -> c [label="f . g"]
  }
#+END_SRC

#+CAPTION: æœ‰ä¸œè¥¿ a, b, c å’Œç®­å¤´ f, g çš„ Categoryï¼Œå…¶ä¸­ f . g è¡¨ç¤º compose f å’Œ g
#+RESULTS:
[[file:images/category.svg]]

è¿™äº›ç©æ„å¯¹åº”åˆ° haskell çš„ typeclass å¤§è‡´å°±æ˜¯è¿™æ ·
#+BEGIN_SRC haskell
class Category (c :: * -> * -> *) where
  id :: c a a
  (.) :: c y z -> c x y -> c x z
#+END_SRC

#+BEGIN_QUOTE
æ³¨æ„åˆ°ä¸ºä»€ä¹ˆæˆ‘ä¼šç®­å¤´ä»å³å¾€å·¦ï¼Œä½ ä¼šå‘ç°è¿™ä¸ªæ–¹å‘è·Ÿ compose çš„æ–¹å‘åˆšå¥½ä¸€è‡´
#+END_QUOTE

å¦‚æœè¿™æ˜¯ä½ ç¬¬ä¸€æ¬¡è§åˆ° Haskell ä»£ç ï¼Œæ²¡æœ‰å…³ç³»ï¼Œè¯­æ³•çœŸçš„å¾ˆç®€å• +æ‰æ€ª+
- =class= å®šä¹‰äº†ä¸€ä¸ª TypeClassï¼Œ =Category= æ˜¯è¿™ä¸ª TypeClass çš„åå­—
- Type class ç±»ä¼¼äºå®šä¹‰ç±»å‹çš„è§„èŒƒï¼Œè§„èŒƒä¸º =where= åé¢é‚£ä¸€å¨
- ç±»å‹è§„èŒƒçš„å¯¹è±¡æ˜¯å‚æ•° ~(c:: * -> * -> *)~ ï¼Œ =::= åé¢æ˜¯cçš„ç±»å‹
- c æ˜¯ /higher kind/ ï¼Œè·Ÿhigher order functionçš„å®šä¹‰å·®ä¸å¤šï¼Œå®ƒæ˜¯æ¥æ”¶ç±»å‹ï¼Œæ„é€ æ–°ç±»å‹çš„ç±»å‹ã€‚è¿™é‡Œçš„ c æ¥æ”¶ä¸€ä¸ªç±»å‹ï¼Œå†æ¥æ”¶ä¸€ä¸ªç±»å‹ï¼Œå°±å¯ä»¥è¿”å›ä¸ªç±»å‹ã€‚
- ~id:: c a a~ è¡¨ç¤º c èŒƒç•´ä¸Šçš„ a åˆ° a çš„ç®­å¤´
- =.= çš„æ„æ€ c èŒƒç•´ä¸Šï¼Œå¦‚æœå–‚ä¸€ä¸ª y åˆ° z çš„ç®­å¤´ï¼Œå†å–‚ä¸€ä¸ª x åˆ° y çš„ç®­å¤´ï¼Œé‚£ä¹ˆå°±è¿”å› x åˆ° z çš„ç®­å¤´ã€‚

{{{ruby(ç®€å•å§,hen nan ba)}}}?è¿˜æ²¡æœ‰é«˜æ•°æŠ½è±¡å‘¢ã€‚

*** /Hask/
Haskell ç±»å‹ç³»ç»ŸèŒƒç•´å«åš Hask
#+INDEX: Hask

åœ¨ Hask èŒƒç•´ä¸Šï¼š

- ä¸œè¥¿æ˜¯ç±»å‹
- ç®­å¤´æ˜¯ç±»å‹çš„å˜æ¢ï¼Œå³ =->=
- id å°±æ˜¯ id å‡½æ•°çš„ç±»å‹ =a -> a=
- compose å½“ç„¶å°±æ˜¯å‡½æ•°ç»„åˆçš„ç±»å‹

#+BEGIN_SRC haskell
type Hask = (->)
instance Category (Hask:: * -> * -> *) where
  (f . g) x = f (g x)
#+END_SRC

æˆ‘ä»¬çœ‹è§æ–°çš„å…³é”®å­— =instance= ï¼Œè¿™è¡¨ç¤º Hask æ˜¯ Type class Category çš„å®ä¾‹ç±»å‹ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥Haskçš„ä¸ªæ„é€ å™¨å»çœŸçš„æ„é€ ä¸€ä¸ªç±»å‹

æ¯”å¦‚ï¼š
#+BEGIN_SRC haskell
(->) a a
#+END_SRC
å°±æ„é€ äº†ä¸€ä¸ªä»aç±»å‹åˆ°aç±»å‹çš„çš„ç±»å‹

æ„é€ å‡ºæ¥çš„è¿™ä¸ªç±»å‹å¯ä»¥ä½œä¸º id å‡½æ•°çš„ç±»å‹
#+BEGIN_SRC haskell
id :: (->) a a
#+END_SRC

*** /Duel/
æ¯ä¸ª Categoryè¿˜æœ‰ä¸€ä¸ªé•œåƒï¼Œä»€ä¹ˆéƒ½ä¸€æ ·ï¼Œé™¤äº†ç®­å¤´æ˜¯åçš„

** /{{{ruby(å‡½å­, Functor)}}}/
#+INDEX: Functor
#+INDEX: å‡½å­
ä¸¤ä¸ªèŒƒç•´ä¸­é—´å¯ä»¥ç”¨å« Functor çš„ä¸œè¥¿æ¥è¿æ¥èµ·æ¥ï¼Œç®€ç§° Tã€‚

#+BEGIN_SRC dot :file images/functor.svg :exports results
  digraph {

  label="Functor C D G"
  compound=true;
  rankdir=RL
  subgraph cluster_C {
          style=dotted
          label="C"
          a -> a [label=id]
          a -> b [label=g]
          b -> c [label=f]
          a -> c [label="f . g"]
  }
  subgraph cluster_D {
          style=dotted
          label=D
          "G a" -> "G a" [label="G id"]
          "G a" -> "G b" [label="G g"]
          "G b" -> "G c" [label="G f"]
          "G a" -> "G c" [label="G f . g = G f . G g"]
  }

  c ->"G a"[ltail=cluster_C,lhead=cluster_D,label=G]
  }
#+END_SRC

#+CAPTION: Functor C D G, ä» C åˆ° D èŒƒç•´çš„Functor G
#+RESULTS:
[[file:images/functor.svg]]

æ‰€ä»¥å¤§éƒ¨åˆ†æŠŠFunctor/Monadæ¯”å–»æˆç›’å­å…¶å®åœ¨å®šä¹‰ä¸Šæ˜¯é”™çš„ï¼Œè™½ç„¶è¿™æ ·æ¯”å–»æ¯”è¾ƒå®¹æ˜“ç†è§£ï¼Œåœ¨ä½¿ç”¨ä¸Šé—®é¢˜ä¹Ÿä¸å¤§ã€‚ä½†æ˜¯ï¼ŒFunctoråªæ˜¯ä»ä¸€ä¸ªèŒƒç•´åˆ°å¦ä¸€ä¸ªèŒƒç•´çš„æ˜ å°„å…³ç³»è€Œå·²ã€‚

- èŒƒç•´é—´ ä¸œè¥¿çš„ Functor æ ‡è®°ä¸º =T(O)=
- èŒƒç•´é—´ ç®­å¤´çš„ Functor æ ‡è®°ä¸º =T(~>)=
- ä»»ä½•èŒƒç•´Cä¸Šå­˜åœ¨ä¸€ä¸ª T æŠŠæ‰€æœ‰çš„ O å’Œ ~> éƒ½æ˜ å°„åˆ°è‡ªå·±ï¼Œæ ‡è®°ä¸ºid functor 1_C
  - 1_C(O) = O
  - 1_C(~>) = ~>

#+BEGIN_SRC haskell
class (Category a, Category b) => Functor a b t where
  fmap :: c a b -> d (t a) (t b)
#+END_SRC

=Functor a b t= è¿™è¡¨ç¤ºä»èŒƒç•´ a åˆ°èŒƒç•´ b çš„ä¸€ä¸ª Functor t

å¦‚æœæŠŠèŒƒç•´ a å’Œ b éƒ½é™åˆ¶åˆ° Hask èŒƒç•´

#+BEGIN_SRC haskell
class Functor (->) (->) t where
  fmap :: (->) a b -> (->) (t a) (t b)
#+END_SRC

=->= åœ¨ Haskell ä¸­æ˜¯ä¸­ç¼€ç±»å‹æ„é€ å™¨ï¼Œæ‰€ä»¥æ˜¯å¯ä»¥å†™åœ¨ä¸­é—´çš„

è¿™æ ·å°±ä¼šå˜æˆæˆ‘ä»¬ç†Ÿæ‚‰çš„ Funtor çš„ Typeclassï¼ˆæŠŠFunctor çš„ç¬¬ä¸€ç¬¬äºŒä¸ªå‚æ•°å»æ‰çš„è¯ï¼‰
#+BEGIN_SRC haskell
class Functor t where
  fmap :: (a -> b) -> (t a -> t b)
#+END_SRC

è€Œ /{{{ruby(è‡ªå‡½å­,endofunctor)}}}/ å°±æ˜¯è¿™ç§è¿æ¥ç›¸åŒèŒƒç•´çš„ Functorï¼Œå› ä¸ºå®ƒä»èŒƒç•´ Hask åˆ°è¾¾åŒæ ·çš„èŒƒç•´ Hask
#+INDEX: endofunctor
#+INDEX: è‡ªå‡½å­

è¿™é‡Œçš„ fmap å°±æ˜¯ T(~>)ï¼Œåœ¨ Hask èŒƒç•´ä¸Šï¼Œæ‰€ä»¥æ˜¯ T(->), è¿™ä¸ªç®­å¤´æ˜¯å‡½æ•°ï¼Œæ‰€ä»¥ä¹Ÿèƒ½è¡¨ç¤ºæˆ T(f) å¦‚æœ =f:: a -> b=

** /{{{ruby(Cat, +çŒ«+)}}}/
å½“æˆ‘ä»¬æŠŠä¸€ä¸ªCategoryçœ‹æˆä¸€ä¸ªobjectï¼Œfunctorçœ‹æˆç®­å¤´ï¼Œé‚£ä¹ˆæˆ‘ä»¬åˆå¾—åˆ°äº†ä¸€ä¸ªCategoryï¼Œè¿™ç§objectæ˜¯categoryçš„categoryæˆ‘ä»¬å«å®ƒ -- /Cat/

å·²ç»æ²¡æ³•è®²äº†ï¼Œçœ‹ TODO å›¾å§

** /{{{ruby(è‡ªç„¶å˜æ¢,Natural Transformations)}}}/
#+INDEX: Natural Transformations
#+INDEX: è‡ªç„¶å˜æ¢
Functor æ˜¯èŒƒç•´é—´çš„æ˜ å°„ï¼Œè€Œ Functor åœ¨ Cat èŒƒç•´åˆæ˜¯ä¸ªç®­å¤´ï¼Œæ‰€ä»¥ï¼ŒFunctoré—´çš„æ˜ å°„ï¼Œä¹Ÿå°±æ˜¯ Cat èŒƒç•´ä¸Šçš„ Functorï¼Œå«åš /è‡ªç„¶å˜æ¢/

#+BEGIN_SRC dot :file images/natrual-transformation.svg :exports results
  digraph {
  label="Functor F åˆ° G çš„è‡ªç„¶å˜æ¢"
  compound=true;
  rankdir=RL
  subgraph cluster_C {
          style=dotted
          label="C"
          a -> a [label=id]
          a -> b [label=g]
          b -> c [label=f]
          a -> c [label="f . g"]
  }
  subgraph cluster_D {
          style=dotted
          label=D
          "G a" -> "G a" [label="G id"]
          "G a" -> "G b" [label="G g"]
          "G b" -> "G c" [label="G f"]
          "G a" -> "G c" [label="G f . g = G f . G g"]
          "F a" -> "F a" [label="F id"]
          "F a" -> "F b" [label="F g"]
          "F b" -> "F c" [label="F f"]
          "F a" -> "F c" [label="F f . g = F f . F g"]
  }
  subgraph FunctorCategory {
          style=dotted
          label="Functor Category"
          rank=same;
          functorG [label="G",shape=plaintext,width=0.01, height=0.01];
          functorF [label="F", shape=plaintext, width=0.01, height=0.01];
  }
  functorF -> functorG[label="Î·"]
  c -> functorG [arrowhead=none]
  c -> functorF [arrowhead=none]
  functorG ->"G a"[ltail=cluster_C,lhead=cluster_D]

  functorF ->"F a"[ltail=cluster_C,lhead=cluster_E]
  }
#+END_SRC

#+CAPTION: Functor Få’ŒGï¼Œä»¥åŠ F åˆ° G çš„è‡ªç„¶å˜åŒ– \eta
#+RESULTS:
[[file:images/natrual-transformation.svg]]

æ‰€ä»¥èŒƒç•´ c ä¸Šçš„å‡½å­ f åˆ° g çš„è‡ªç„¶å˜åŒ–å°±å¯ä»¥è¡¨ç¤ºæˆ
#+BEGIN_SRC haskell
type Nat c f g = c (f a) (g a)
#+END_SRC

Hask èŒƒç•´ä¸Šçš„è‡ªç„¶å˜åŒ–å°±å˜æˆäº†
#+BEGIN_SRC haskell
type NatHask f g = f a -> g a
#+END_SRC

æœ‰è¶£çš„æ˜¯ï¼Œè‡ªç„¶è½¬æ¢ä¹Ÿæ»¡è¶³ç®­å¤´çš„æ¦‚å¿µï¼Œå¯ä»¥å½“æˆ functor èŒƒç•´ä¸Šçš„ç®­å¤´ï¼Œæ‰€ä»¥åˆå¯ä»¥å®šä¹‰å‡ºæ¥ä¸€ä¸ª Functor Catergory

- ä¸œè¥¿æ˜¯å‡½å­
- ç®­å¤´æ˜¯è‡ªç„¶å˜æ¢

è¦æˆä¸ºèŒƒç•´ï¼Œè¿˜æœ‰ä¸¤ç‚¹
- id ä¸º f a åˆ° f a çš„è‡ªç„¶å˜æ¢
- è‡ªç„¶å˜æ¢çš„ç»„åˆ

#+BEGIN_SRC dot :file images/functor-category.svg :exports results
digraph FunctorCategory {
          style=dotted
          label="Functor Category"
          rank=same;
          functorG [label="G",shape=plaintext,width=0.01, height=0.01];
          functorF [label="F", shape=plaintext, width=0.01, height=0.01];
functorF -> functorG[label="Î·"]
  }
#+END_SRC

#+RESULTS:
[[file:images/functor-category.svg]]

æˆ‘ä»¬æ¥æ¢³ç†ä¸€ä¸‹ï¼Œå·²ç»ä¸çŸ¥é“å‡äº†å‡ ä¸ªç»´åº¦äº†ï¼Œæˆ‘ä»¬å‡è®¾ç±»å‹æ˜¯ç¬¬ä¸€ç»´åº¦
- ä¸€ç»´ï¼š Haskï¼Œ ä¸œè¥¿æ˜¯ç±»å‹ï¼Œç®­å¤´æ˜¯ ->
- äºŒç»´ï¼š Catï¼Œ ä¸œè¥¿æ˜¯ Haskï¼Œ ç®­å¤´æ˜¯ Functor
- ä¸‰ç»´ï¼š FunctorèŒƒç•´ï¼Œ ä¸œè¥¿æ˜¯Functorï¼Œ ç®­å¤´æ˜¯è‡ªç„¶å˜æ¢

æ„Ÿè§‰åˆ°è¾¾ä¸‰ç»´å·²ç»æ˜¯æé™äº†ï¼Œå°¼ç›è¿˜æœ‰å®Œæ²¡å®Œäº†ï¼Œæ¯å‡ä¸€ä¸ªç»´åº¦è¿˜è¦èµ·è¿™ä¹ˆå¤šè£…é€¼çš„åå­—ï¼Œå†å‡ç»´åº¦å°±è¦ä¸€è„¸æ‡µé€¼äº†å‘¢ã€‚è™½ç„¶ç»´åº¦ä¸ç®—å¤ªé«˜ï¼Œä½†æ˜¯å·²ç»ä¸èƒ½ç”¨ç®€å•çš„å›¾æ¥æè¿°äº†ï¼Œæ‰€ä»¥éœ€è¦å¼•å…¥ String Diagramã€‚

** String Diagram

String Diagram çš„æ¦‚å¿µå¾ˆç®€å•ï¼Œå°±æ˜¯ç‚¹å˜çº¿çº¿å˜ç‚¹ã€‚

å½“æœ‰äº†è‡ªç„¶å˜æ¢ä¹‹åï¼Œæ²¡æ³•è¡¨ç¤ºäº†å‘€ï¼Œé‚£åŸæ¥çš„ç‚¹å’Œçº¿éƒ½å‡ä¸€ç»´åº¦ï¼Œå˜æˆçº¿å’Œé¢ï¼Œè¿™æ ·ï¼Œå°±è…¾å‡ºä¸€ä¸ªç‚¹æ¥è¡¨ç¤ºè‡ªç„¶å˜æ¢äº†ã€‚

#+CAPTION: String Diagramï¼šè‡ªç„¶å˜æ¢æ˜¯ç‚¹ï¼ŒFunctoræ˜¯çº¿ï¼ŒèŒƒç•´æ˜¯é¢
https://www.evernote.com/l/ABdTD63_idxFyKnvfX39lvCgfuC0GeAWPjEB/image.png

** /Adjunction Functor/ ä¼´éšå‡½å­
#+INDEX: Adjunction Functor
èŒƒç•´Cå’ŒDç›´æ¥æœ‰æ¥æœ‰å›çš„å‡½å­ï¼Œä¸ºä»€ä¹ˆè¦ä»‹ç»è¿™ä¸ªï¼Œå› ä¸ºå®ƒç›´æ¥å¯ä»¥æ¨å‡º Monad

è®©æˆ‘ä»¬æ¥çœ‹çœ‹ä»€ä¹ˆå«æœ‰æ¥å›ã€‚

https://www.evernote.com/l/ABdLVPGwUI5FX4WJpCP26KQ4tjuQBYzbk3MB/image.png

å…¶ä¸­ï¼š

- ä¸€ä¸ªèŒƒç•´ C å¯ä»¥é€šè¿‡å‡½å­ G åˆ° Dï¼Œå†é€šè¿‡å‡½å­ F å›åˆ° Cï¼Œé‚£ä¹ˆ F å’Œ G å°±æ˜¯ä¼´éšå‡½å­ã€‚
- \eta æ˜¯ GF åˆ° 1_D çš„è‡ªç„¶å˜æ¢
- \epsilon æ˜¯ 1_C åˆ° FG çš„è‡ªç„¶å˜æ¢

åŒæ—¶æ ¹æ®åŒæ„çš„å®šä¹‰ï¼ŒG ä¸ F æ˜¯ /åŒæ„/ çš„ã€‚
#+INDEX: isomorphic
#+INDEX: åŒæ„

åŒæ„æŒ‡çš„æ˜¯è‹¥æ˜¯æœ‰
#+BEGIN_SRC haskell
f :: a -> b
f':: b -> a
#+END_SRC
é‚£ä¹ˆ f ä¸ f' åŒæ„ï¼Œå› ä¸º f . f' = id = f' . f

ä¼´éšå‡½å­çš„ FG ç»„åˆæ˜¯ C èŒƒç•´çš„ id å‡½å­ F . G = 1_c

#+CAPTION: ä¼´éšå‡½å­çš„ä¸¤ä¸ªFunctorç»„åˆ, å·¦ä¾§ä¸º F \eta, å³ä¾§ä¸º \epsilon F
https://www.evernote.com/l/ABd_ole4GrRMGJ82dcTN4Du4x0b1CShrinsB/image.png

Functorçš„ç»„åˆåœ¨è‡ªç„¶å˜æ¢ç»´åº¦ä¸Šæ˜¯å¯ä»¥ç»„åˆçš„ï¼Œå› ä¸ºè‡ªç„¶å˜æ¢æ˜¯Functor èŒƒç•´çš„ç®­å¤´

#+CAPTION: F \eta . \epsilon F  = F
https://www.evernote.com/l/ABc-GpFhWhxN6K06AmOhCUgL0tMa-a8dMS0B/image.png

** ä»ä¼´éšå‡½å­åˆ° {{{ruby(å•å­, Monad)}}}
æœ‰äº†ä¼´éšå‡½å­ï¼Œå¾ˆå®¹æ˜“æ¨å‡ºå•å­ï¼Œè®©æˆ‘ä»¬æ¥çœ‹çœ‹ä»€ä¹ˆæ˜¯å•å­


- é¦–å…ˆï¼Œå®ƒæ˜¯ä¸€ä¸ª endofunctor T
- æœ‰ä¸€ä¸ªä» i_c åˆ° T çš„è‡ªç„¶å˜åŒ– \eta (eta)
- æœ‰ä¸€ä¸ªä» T^2 åˆ° T çš„è‡ªç„¶å˜åŒ– \mu (mu)

https://www.evernote.com/l/ABexO3KphElMrZ_5scYTDxjOelA5cigrHCoB/image.png

#+BEGIN_SRC haskell
class Endofunctor c t => Monad c t where
  eta :: c a (t a)
  mu  :: c (t (t a)) (t a)
#+END_SRC

åŒæ ·ï¼ŒæŠŠ c = Hask æ›¿æ¢è¿›å»ï¼Œå°±å¾—åˆ°æ›´ç±»ä¼¼æˆ‘ä»¬ Haskell ä¸­ Monad çš„å®šä¹‰
#+BEGIN_SRC haskell
class Endofunctor m => Monad m where
  eta :: a -> (m a)
  mu :: m m a -> m a
#+END_SRC

#+CAPTION: ä¼´éšå‡½å­çš„ \epsilon å°±æ˜¯å•å­çš„ \eta
https://www.evernote.com/l/ABfg4vXk8DJGRZGPRv6A_ifmOykudKxqyqUB/image.png

#+CAPTION: ä¼´éšå‡½å­çš„ F \eta G æ˜¯å‡½å­çš„ \mu
https://www.evernote.com/l/ABf_3PObVKVLI4xOK9ijFcnC0hZ29TJIZVsB/image.png

*** ä¸‰è§’ç­‰å¼
#+CAPTION: F \eta G  . \epsilon F G = F G
https://www.evernote.com/l/ABemC0HnOQ1PIpiI6Y-34nEm4CSoITFuB64B/image.png

#+CAPTION: F \eta G  . \epsilon F G= F G å¯¹åº”åˆ°Monadå°±æ˜¯ \mu . \eta T = T
https://www.evernote.com/l/ABePUH_43tVLgJJ8y4QNKhr10UnxWlWnpI0B/image.png

æ¢åˆ°ä»£ç ä¸Šæ¥è¯´
#+BEGIN_SRC haskell
  class Endofunctor m => Monad m where
    (mu . eta) m = m
#+END_SRC

åŒæ ·çš„ï¼Œå·¦å³ç¿»è½¬ä¹Ÿæˆç«‹

#+CAPTION: F \eta G . F G \epsilon = F G
https://www.evernote.com/l/ABfdt-llk4dKvY94Pqn5fZFlRt5B9qwii6UB/image.png

#+CAPTION: F \eta G . F G \epsilon = F G å¯¹åº”åˆ° Monadæ˜¯ \mu . T \eta = T
https://www.evernote.com/l/ABcG2YoCCNdHd7pdFViyMBMli12foiuBIsAB/image.png

T \eta å°±æ˜¯ fmap eta
#+BEGIN_SRC haskell
    (mu . fmap eta) m = m
#+END_SRC

å¦‚æœæŠŠ ~mu . fmap~ å†™æˆ ~>>=~ , å°±æœ‰äº†

#+BEGIN_SRC haskell
m >>= eta = m
#+END_SRC

*** ç»“åˆå¾‹
å•å­å¦ä¸€å¤§å®šå¾‹æ˜¯ç»“åˆå¾‹ï¼Œè®©æˆ‘ä»¬ä»ä¼´éšå‡½å­æ¨èµ·

å‡è®¾æˆ‘ä»¬ç°åœ¨æœ‰å‡½å­ F \eta G å’Œ å‡½å­ F \eta G F G, compose èµ·æ¥ä¼šå˜æˆ  F \eta G . F \eta G F G
https://www.evernote.com/l/ABfsS4KBjE1Gbrd8AouQJeBVc9u_sqBUzPwB/image.png

ç”¨ F G = T ï¼Œ F \eta G = \mu ä»£æ¢é‚£ä¹ˆå°±å¾—åˆ°äº†å•å­çš„ \mu . \mu T
https://www.evernote.com/l/ABc_scvfquxHhKZZ6I51i1hL3f5Oe382IZ0B/image.png

å½“ç»„åˆ F \eta G å’Œ F G F \mu G åï¼Œä¼šå¾—åˆ°ä¸€ä¸ªé•œåƒçš„å›¾
https://www.evernote.com/l/ABcsGipPc8BFL7Yp9NuCfUQQ3W0JntC7JDcB/image.png

å¯¹åº”åˆ°å•å­çš„ \mu . T \mu
https://www.evernote.com/l/ABdRAkfmbjJMHZNeSNxzc_r2bgeq2MNKrC8B/image.png

ç»“åˆå¾‹æ˜¯è¯´ \mu . \mu T = \mu . T \mu , å³å›¾å·¦å³ç¿»è½¬ç»“æœæ˜¯ç›¸ç­‰çš„ï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿçœ‹å•å­çš„String Diagram ä¸å¤ªå¥½çœ‹å‡ºæ¥ï¼Œæˆ‘ä»¬æ¥çœ‹ä¼´éšå‡½å­

å¦‚æœæŠŠå·¦å›¾çš„å·¦è¾¹çš„ \mu å¾€ä¸ŠæŒªä¸€ç‚¹ï¼Œå³è¾¹çš„ \mu å¾€ä¸‹æŒªä¸€ç‚¹ï¼Œæ˜¯ä¸æ˜¯è·Ÿå³å›¾å°±ä¸€æ ·äº†
https://www.evernote.com/l/ABcv0axE5alKiZupUL2SyhrALuS-4DyBfQAB/image.png

ç»“åˆå¾‹åæ˜ åˆ°ä»£ç ä¸­å°±æ˜¯
#+BEGIN_SRC haskell
mu . fmap mu = mu . mu
#+END_SRC

ä»£ç å¾ˆéš¾çœ‹å‡ºç»“åˆåœ¨å“ªé‡Œï¼Œå› ä¸ºæ­£å¸¸çš„ç»“åˆå¾‹åº”è¯¥æ˜¯è¿™æ ·çš„ (1+2)+3 = 1+(2+3)ï¼Œä½†æ˜¯ä¸æƒ³åŠ æ³•çš„ç»´åº¦ä¸ä¸€æ ·ï¼Œè¿™é‡Œè¯´çš„æ˜¯è‡ªç„¶å˜æ¢ç»´åº¦çš„ç»“åˆï¼Œå¯ä»¥é€šè¿‡String Diagram å¾ˆæ¸…æ¥šçš„çœ‹è§ç»“åˆçš„è¿‡ç¨‹ï¼Œå³ \mu å·¦è¾¹çš„ä¸¤ä¸ªTå’Œå…ˆ \mu å³è¾¹ä¸¤ä¸ª T æ˜¯ç›¸ç­‰çš„ã€‚

** Yoneda lemma / +ç±³ç”°å…±+ ç±³ç”°å¼•ç†
#+INDEX: ç±³ç”°å¼•ç†
#+INDEX: Yoneda Lemma

ç±³ç”°å¼•ç†æ˜¯è¯´æ‰€æœ‰Functor =f a= ä¸€å®šå­˜åœ¨ embed å’Œ unembedï¼Œä½¿å¾— =f a= å’Œ =(a -> b) -> F b= isomorphic åŒæ„

haskellè¿˜è¦å…ˆæ‰“å¼€ RankNTypes çš„ feature

#+BEGIN_SRC haskell
{-# LANGUAGE RankNTypes #-}

embed :: Functor f => f a -> (forall b . (a -> b) -> f b)
embed x f = fmap f x

unembed :: Functor f => (forall b . (a -> b) -> f b) -> f a
unembed f = f id
#+END_SRC

embed å¯ä»¥æŠŠ functor =f a= å˜æˆ =(a -> b) -> f b=

unembed æ˜¯åè¿‡æ¥ï¼Œ =(a -> b) -> f b= å˜æˆ =f a=

ä¸Šä¸ªå›¾å°±æ˜ç™½äº†
#+BEGIN_SRC dot :file images/yoneda-lemma.svg  :exports results
    digraph {
            rankdir=RL
            newrank=true;
            compound=true;
            subgraph cluster_C {
                  0[style=invis,shape=point,height=0,margin=0];
                    style=dotted
                    label=C
                    a;b;
                    a -> b
            }



            subgraph cluster_D {
                  1[style=invis, shape=point,height=0,margin=0];
                    style=dotted
                    label=D
                    "F a" -> "F b"
            }
            edge[constraint=false, style=solid];
            0 -> 1[ltail=cluster_C, lhead=cluster_D, label=F]
            // a -> F [ltail=cluster_C,arrowhead=none]
            // F ->"F a"[lhead=cluster_D]
            {rank=same;a;"F a"}
    }
#+END_SRC

#+CAPTION: ä¹Ÿå°±æ˜¯è¯´ï¼Œå›¾ä¸­æ— è®ºçŸ¥é“a->b å†åŠ ä¸Šä»»æ„ä¸€ä¸ª F xï¼Œéƒ½èƒ½æ¨å‡ºå¦å¤–ä¸€ä¸ª F
#+RESULTS:
[[file:images/yoneda-lemma.svg]]

*** Rank N Type
#+INDEX: Arbitrary-rank polymorphism
#+INDEX: Rank N Type
- Monomorphic Rank 0 / 0çº§å•æ€: t
- Polymorphic Rank 1 / 1çº§ +å˜æ€+ å¤šæ€: forall a. a -> t
- Polymorphic Rank 2 / 2çº§å¤šæ€: (forall a. a -> t) -> t
- Polymorphic Rank 3 / 3çº§å¤šæ€: ((forall a. a -> t) -> t) -> t

çœ‹rankå‡ åªè¦æ•°å·¦è¾¹ forall çš„æ‹¬å·åµŒå¥—å±‚æ•°å°±å¥½äº†

ä¸€çº§å¤šæ€é”å®šå…¨éƒ¨ç±»å‹å˜åŒ–ä¸­çš„ç±»å‹a

äºŒçº§å¤šæ€å¯ä»¥åˆ†åˆ«ç¡®å®š a -> t è¿™ä¸ªå‡½æ•°çš„ç±»å‹å¤šæ€

æ¯”å¦‚
#+BEGIN_SRC haskell
rank2 :: (forall a. a -> a) -> (Bool, Char)
rank2 f = (f True, f 'a')
#+END_SRC

- f åœ¨ =f True= æ—¶ç±»å‹ =Boolean -> Boolean= æ˜¯ç¬¦åˆ =forall a. a->a= çš„
- åœ¨ =f 'a'= æ—¶ç±»å‹æ˜¯ =Char -> Char= ä¹Ÿç¬¦åˆ =forall a. a->a=

ä½†æ˜¯åˆ° rank1 ç±»å‹ç³»ç»Ÿå°±æ‡µé€¼äº†
#+BEGIN_SRC haskell
rank1 :: forall a. (a -> a) -> (Bool, Char)
rank1 f = (f True, f 'a')
#+END_SRC
f åœ¨ =f True= æ˜¯ç¡®å®š a æ˜¯ Booleanï¼Œåœ¨rank1å¤šæ€æ˜¯æ—¶å°±ç¡®å®šäº† =a->a= çš„ç±»å‹ä¸€å®šæ˜¯ =Boolean -> Boolean=

æ‰€ä»¥åˆ° =f 'a'= ç±»å‹å°±æŒ‚äº†ã€‚

** /Kleisli Catergory/
#+INDEX: Kleisi Catergory

#+BEGIN_SRC dot :file images/kleisli.svg :exports results
      digraph g {
              rankdir="RL";
              edge[style=invis];

              { rank=same;
                      0 [style = invis, shape=point];
                      01 [style = invis,shape=point];
                      02 [style=invis,shape=point];
                      0 -> 01 -> 02;
              }

              subgraph clusterA {
                      style=dotted
                      "a" -> "b" -> "c";
                      "a" -> "b" [label="g'", constraint=false, style=solid];
                      "b" -> "c" [label="f'", constraint=false, style=solid];
              }
              subgraph clusterB {
                      style=dotted
                      "T a" -> "T b" -> "T c";
                      "T a" -> "T b" [label="T g'", constraint=false, style=solid];
                      "T b" -> "T c" [label="T f'", constraint=false, style=solid];
              }

              subgraph clusterC {
                      style=dotted
                      "T T a" -> "T T b" -> "T T c";
                      "T T a" -> "T T b" [label="T T g'", constraint=false, style=solid];
                      "T T b" -> "T T c" [label="T T f'", constraint=false, style=solid];
              }


              0 -> a;
              01 -> "T a";
              02 -> "T T a";

              // edges between clusters
              edge[constraint=false, style=solid];
              a -> "T b"[label=g, color=blue, fontcolor=blue];
              a -> "T c" [label="f <=< g", style=dashed, color=blue, fontcolor=blue]
              "b" -> "T c"[label=f];
              "T b" -> "T T c"[label="T f", color=purple, fontcolor=purple];
              "T T c" -> "T c" [label="Î¼", style=dashed, color=purple];
              c -> "T c" [label="Î·", style=dashed]
              "T b" -> "T c" [label="Î¼ . T f (>>= f)", style=dashed, color=blue,fontcolor=blue]


      }
#+END_SRC

#+CAPTION: æ³¨æ„è§‚å¯Ÿå¤§ç«ç®­ <=< çš„è½¨è¿¹ï¼ˆä¸çŸ¥é“dotä¸ºä»€ä¹ˆä¼šæŠŠè¿™æ ¹çº¿æè¿™ä¹ˆåˆå¼¯åˆéªšçš„ï¼‰ å’Œ >>= ã€‚æ‰€ä»¥ Kleisli å…¶å®å°±æ˜¯æ–œç€èµ°çš„ä¸€ä¸ªèŒƒç•´ï¼Œä½†æ˜¯ >>= æŠŠå®ƒç¡¬ç”Ÿç”Ÿæ° +å¼¯+ ç›´äº†ã€‚
#+RESULTS:
[[file:images/kleisli.svg]]

Functor çš„ Catergory å«åš Functor Catergoryï¼Œå› ä¸ºæœ‰ç®­å¤´ -- è‡ªç„¶å˜æ¢ã€‚Monad ä¹Ÿå¯ä»¥å®šä¹‰å‡ºæ¥ä¸€ä¸ª Catergoryï¼ˆå½“ç„¶ç”±äºMonadæ˜¯ Endofunctorï¼Œæ‰€ä»¥ä»–ä¹Ÿå¯ä»¥æ˜¯ è‡ªå‡½å­èŒƒç•´ï¼‰ï¼Œå«åš Kleisli Catergoryï¼Œé‚£ä¹ˆ Kleisli çš„ç®­å¤´æ˜¯ä»€ä¹ˆï¼Ÿ

æˆ‘ä»¬çœ‹å®šä¹‰ï¼ŒKleisli Catergory
1. ç®­å¤´æ˜¯ Kleisli ç®­å¤´ =a -> T b=
2. ä¸œè¥¿å°±æ˜¯cèŒƒç•´ä¸­çš„ä¸œè¥¿. å› ä¸º a å’Œ b éƒ½æ˜¯ c èŒƒç•´ä¸Šçš„ï¼Œ ç”±äºTæ˜¯è‡ªå‡½å­ï¼Œæ‰€ä»¥ T b ä¹Ÿæ˜¯ c èŒƒç•´çš„

çœ‹åˆ°å›¾ä¸Šçš„ {{{ruby(T f, fmap f)}}} å’Œ \mu äº†æ²¡ï¼Ÿ

#+BEGIN_SRC haskell
f :: b -> T c
fmap f :: T b -> T^2 c
mu :: T^2 c -> T c
#+END_SRC

ç´«è‰²çš„ç®­å¤´è¿èµ·æ¥ï¼ˆcomposeï¼‰å°±æ˜¯ T f'ï¼Œæ‰€ä»¥, 
#+BEGIN_SRC haskell
tb >>= f = mu . fmap f tb
#+END_SRC

å¤§ç«ç®­åˆ™æ˜¯è“è‰²ç®­å¤´çš„ç»„åˆ 
#+BEGIN_SRC haskel
(f <=< g) = mu . T f . g = mu . fmap f . g
#+END_SRC

è€Œä¸”å¤§ç«ç®­å°±æ˜¯ Kleisli èŒƒç•´çš„ compose

#+BEGIN_SRC haskell
(<=<) :: Monad T => (b -> T c) -> (a -> T b) -> (a -> T c)
#+END_SRC

** Summary
ç¬¬ä¸€éƒ¨åˆ†ç†è®ºéƒ¨åˆ†éƒ½è®²å®Œäº†ï¼Œ å¦‚æœä½ è¯»åˆ°è¿™é‡Œè¿˜æ²¡æœ‰è¢«è¿™äº›{{{ruby(åŠç‚¸å¤©,ä¹±ä¸ƒå…«ç³Ÿ)}}}çš„æ¦‚å¿µædazeï¼Œæ¥ä¸‹æ¥å¯ä»¥çœ‹çœ‹å®ƒåˆ°åº•è·Ÿæˆ‘ä»¬ç¼–ç¨‹æœ‰é¸Ÿå…³ç³»å‘¢ï¼Ÿç¬¬äºŒéƒ¨åˆ†å°†ä»‹ç»è¿™äº›æ¦‚å¿µäº§ç”Ÿçš„ä¸€äº›å®ç”¨çš„monad

- ğŸ‘‰ [[./part2.org][ç¬¬äºŒéƒ¨åˆ†ï¼š{{{ruby(é£Ÿç”¨çŒ«å‘¢, Practical Monads)}}}]]

å½“ç„¶æˆ‘è¿˜æ²¡ç©ºå…¨éƒ¨å†™å®Œï¼Œå¦‚æœæœ‰å¾ˆå¤šäºº{{{ruby(é¢„å®š,åªè¦998)}}} Gumroad ä¸Šçš„ @@html: <script src="https://gumroad.com/js/gumroad.js"></script><a class="gumroad-button" href="https://gum.co/grokking-monad" target="_blank">Grokking Monad</a>@@ ç”µå­ä¹¦çš„è¯ï¼Œæˆ‘å¯èƒ½ä¼šç¨å¾®å†™å¾—å¿«ä¸€äº›ã€‚æ¯•ç«Ÿï¼Œå†™äº†ä¹Ÿæ²¡äººæ„Ÿå…´è¶£ä¹Ÿæ€ªæµªè´¹æ—¶é—´çš„ã€‚ä¸è¿‡ï¼Œæˆ‘çŒœä¹Ÿæ²¡å‡ ä¸ªäººèƒ½çœ‹åˆ°è¿™ä¸€è¡Œã€‚

* References
- http://dev.stephendiehl.com/hask
- https://en.wikibooks.org/wiki/Haskell/Category_theory
- https://www.youtube.com/watch?v=ZKmodCApZwk
- https://www.youtube.com/watch?v=kiXjcqxVogE&list=PL50ABC4792BD0A086&index=5
