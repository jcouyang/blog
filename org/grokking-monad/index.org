#+TITLE: èŒƒç•´è®ºå®Œå…¨è£…é€¼æ‰‹å†Œ / Grokking Monad
#+Date: <2017-02-10 Fri>
#+AUTHOR: æ¬§é˜³ç»§è¶…
#+OPTIONS: ^:t

å¾ˆå¤šäººéƒ½ä¸æ˜ç™½ä»€ä¹ˆæ˜¯Monadï¼Œå¹¶ä¸æ˜¯å› ä¸ºä¸ä¼šç”¨ï¼Œä¸çŸ¥è§‰å¯èƒ½å°±åœ¨ç”¨æŸç§monadã€‚å®šä¹‰å’Œä½¿ç”¨èµ·æ¥å…¶å®ä¸éš¾ï¼Œå›°æƒ‘çš„å¤§å¤šåº”è¯¥æ˜¯åé¢çš„è¿™å †ç†è®º-- +é¥­ç¨ + èŒƒç•´è®ºã€‚å½“ç„¶ï¼Œæˆ‘ä¹Ÿæ²¡å­¦è¿‡èŒƒç•´è®ºï¼Œåªæ˜¯ç•¥å¾®çœ‹å¾—æ‡‚å†™Haskellç½¢äº†ã€‚

æˆ‘å°è¯•è¿‡å¾ˆå¤šç§æ–¹å¼è§£é‡Šï¼Œæ¯”å¦‚ä¸ºäº†é™ä½é—¨æ§›ç”¨JSæ¥å®ç°ï¼Œé‚£Haskell/Scalaçš„äººå‡ºæ¥å–·ä½ ä»¬å‰ç«¯è¿™äº›ä¸æ‡‚å‡½æ•°å¼çš„äººä¹±æå‡ºæ¥çš„ä¸œè¥¿æ ¹æœ¬å°±ä¸æ˜¯monadã€‚æ¯”å¦‚ç”¨å›¾æ¥è§£é‡Šï¼Œåˆä¼šè¢«å«Œå¼ƒç”»é£ä¸å¥½ã€‚ä½†æ˜¯ï¼Œä½œä¸ºçµé­‚ç”»å¸ˆï¼Œæˆ‘åª +æ˜¯è§‰å¾—è‡ªå·±èŒèŒçš„å•Š+ åœ¨ä¹ç”»çš„çµé­‚æ˜¯å¦èƒ½å¤Ÿç»™ä½ ä¸€ç‚¹å¯å‘ã€‚

å¥½äº†ï¼Œå®‰å…¨å¸¦ç³»å¥½ï¼Œæˆ‘è¦å¼€è½¦äº†ã€‚ä¸ºäº†é˜²æ­¢é„™è§†é“¾é¡¶ç«¯çš„è¯­è¨€ç”¨æˆ·ä»¬å–·å†å«Œå¼ƒï¼Œæˆ‘å†³å®šå°±ç”¨Haskellå¥½äº†ï¼Œå…¶å®ä¹Ÿä¸éš¾è§£é‡Šæ¸…æ¥š +æ‰æ€ª+ ã€‚

è¿™é‡Œé¢å¾ˆå¤šå¾ˆè£…é€¼çš„å•è¯(å®ƒä»¬éƒ½æ˜¯ /æ–œä½“/)ï¼Œå°±ç®—æ²¡çœ‹æ‡‚ï¼ŒæŠŠè¿™äº›è¯è®°ä½ä¹Ÿè¶³å¤Ÿè£…ä¸€é˜µå­é€¼äº†ã€‚

* ç¬¬ä¸€ç« ï¼šCatergory Theory
** /Category/
#+INDEX: Catergory
#+INDEX: èŒƒç•´

ä¸€ä¸ª /èŒƒç•´/ åŒ…å«ä¸¤ä¸ªç©æ„
- ä¸œè¥¿ =O= ï¼ˆObjectï¼‰
- ä¸¤ä¸ªä¸œè¥¿çš„å…³ç³»ï¼Œç®­å¤´ =~>= ï¼ˆ /Morphism/ ï¼Œä¹¦ä¸Šå« /æ€å°„/ ï¼‰

ä¸€äº›å±æ€§
- ä¸€å®šæœ‰ä¸€ä¸ªå« id çš„ç®­å¤´ï¼Œä¹Ÿå«åš 1
- ç®­å¤´å¯ä»¥ /ç»„åˆ(compose)/

æ©ï¼Œå°±æ˜¯è¿™ä¹ˆç®€å•

#+CAPTION: åœ¨é…’åº—ç ´ç¬”ç”»çš„ï¼Œå¿ä¸€å¿çœ‹å§ï¼Œå›å»ç”¨surfaceè¡¥ä¸Š
https://www.evernote.com/l/ABdanaXlenVL5oMgKmviXVKaO2fQ_F9P9mQB/image.png

è¿™äº›ç©æ„å¯¹åº”åˆ°haskellçš„typeclasså¤§è‡´å°±æ˜¯è¿™æ ·
#+BEGIN_SRC haskell
class Category (c :: * -> * -> *) where
  id :: c a a
  (.) :: c y z -> c x y -> c x z
#+END_SRC

å…¶ä¸­ï¼š
c æ˜¯ /higher kind/ ï¼Œè·Ÿhigher order functionçš„å®šä¹‰å·®ä¸å¤šï¼Œå®ƒæ˜¯æ¥æ”¶ç±»å‹ï¼Œæ„é€ æ–°ç±»å‹çš„ç±»å‹ã€‚è¿™é‡Œçš„ c æ¥æ”¶ä¸€ä¸ªç±»å‹ï¼Œå†æ¥æ”¶ä¸€ä¸ªç±»å‹ï¼Œå°±å¯ä»¥è¿”å›ä¸ªç±»å‹ã€‚

- =id :: c a a= cèŒƒç•´ä¸Šçš„ a åˆ° a çš„ç®­å¤´

- =.= çš„æ„æ€ c èŒƒç•´ä¸Šï¼Œå¦‚æœå–‚ä¸€ä¸ª y åˆ° z çš„ç®­å¤´ï¼Œå†å–‚ä¸€ä¸ª x åˆ° y çš„ç®­å¤´ï¼Œé‚£ä¹ˆå°±è¿”å› x åˆ° z çš„ç®­å¤´ã€‚

*** /Hask/
Haskell ç±»å‹ç³»ç»ŸèŒƒç•´å«åš Hask
#+INDEX: Hask

Hask èŒƒç•´çš„ï¼š

- ä¸œè¥¿æ˜¯ =type=
- ç®­å¤´æ˜¯ =->= ä¹Ÿå°±æ˜¯å‡½æ•°çš„ç®­å¤´
- id å°±æ˜¯ id å‡½æ•°çš„ç±»å‹ =a -> a=
- compose å½“ç„¶å°±æ˜¯å‡½æ•°ç»„åˆ

#+BEGIN_SRC haskell
type Hask = (->)
instance Category (Hask:: * -> * -> *) where
  (f . g) x = f (g x)
#+END_SRC

** Functor / å‡½å­
#+INDEX: Functor
#+INDEX: å‡½å­
ä¸¤ä¸ªèŒƒç•´ä¸­é—´å¯ä»¥ç”¨å«Functorçš„ä¸œè¥¿æ¥è¿æ¥èµ·æ¥ï¼Œç®€ç§° Tã€‚
- èŒƒç•´é—´ ä¸œè¥¿çš„ Functor æ ‡è®°ä¸º =T(O)=
- èŒƒç•´é—´ ç®­å¤´çš„ Functor æ ‡è®°ä¸º =T(~>)=
- å­˜åœ¨ä¸€ä¸ª T æŠŠæ‰€æœ‰çš„ O å’Œ ~> éƒ½æ˜ å°„åˆ°è‡ªå·±ï¼Œæ ‡è®°ä¸ºid functor 1_C
  - 1_C(O) = O
  - 1_C(~>) = ~>

#+BEGIN_SRC haskell
class (Category a, Category b) => Functor a b t where
  fmap :: c a b -> d (t a) (t b)
#+END_SRC

=Functor a b t= è¿™è¡¨ç¤ºä»èŒƒç•´ a åˆ°èŒƒç•´ b çš„ä¸€ä¸ª Functor t

å¦‚æœæŠŠèŒƒç•´ a å’Œ b éƒ½é™åˆ¶åˆ° Hask èŒƒç•´

#+BEGIN_SRC haskell
class Functor (->) (->) t where
  fmap :: (->) a b -> (->) (t a) (t b)
#+END_SRC

=->= åœ¨ Haskell ä¸­æ˜¯ä¸­ç¼€ç±»å‹æ„é€ å™¨ï¼Œæ‰€ä»¥æ˜¯å¯ä»¥å†™åœ¨ä¸­é—´çš„

è¿™æ ·å°±ä¼šå˜æˆæˆ‘ä»¬ç†Ÿæ‚‰çš„ Funtor çš„ Typeclassï¼ˆæŠŠFunctor çš„ç¬¬ä¸€ç¬¬äºŒä¸ªå‚æ•°å»æ‰çš„è¯ï¼‰
#+BEGIN_SRC haskell
class Functor t where
  fmap :: (a -> b) -> (t a -> t b)
#+END_SRC

è€Œ /endofunctor/ å°±æ˜¯è¿™ç§è¿æ¥ç›¸åŒèŒƒç•´çš„ Functorï¼Œå› ä¸ºå®ƒä»èŒƒç•´ Hask åˆ°è¾¾åŒæ ·çš„èŒƒç•´ Hask
#+INDEX: endofunctor

è¿™é‡Œçš„ fmap å°±æ˜¯ T(~>)ï¼Œåœ¨ Hask èŒƒç•´ä¸Šï¼Œæ‰€ä»¥æ˜¯ T(->), è¿™ä¸ªç®­å¤´æ˜¯å‡½æ•°ï¼Œæ‰€ä»¥ä¹Ÿèƒ½è¡¨ç¤ºæˆ T(f) å¦‚æœ =f:: a -> b=



** Natural Transformations / è‡ªç„¶å˜æ¢
#+INDEX: Natural Transformations
#+INDEX: è‡ªç„¶å˜æ¢
Functor æ˜¯èŒƒç•´é—´çš„æ˜ å°„ï¼Œè€Œè‡ªç„¶å˜æ¢ï¼Œåˆ™æ˜¯Functoré—´çš„æ˜ å°„ã€‚

#+CAPTION: Functor Få’ŒGï¼Œè‡ªç„¶å˜åŒ– \etaï¼Œ ä»¥åŠFunctor Category
https://www.evernote.com/l/ABfSbtcBnthEIp82P0f4ptd-BMNxusJ5jQUB/image.jpg

æ‰€ä»¥èŒƒç•´ c ä¸Šçš„å‡½å­ f åˆ° g çš„è‡ªç„¶å˜åŒ–å°±å¯ä»¥è¡¨ç¤ºæˆ
#+BEGIN_SRC haskell
type Nat c f g = c (f a) (g a)
#+END_SRC

Hask èŒƒç•´ä¸Šçš„è‡ªç„¶å˜åŒ–å°±å˜æˆäº†
#+BEGIN_SRC haskell
type NatHask f g = f a -> g a
#+END_SRC

æœ‰è¶£çš„æ˜¯ï¼Œè‡ªç„¶è½¬æ¢ä¹Ÿæ»¡è¶³ç®­å¤´çš„æ¦‚å¿µï¼Œå¯ä»¥å½“æˆ functor èŒƒç•´ä¸Šçš„ç®­å¤´ï¼Œæ‰€ä»¥åˆå¯ä»¥å®šä¹‰å‡ºæ¥ä¸€ä¸ª Functor Catergory

- ä¸œè¥¿æ˜¯å‡½å­
- ç®­å¤´æ˜¯è‡ªç„¶å˜æ¢

è¦æˆä¸ºèŒƒç•´ï¼Œè¿˜æœ‰ä¸¤ç‚¹
- id ä¸º f a åˆ° f a çš„è‡ªç„¶å˜æ¢
- è‡ªç„¶å˜æ¢çš„ç»„åˆ

ç°åœ¨ç»´åº¦è¶Šæ¥è¶Šé«˜äº†ï¼Œå·²ç»ä¸èƒ½ç”¨ç®€å•çš„å›¾æ¥æè¿°äº†ï¼Œæ‰€ä»¥éœ€è¦å¼•å…¥ String Diagramã€‚

*** TODO String Diagram

T1 æ˜¯ èŒƒç•´ a åˆ° b çš„functor

T2 æ˜¯èŒƒç•´ b åˆ° c çš„functor

é‚£ä¹ˆ T2 . T1 å°±æ˜¯ a åˆ° c çš„funtorå’¯

å¦‚æœ T æ˜¯èŒƒç•´aä¸Šçš„endofunctor

é‚£ä¹ˆå¯ä»¥ T.T å¯ä»¥å†™æˆ TT æˆ–è€… T^2

é‚£ä¹ˆ compose å®Œçš„ç®­å¤´å¼ ä»€ä¹ˆæ ·å‘¢ï¼Ÿ

ç”¨ Maybe Functoræ¥è¯´

#+BEGIN_SRC haskell
-- Functor category
newtype Fun f g a b = FNat (f a -> g b)

-- Endofunctor category
type End f = Fun f f

instance Category (End f) where
  id = FNat id
  (FNat f) . (FNat g) = FNat (f . g)
#+END_SRC

** TODO /Adjunction Functor/ ä¼´éšå‡½å­
#+INDEX: Adjunction Functor
èŒƒç•´Cå’ŒDç›´æ¥æœ‰æ¥æœ‰å›çš„å‡½å­
** TODO Yoneda lemma / +ç±³ç”°å…±+ ç±³ç”°å¼•ç†
#+INDEX: ç±³ç”°å¼•ç†
#+INDEX: Yoneda Lemma

ç±³ç”°å¼•ç†æ˜¯è¯´æ‰€æœ‰Functor =f a= ä¸€å®šå­˜åœ¨ embed å’Œ unembedï¼Œä½¿å¾— =f a= å’Œ =(a -> b) -> F b= isomorphic åŒæ„
#+INDEX: isomorphic
#+INDEX: åŒæ„

haskellè¿˜è¦å…ˆæ‰“å¼€ RankNTypes çš„ feature

#+BEGIN_SRC haskell
{-# LANGUAGE RankNTypes #-}

embed :: Functor f => f a -> (forall b . (a -> b) -> f b)
embed x f = fmap f x

unembed :: Functor f => (forall b . (a -> b) -> f b) -> f a
unembed f = f id
#+END_SRC

embed å¯ä»¥æŠŠ functor =f a= å˜æˆ =(a -> b) -> f b=

unembed æ˜¯åè¿‡æ¥ï¼Œ =(a -> b) -> f b= å˜æˆ =f a=
*** Rank N Type
#+INDEX: Arbitrary-rank polymorphism
#+INDEX: Rank N Type
- Monomorphic Rank 0 / 0çº§å•æ€: t
- Polymorphic Rank 1 / 1çº§ +å˜æ€+ å¤šæ€: forall a. a -> t
- Polymorphic Rank 2 / 2çº§å¤šæ€: (forall a. a -> t) -> t
- Polymorphic Rank 3 / 3çº§å¤šæ€: ((forall a. a -> t) -> t) -> t

çœ‹rankå‡ åªè¦æ•°å·¦è¾¹ forall çš„æ‹¬å·åµŒå¥—å±‚æ•°å°±å¥½äº†

ä¸€çº§å¤šæ€é”å®šå…¨éƒ¨ç±»å‹å˜åŒ–ä¸­çš„ç±»å‹a

äºŒçº§å¤šæ€å¯ä»¥åˆ†åˆ«ç¡®å®š a -> t è¿™ä¸ªå‡½æ•°çš„ç±»å‹å¤šæ€

æ¯”å¦‚
#+BEGIN_SRC haskell
rank2 :: (forall a. a -> a) -> (Bool, Char)
rank2 f = (f True, f 'a')
#+END_SRC

- f åœ¨ =f True= æ—¶ç±»å‹ =Boolean -> Boolean= æ˜¯ç¬¦åˆ =forall a. a->a= çš„
- åœ¨ =f 'a'= æ—¶ç±»å‹æ˜¯ =Char -> Char= ä¹Ÿç¬¦åˆ =forall a. a->a=

ä½†æ˜¯åˆ°rank1å°±ç±»å‹ç³»ç»Ÿå°±æ‡µé€¼äº†
#+BEGIN_SRC haskell
rank1 :: forall a. (a -> a) -> (Bool, Char)
rank1 f = (f True, f 'a')
#+END_SRC
f åœ¨ =f True= æ˜¯ç¡®å®š a æ˜¯ Booleanï¼Œåœ¨rank1å¤šæ€æ˜¯æ—¶å°±ç¡®å®šäº† =a->a= çš„ç±»å‹ä¸€å®šæ˜¯ =Boolean -> Boolean=

æ‰€ä»¥åˆ° =f 'a'= ç±»å‹å°±æŒ‚äº†ã€‚

** /Monad/ å•å­
æœ‰äº† Functorï¼Œè§£é‡Š Monad å°±ç®€å•äº†ã€‚Monad çš„å®šä¹‰æ¯” Functor å†å¤šä¸€äº›è¦æ±‚
- é¦–å…ˆï¼Œå®ƒæ˜¯ä¸€ä¸ª endofunctor T
- ä¸€ä¸ªä» i_c åˆ° T çš„è‡ªç„¶å˜åŒ– \eta (eta)
- ä¸€ä¸ªä» T^2 åˆ° T çš„è‡ªç„¶å˜åŒ– \mu (mu)

#+BEGIN_SRC haskell
class Endofunctor c t => Monad c t where
  eta :: c a (t a)
  mu  :: c (t (t a)) (t a)
#+END_SRC

åŒæ ·ï¼ŒæŠŠ c = Hask æ›¿æ¢è¿›å»ï¼Œå°±å¾—åˆ°æ›´ç±»ä¼¼æˆ‘ä»¬ Haskell ä¸­ Monad çš„å®šä¹‰
#+BEGIN_SRC haskell
class Endofunctor m => Monad m where
  eta :: a -> (m a)
  mu :: m m a -> m a

#+END_SRC
** /Kleisli Catergory/
#+INDEX: Kleisi Catergory

#+CAPTION: få’Œgç”»ç¿»äº† ğŸ˜‚ ä¸è¿‡é€»è¾‘å¼å¯¹çš„ï¼Œæ³¨æ„ >>= å’Œå¤§ç«ç®­ <=< çš„è½¨è¿¹
https://www.evernote.com/l/ABeNc2skWiZCdLKdJGy4h8L_2GeUo-EDHGsB/image.jpg

Functor çš„ Catergory å«åš Functor Catergoryï¼Œå› ä¸ºæœ‰ç®­å¤´è‡ªç„¶å˜æ¢ã€‚Monad ä¹Ÿå¯ä»¥å®šä¹‰å‡ºæ¥ä¸€ä¸ª Catergoryï¼ˆå½“ç„¶ç”±äºMonadæ˜¯ Endofunctorï¼Œæ‰€ä»¥ä»–ä¹Ÿå¯ä»¥æ˜¯ è‡ªå‡½å­èŒƒç•´ï¼‰ï¼Œå«åš Kleisli Catergoryï¼Œé‚£ä¹ˆ Kleisli çš„ç®­å¤´æ˜¯ä»€ä¹ˆï¼Ÿ

æˆ‘ä»¬çœ‹å®šä¹‰ï¼ŒKleisli Catergory
1. ç®­å¤´æ˜¯ Kleisli ç®­å¤´ =a -> T b=
2. ä¸œè¥¿å°±æ˜¯cèŒƒç•´ä¸­çš„ä¸œè¥¿. å› ä¸º a å’Œ b éƒ½æ˜¯ c èŒƒç•´ä¸Šçš„ï¼Œ ç”±äºTæ˜¯è‡ªå‡½å­ï¼Œæ‰€ä»¥ T b ä¹Ÿæ˜¯ c èŒƒç•´çš„

çœ‹åˆ°å›¾ä¸Šçš„ g' å’Œ \mu äº†æ²¡ï¼Ÿ

- =g':: T b -> T^2 c=
- =\mu :: T^2 c -> T c=

æ‰€ä»¥
- ~(>>=) = \mu . g'~
- å¤§ç«ç®­ ~(<=<) = \mu . g' . f' = \mu . F g . f' ~

å¤§ç«ç®­æ»¡è¶³compose

=(y -> T z) <=< (x -> T y) = (x -> T z)=

æ²¿ç€å›¾ä¸Šè½¨è¿¹æ‰¾æ‰¾çœ‹

* TODO ç¬¬äºŒç« ï¼šPractical Monads
ä¸€äº›æœ‰ç”¨çš„ Monad instances
** Applicative
*** Alternative
*** Arrow
*** Bifunctor

** Either
** Validate
** Reader
ç»™ä¸€ä¸ªcomputationå–‚æ•°æ®
è¾“å…¥ r
asks å¯ä»¥é€šè¿‡å‡½æ•° r->a å¾—åˆ°ä¸€ä¸ª Reader r a monad
#+BEGIN_SRC haskell
asks :: (r -> a) -> Reader r a
runReader :: Reader r a -> r -> a

import Control.Monad.Reader

data MyContext = MyContext
  { foo :: String
  , bar :: Int
  } deriving (Show)

computation :: Reader MyContext (Maybe String)
computation = do
  n <- asks bar
  x <- asks foo
  if n > 0
    then return (Just x)
    else return Nothing

ex1 :: Maybe String
ex1 = runReader computation $ MyContext "hello" 1

ex2 :: Maybe String
ex2 = runReader computation $ MyContext "haskell" 0
#+END_SRC
** Writter
é™¤äº†è¿”å›å€¼ï¼Œcomputationä¼šå†™ä¸€äº›é¢å¤–çš„æ•°æ®

è¿”å›å€¼ä¼šæ˜¯ä¸€ä¸ªè¿™æ · =(result, log)= çš„ tuple

é™åˆ¶æ˜¯ log çš„ç±»å‹å¿…é¡»æ˜¯ä¸ª monoid

#+BEGIN_SRC haskell
example  = do
  tell [1..3]
  tell [3..5]
  return "foo"

output :: (String, [Int])
output = runWriter example
-- ("foo", [1, 2, 3, 3, 4, 5])
#+END_SRC
** State

** RWS
** Expection
** Monad Transform
** Cont
** MonadPlus
** MonadFix
** ST
** Free Monad
** Eff

* References
http://dev.stephendiehl.com/hask
https://www.youtube.com/watch?v=ZKmodCApZwk
