#+TITLE: èŒƒç•´è®ºå®Œå…¨è£…é€¼æ‰‹å†Œ / Grokking Monad
#+Date: <2017-02-10 Fri>
#+AUTHOR: æ¬§é˜³ç»§è¶…
#+OPTIONS: ^:t
#+MACRO: ruby @@html:<ruby>$1<rt>$2</rt></ruby>@@

å¾ˆå¤šäººéƒ½ä¸æ˜ç™½ä»€ä¹ˆæ˜¯Monadï¼Œå¹¶ä¸æ˜¯å› ä¸ºä¸ä¼šç”¨ï¼Œä¸çŸ¥è§‰å¯èƒ½å°±åœ¨ç”¨æŸç§ monadã€‚\\
å®šä¹‰å’Œä½¿ç”¨èµ·æ¥å…¶å®ä¸éš¾ï¼Œå›°æƒ‘çš„å¤§å¤šåº”è¯¥æ˜¯åé¢çš„è¿™å †ç†è®º-- èŒƒç•´è®ºã€‚å½“ç„¶ï¼Œæˆ‘ä¹Ÿæ²¡å­¦è¿‡èŒƒç•´è®ºï¼Œåªæ˜¯ç•¥å¾®çœ‹å¾—æ‡‚å†™Haskellç½¢äº†ã€‚

æˆ‘åœ¨ä¹¦ä¸­[[https://book.douban.com/subject/26883736/][å†™è¿‡ä¸€ç« ]]æ¥è§£é‡Šï¼ŒæŸäººä¹Ÿå°è¯•è¿‡å¾ˆ[[http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html][å†™åšå®¢è§£é‡Š]]ï¼Œæ¯”å¦‚ä¸ºäº†é™ä½é—¨æ§›ç”¨JSæ¥ï¼Œé‚£Haskell/Scalaçš„äººå‡ºæ¥å–·ä½ ä»¬å‰ç«¯è¿™äº›ä¸æ‡‚å‡½æ•°å¼çš„æ¸£æ¸£ä¹±æå‡ºæ¥çš„ä¸œè¥¿æ ¹æœ¬å°±ä¸æ˜¯ monadã€‚

æˆ‘ä¹Ÿç”»è¿‡ä¸€äº›å›¾æ¥è§£é‡Šï¼Œåˆä¼šè¢«å«Œå¼ƒç”»é£ä¸å¥½ã€‚ä½†æ˜¯ï¼Œä½œä¸ºçµé­‚ç”»å¸ˆï¼Œæˆ‘åª +æ˜¯è§‰å¾—è‡ªå·±èŒèŒçš„å•Š+ åœ¨ä¹ç”»çš„çµé­‚æ˜¯å¦èƒ½å¤Ÿç»™ä½ ä¸€ç‚¹å¯å‘ã€‚å¥½å§ï¼Œè®²è¿™ä¹ˆå­¦æœ¯çš„ä¸œè¥¿ï¼Œè¿˜æ˜¯ç”¨dotæ¥ç”»å§ï¼Œçœ‹èµ·æ¥å¥½æ­£è§„å‘¢ã€‚

å¥½äº†ï¼Œå®‰å…¨å¸¦ç³»å¥½ï¼Œæˆ‘çœŸçš„è¦å¼€è½¦äº†ã€‚ä¸ºäº† +é˜²æ­¢é„™è§†é“¾é¡¶ç«¯çš„è¯­è¨€ç”¨æˆ·ä»¬å–·å†å«Œå¼ƒ+ è§£é‡Šçš„ä¸åˆ°ä½ï¼Œå°±ç”¨ Haskell å¥½äº†ï¼ˆè™½ç„¶haskellä¹Ÿæ²¡åˆ°é„™è§†é“¾é¡¶ï¼‰ï¼Œå…¶å®ä¹Ÿä¸éš¾è§£é‡Šæ¸…æ¥š +æ‰æ€ª+ ã€‚

è¿™é‡Œé¢å¾ˆå¤šå¾ˆè£…é€¼çš„å•è¯ï¼Œå®ƒä»¬éƒ½æ˜¯ /æ–œä½“/ ï¼Œå°±ç®—æ²¡çœ‹æ‡‚ï¼ŒæŠŠè¿™äº›è¯è®°ä½ä¹Ÿè¶³å¤Ÿ{{{ruby(è£…ä¸€é˜µå­é€¼äº†,ä¹°ä¸€é˜µå­èŒäº†)}}}ã€‚

* COMMENT
#+BEGIN_SRC emacs-lisp
(require 'ob-dot)
#+END_SRC

#+RESULTS:
: ob-dot

* ç¬¬ä¸€éƒ¨åˆ†ï¼š{{{ruby(èŒƒç•´è®º,Catergory Theory)}}}
** /Category/
#+INDEX: Catergory
#+INDEX: èŒƒç•´

ä¸€ä¸ª /{{{ruby(èŒƒç•´,Category)}}}/ åŒ…å«ä¸¤ä¸ªç©æ„
- ä¸œè¥¿ =O= ï¼ˆObjectï¼‰
- ä¸¤ä¸ªä¸œè¥¿çš„å…³ç³»ï¼Œç®­å¤´ =~>= ï¼ˆ /{{{ruby(æ€å°„,Morphism)}}}/ ï¼‰

ä¸€äº›å±æ€§
- ä¸€å®šæœ‰ä¸€ä¸ªå« id çš„ç®­å¤´ï¼Œä¹Ÿå«åš 1
- ç®­å¤´å¯ä»¥ /{{{ruby(ç»„åˆ, compose)}}}/

æ©ï¼Œå°±æ˜¯è¿™ä¹ˆç®€å•

#+BEGIN_SRC dot :file images/category.svg :exports results
  digraph {
          label="Category"
          rankdir=RL
          a -> b [label=g]
          b -> c [label=f]
          a -> a [label=id]
          b -> b [label=id]
          c -> c [label=id]
          a -> c [label="f . g"]
  }
#+END_SRC

#+CAPTION: æœ‰ä¸œè¥¿ a, b, c å’Œç®­å¤´ f, g çš„ Categoryï¼Œå…¶ä¸­ f . g è¡¨ç¤º compose f å’Œ g
#+RESULTS:
[[file:images/category.svg]]

è¿™äº›ç©æ„å¯¹åº”åˆ° haskell çš„ typeclass å¤§è‡´å°±æ˜¯è¿™æ ·
#+BEGIN_SRC haskell
class Category (c :: * -> * -> *) where
  id :: c a a
  (.) :: c y z -> c x y -> c x z
#+END_SRC

å¦‚æœè¿™æ˜¯ä½ ç¬¬ä¸€æ¬¡è§åˆ° Haskell ä»£ç ï¼Œæ²¡æœ‰å…³ç³»ï¼Œè¯­æ³•çœŸçš„å¾ˆç®€å• +æ‰æ€ª+
- =class= å®šä¹‰äº†ä¸€ä¸ª TypeClassï¼Œ =Category= æ˜¯è¿™ä¸ª TypeClass çš„åå­—
- Type class ç±»ä¼¼äºå®šä¹‰ç±»å‹çš„è§„èŒƒï¼Œè§„èŒƒä¸º =where= åé¢é‚£ä¸€å¨
- ç±»å‹è§„èŒƒçš„å¯¹è±¡æ˜¯å‚æ•° ~(c:: * -> * -> *)~ ï¼Œ =::= åé¢æ˜¯cçš„ç±»å‹
- c æ˜¯ /higher kind/ ï¼Œè·Ÿhigher order functionçš„å®šä¹‰å·®ä¸å¤šï¼Œå®ƒæ˜¯æ¥æ”¶ç±»å‹ï¼Œæ„é€ æ–°ç±»å‹çš„ç±»å‹ã€‚è¿™é‡Œçš„ c æ¥æ”¶ä¸€ä¸ªç±»å‹ï¼Œå†æ¥æ”¶ä¸€ä¸ªç±»å‹ï¼Œå°±å¯ä»¥è¿”å›ä¸ªç±»å‹ã€‚
- ~id:: c a a~ è¡¨ç¤º c èŒƒç•´ä¸Šçš„ a åˆ° a çš„ç®­å¤´
- =.= çš„æ„æ€ c èŒƒç•´ä¸Šï¼Œå¦‚æœå–‚ä¸€ä¸ª y åˆ° z çš„ç®­å¤´ï¼Œå†å–‚ä¸€ä¸ª x åˆ° y çš„ç®­å¤´ï¼Œé‚£ä¹ˆå°±è¿”å› x åˆ° z çš„ç®­å¤´ã€‚

{{{ruby(ç®€å•å§,hen nan ba)}}}?è¿˜æ²¡æœ‰é«˜æ•°æŠ½è±¡å‘¢ã€‚

*** /Hask/
Haskell ç±»å‹ç³»ç»ŸèŒƒç•´å«åš Hask
#+INDEX: Hask

åœ¨ Hask èŒƒç•´ä¸Šï¼š

- ä¸œè¥¿æ˜¯ç±»å‹
- ç®­å¤´æ˜¯ç±»å‹çš„å˜æ¢ï¼Œå³ =->=
- id å°±æ˜¯ id å‡½æ•°çš„ç±»å‹ =a -> a=
- compose å½“ç„¶å°±æ˜¯å‡½æ•°ç»„åˆçš„ç±»å‹

#+BEGIN_SRC haskell
type Hask = (->)
instance Category (Hask:: * -> * -> *) where
  (f . g) x = f (g x)
#+END_SRC

æˆ‘ä»¬çœ‹è§æ–°çš„å…³é”®å­— =instance= ï¼Œè¿™è¡¨ç¤º Hask æ˜¯ Type class Category çš„å®ä¾‹ç±»å‹ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥Haskçš„ä¸ªæ„é€ å™¨å»çœŸçš„æ„é€ ä¸€ä¸ªç±»å‹

æ¯”å¦‚ï¼š
#+BEGIN_SRC haskell
(->) a a
#+END_SRC
å°±æ„é€ äº†ä¸€ä¸ªä»aç±»å‹åˆ°aç±»å‹çš„çš„ç±»å‹

æ„é€ å‡ºæ¥çš„è¿™ä¸ªç±»å‹å¯ä»¥ä½œä¸º id å‡½æ•°çš„ç±»å‹
#+BEGIN_SRC haskell
id :: (->) a a
#+END_SRC

** /{{{ruby(å‡½å­, Functor)}}}/
#+INDEX: Functor
#+INDEX: å‡½å­
ä¸¤ä¸ªèŒƒç•´ä¸­é—´å¯ä»¥ç”¨å« Functor çš„ä¸œè¥¿æ¥è¿æ¥èµ·æ¥ï¼Œç®€ç§° Tã€‚

#+BEGIN_SRC dot :file images/functor.svg :exports results
  digraph {

  label="Functor C D G"
  compound=true;
  rankdir=RL
  subgraph cluster_C {
          style=dotted
          label="C"
          a -> a [label=id]
          a -> b [label=g]
          b -> c [label=f]
          a -> c [label="f . g"]
  }
  subgraph cluster_D {
          style=dotted
          label=D
          "G a" -> "G a" [label="G id"]
          "G a" -> "G b" [label="G g"]
          "G b" -> "G c" [label="G f"]
          "G a" -> "G c" [label="G f . g = G f . G g"]
  }

  c ->"G a"[ltail=cluster_C,lhead=cluster_D,label=G]
  }
#+END_SRC

#+CAPTION: Functor C D G, ä» C åˆ° D èŒƒç•´çš„Functor G
#+RESULTS:
[[file:images/functor.svg]]

æ‰€ä»¥å¤§éƒ¨åˆ†æŠŠFunctor/Monadæ¯”å–»æˆç›’å­å…¶å®åœ¨å®šä¹‰ä¸Šæ˜¯é”™çš„ï¼Œè™½ç„¶è¿™æ ·æ¯”å–»æ¯”è¾ƒå®¹æ˜“ç†è§£ï¼Œåœ¨ä½¿ç”¨ä¸Šé—®é¢˜ä¹Ÿä¸å¤§ã€‚ä½†æ˜¯ï¼ŒFunctoråªæ˜¯ä»ä¸€ä¸ªèŒƒç•´åˆ°å¦ä¸€ä¸ªèŒƒç•´çš„æ˜ å°„å…³ç³»è€Œå·²ã€‚

- èŒƒç•´é—´ ä¸œè¥¿çš„ Functor æ ‡è®°ä¸º =T(O)=
- èŒƒç•´é—´ ç®­å¤´çš„ Functor æ ‡è®°ä¸º =T(~>)=
- ä»»ä½•èŒƒç•´Cä¸Šå­˜åœ¨ä¸€ä¸ª T æŠŠæ‰€æœ‰çš„ O å’Œ ~> éƒ½æ˜ å°„åˆ°è‡ªå·±ï¼Œæ ‡è®°ä¸ºid functor 1_C
  - 1_C(O) = O
  - 1_C(~>) = ~>

#+BEGIN_SRC haskell
class (Category a, Category b) => Functor a b t where
  fmap :: c a b -> d (t a) (t b)
#+END_SRC

=Functor a b t= è¿™è¡¨ç¤ºä»èŒƒç•´ a åˆ°èŒƒç•´ b çš„ä¸€ä¸ª Functor t

å¦‚æœæŠŠèŒƒç•´ a å’Œ b éƒ½é™åˆ¶åˆ° Hask èŒƒç•´

#+BEGIN_SRC haskell
class Functor (->) (->) t where
  fmap :: (->) a b -> (->) (t a) (t b)
#+END_SRC

=->= åœ¨ Haskell ä¸­æ˜¯ä¸­ç¼€ç±»å‹æ„é€ å™¨ï¼Œæ‰€ä»¥æ˜¯å¯ä»¥å†™åœ¨ä¸­é—´çš„

è¿™æ ·å°±ä¼šå˜æˆæˆ‘ä»¬ç†Ÿæ‚‰çš„ Funtor çš„ Typeclassï¼ˆæŠŠFunctor çš„ç¬¬ä¸€ç¬¬äºŒä¸ªå‚æ•°å»æ‰çš„è¯ï¼‰
#+BEGIN_SRC haskell
class Functor t where
  fmap :: (a -> b) -> (t a -> t b)
#+END_SRC

è€Œ /{{{ruby(è‡ªå‡½å­,endofunctor)}}}/ å°±æ˜¯è¿™ç§è¿æ¥ç›¸åŒèŒƒç•´çš„ Functorï¼Œå› ä¸ºå®ƒä»èŒƒç•´ Hask åˆ°è¾¾åŒæ ·çš„èŒƒç•´ Hask
#+INDEX: endofunctor
#+INDEX: è‡ªå‡½å­

è¿™é‡Œçš„ fmap å°±æ˜¯ T(~>)ï¼Œåœ¨ Hask èŒƒç•´ä¸Šï¼Œæ‰€ä»¥æ˜¯ T(->), è¿™ä¸ªç®­å¤´æ˜¯å‡½æ•°ï¼Œæ‰€ä»¥ä¹Ÿèƒ½è¡¨ç¤ºæˆ T(f) å¦‚æœ =f:: a -> b=

** /{{{ruby(Cat, +çŒ«+)}}}/
å½“æˆ‘ä»¬æŠŠä¸€ä¸ªCategoryçœ‹æˆä¸€ä¸ªobjectï¼Œfunctorçœ‹æˆç®­å¤´ï¼Œé‚£ä¹ˆæˆ‘ä»¬åˆå¾—åˆ°äº†ä¸€ä¸ªCategoryï¼Œè¿™ç§objectæ˜¯categoryçš„categoryæˆ‘ä»¬å«å®ƒ -- /Cat/

å·²ç»æ²¡æ³•è®²äº†ï¼Œçœ‹ TODO å›¾å§

** /{{{ruby(è‡ªç„¶å˜æ¢,Natural Transformations)}}}/
#+INDEX: Natural Transformations
#+INDEX: è‡ªç„¶å˜æ¢
Functor æ˜¯èŒƒç•´é—´çš„æ˜ å°„ï¼Œè€Œ Functor åœ¨ Cat èŒƒç•´åˆæ˜¯ä¸ªç®­å¤´ï¼Œæ‰€ä»¥ï¼ŒFunctoré—´çš„æ˜ å°„ï¼Œä¹Ÿå°±æ˜¯ Cat èŒƒç•´ä¸Šçš„ Functorï¼Œå«åš /è‡ªç„¶å˜æ¢/

#+BEGIN_SRC dot :file images/natrual-transformation.svg :exports results
  digraph {
  label="Functor F åˆ° G çš„è‡ªç„¶å˜æ¢"
  compound=true;
  rankdir=RL
  subgraph cluster_C {
          style=dotted
          label="C"
          a -> a [label=id]
          a -> b [label=g]
          b -> c [label=f]
          a -> c [label="f . g"]
  }
  subgraph cluster_D {
          style=dotted
          label=D
          "G a" -> "G a" [label="G id"]
          "G a" -> "G b" [label="G g"]
          "G b" -> "G c" [label="G f"]
          "G a" -> "G c" [label="G f . g = G f . G g"]
  }
  subgraph cluster_E {
          style=dotted
          label=E
          "F a" -> "F a" [label="F id"]
          "F a" -> "F b" [label="F g"]
          "F b" -> "F c" [label="F f"]
          "F a" -> "F c" [label="F f . g = F f . F g"]
  }

  subgraph FunctorCategory {
          style=dotted
          label="Functor Category"
          rank=same;
          functorG [label="G",shape=plaintext,width=0.01, height=0.01];
          functorF [label="F", shape=plaintext, width=0.01, height=0.01];
  }
  functorF -> functorG[label="Î·"]
  c -> functorG [arrowhead=none]
  c -> functorF [arrowhead=none]
  functorG ->"G a"[ltail=cluster_C,lhead=cluster_D]

  functorF ->"F a"[ltail=cluster_C,lhead=cluster_E]
  }
#+END_SRC

#+CAPTION: Functor Få’ŒGï¼Œä»¥åŠ F åˆ° G çš„è‡ªç„¶å˜åŒ– \eta
#+RESULTS:
[[file:images/natrual-transformation.svg]]

æ‰€ä»¥èŒƒç•´ c ä¸Šçš„å‡½å­ f åˆ° g çš„è‡ªç„¶å˜åŒ–å°±å¯ä»¥è¡¨ç¤ºæˆ
#+BEGIN_SRC haskell
type Nat c f g = c (f a) (g a)
#+END_SRC

Hask èŒƒç•´ä¸Šçš„è‡ªç„¶å˜åŒ–å°±å˜æˆäº†
#+BEGIN_SRC haskell
type NatHask f g = f a -> g a
#+END_SRC

æœ‰è¶£çš„æ˜¯ï¼Œè‡ªç„¶è½¬æ¢ä¹Ÿæ»¡è¶³ç®­å¤´çš„æ¦‚å¿µï¼Œå¯ä»¥å½“æˆ functor èŒƒç•´ä¸Šçš„ç®­å¤´ï¼Œæ‰€ä»¥åˆå¯ä»¥å®šä¹‰å‡ºæ¥ä¸€ä¸ª Functor Catergory

- ä¸œè¥¿æ˜¯å‡½å­
- ç®­å¤´æ˜¯è‡ªç„¶å˜æ¢

è¦æˆä¸ºèŒƒç•´ï¼Œè¿˜æœ‰ä¸¤ç‚¹
- id ä¸º f a åˆ° f a çš„è‡ªç„¶å˜æ¢
- è‡ªç„¶å˜æ¢çš„ç»„åˆ

#+BEGIN_SRC dot :file images/functor-category.svg :exports results
digraph FunctorCategory {
          style=dotted
          label="Functor Category"
          rank=same;
          functorG [label="G",shape=plaintext,width=0.01, height=0.01];
          functorF [label="F", shape=plaintext, width=0.01, height=0.01];
functorF -> functorG[label="Î·"]
  }
#+END_SRC

#+RESULTS:
[[file:images/functor-category.svg]]

æˆ‘ä»¬æ¥æ¢³ç†ä¸€ä¸‹ï¼Œå·²ç»ä¸çŸ¥é“å‡äº†å‡ ä¸ªç»´åº¦äº†ï¼Œæˆ‘ä»¬å‡è®¾ç±»å‹æ˜¯ç¬¬ä¸€ç»´åº¦
- ä¸€ç»´ï¼šèŒƒç•´ Haskï¼Œä¸œè¥¿æ˜¯ç±»å‹ï¼Œç®­å¤´æ˜¯ ->
- äºŒç»´ï¼šèŒƒç•´ Catï¼Œ ä¸œè¥¿æ˜¯ Haskï¼Œ ç®­å¤´æ˜¯ Functor
- ä¸‰ç»´ï¼šèŒƒç•´ Functorï¼Œ ä¸œè¥¿æ˜¯Functorï¼Œ ç®­å¤´æ˜¯è‡ªç„¶å˜æ¢

æ„Ÿè§‰åˆ°è¾¾ä¸‰ç»´å·²ç»æ˜¯æé™äº†ï¼Œå°¼ç›è¿˜æœ‰å®Œæ²¡å®Œäº†ï¼Œæ¯å‡ä¸€ä¸ªç»´åº¦è¿˜è¦èµ·è¿™ä¹ˆå¤šè£…é€¼çš„åå­—ï¼Œå†å‡ç»´åº¦å°±è¦ä¸€è„¸æ‡µé€¼äº†å‘¢ã€‚è™½ç„¶ç»´åº¦ä¸ç®—å¤ªé«˜ï¼Œä½†æ˜¯å·²ç»ä¸èƒ½ç”¨ç®€å•çš„å›¾æ¥æè¿°äº†ï¼Œæ‰€ä»¥éœ€è¦å¼•å…¥ String Diagramã€‚

** TODO String Diagram

T1 æ˜¯ èŒƒç•´ a åˆ° b çš„functor

T2 æ˜¯èŒƒç•´ b åˆ° c çš„functor

é‚£ä¹ˆ T2 . T1 å°±æ˜¯ a åˆ° c çš„funtorå’¯

å¦‚æœ T æ˜¯èŒƒç•´aä¸Šçš„endofunctor

é‚£ä¹ˆå¯ä»¥ T.T å¯ä»¥å†™æˆ TT æˆ–è€… T^2

é‚£ä¹ˆ compose å®Œçš„ç®­å¤´å¼ ä»€ä¹ˆæ ·å‘¢ï¼Ÿ

ç”¨ Maybe Functoræ¥è¯´

#+BEGIN_SRC haskell
-- Functor category
newtype Fun f g a b = FNat (f a -> g b)

-- Endofunctor category
type End f = Fun f f

instance Category (End f) where
  id = FNat id
  (FNat f) . (FNat g) = FNat (f . g)
#+END_SRC

** TODO /Adjunction Functor/ ä¼´éšå‡½å­
#+INDEX: Adjunction Functor
èŒƒç•´Cå’ŒDç›´æ¥æœ‰æ¥æœ‰å›çš„å‡½å­
** TODO Yoneda lemma / +ç±³ç”°å…±+ ç±³ç”°å¼•ç†
#+INDEX: ç±³ç”°å¼•ç†
#+INDEX: Yoneda Lemma

ç±³ç”°å¼•ç†æ˜¯è¯´æ‰€æœ‰Functor =f a= ä¸€å®šå­˜åœ¨ embed å’Œ unembedï¼Œä½¿å¾— =f a= å’Œ =(a -> b) -> F b= isomorphic åŒæ„
#+INDEX: isomorphic
#+INDEX: åŒæ„

haskellè¿˜è¦å…ˆæ‰“å¼€ RankNTypes çš„ feature

#+BEGIN_SRC haskell
{-# LANGUAGE RankNTypes #-}

embed :: Functor f => f a -> (forall b . (a -> b) -> f b)
embed x f = fmap f x

unembed :: Functor f => (forall b . (a -> b) -> f b) -> f a
unembed f = f id
#+END_SRC

embed å¯ä»¥æŠŠ functor =f a= å˜æˆ =(a -> b) -> f b=

unembed æ˜¯åè¿‡æ¥ï¼Œ =(a -> b) -> f b= å˜æˆ =f a=
*** Rank N Type
#+INDEX: Arbitrary-rank polymorphism
#+INDEX: Rank N Type
- Monomorphic Rank 0 / 0çº§å•æ€: t
- Polymorphic Rank 1 / 1çº§ +å˜æ€+ å¤šæ€: forall a. a -> t
- Polymorphic Rank 2 / 2çº§å¤šæ€: (forall a. a -> t) -> t
- Polymorphic Rank 3 / 3çº§å¤šæ€: ((forall a. a -> t) -> t) -> t

çœ‹rankå‡ åªè¦æ•°å·¦è¾¹ forall çš„æ‹¬å·åµŒå¥—å±‚æ•°å°±å¥½äº†

ä¸€çº§å¤šæ€é”å®šå…¨éƒ¨ç±»å‹å˜åŒ–ä¸­çš„ç±»å‹a

äºŒçº§å¤šæ€å¯ä»¥åˆ†åˆ«ç¡®å®š a -> t è¿™ä¸ªå‡½æ•°çš„ç±»å‹å¤šæ€

æ¯”å¦‚
#+BEGIN_SRC haskell
rank2 :: (forall a. a -> a) -> (Bool, Char)
rank2 f = (f True, f 'a')
#+END_SRC

- f åœ¨ =f True= æ—¶ç±»å‹ =Boolean -> Boolean= æ˜¯ç¬¦åˆ =forall a. a->a= çš„
- åœ¨ =f 'a'= æ—¶ç±»å‹æ˜¯ =Char -> Char= ä¹Ÿç¬¦åˆ =forall a. a->a=

ä½†æ˜¯åˆ°rank1å°±ç±»å‹ç³»ç»Ÿå°±æ‡µé€¼äº†
#+BEGIN_SRC haskell
rank1 :: forall a. (a -> a) -> (Bool, Char)
rank1 f = (f True, f 'a')
#+END_SRC
f åœ¨ =f True= æ˜¯ç¡®å®š a æ˜¯ Booleanï¼Œåœ¨rank1å¤šæ€æ˜¯æ—¶å°±ç¡®å®šäº† =a->a= çš„ç±»å‹ä¸€å®šæ˜¯ =Boolean -> Boolean=

æ‰€ä»¥åˆ° =f 'a'= ç±»å‹å°±æŒ‚äº†ã€‚

** /Monad/ å•å­
æœ‰äº† Functorï¼Œè§£é‡Š Monad å°±ç®€å•äº†ã€‚Monad çš„å®šä¹‰æ¯” Functor å†å¤šä¸€äº›è¦æ±‚
- é¦–å…ˆï¼Œå®ƒæ˜¯ä¸€ä¸ª endofunctor T
- ä¸€ä¸ªä» i_c åˆ° T çš„è‡ªç„¶å˜åŒ– \eta (eta)
- ä¸€ä¸ªä» T^2 åˆ° T çš„è‡ªç„¶å˜åŒ– \mu (mu)

#+BEGIN_SRC haskell
class Endofunctor c t => Monad c t where
  eta :: c a (t a)
  mu  :: c (t (t a)) (t a)
#+END_SRC

åŒæ ·ï¼ŒæŠŠ c = Hask æ›¿æ¢è¿›å»ï¼Œå°±å¾—åˆ°æ›´ç±»ä¼¼æˆ‘ä»¬ Haskell ä¸­ Monad çš„å®šä¹‰
#+BEGIN_SRC haskell
class Endofunctor m => Monad m where
  eta :: a -> (m a)
  mu :: m m a -> m a

#+END_SRC
** /Kleisli Catergory/
#+INDEX: Kleisi Catergory

#+CAPTION: få’Œgç”»ç¿»äº† ğŸ˜‚ ä¸è¿‡é€»è¾‘å¼å¯¹çš„ï¼Œæ³¨æ„ >>= å’Œå¤§ç«ç®­ <=< çš„è½¨è¿¹
https://www.evernote.com/l/ABeNc2skWiZCdLKdJGy4h8L_2GeUo-EDHGsB/image.jpg

Functor çš„ Catergory å«åš Functor Catergoryï¼Œå› ä¸ºæœ‰ç®­å¤´è‡ªç„¶å˜æ¢ã€‚Monad ä¹Ÿå¯ä»¥å®šä¹‰å‡ºæ¥ä¸€ä¸ª Catergoryï¼ˆå½“ç„¶ç”±äºMonadæ˜¯ Endofunctorï¼Œæ‰€ä»¥ä»–ä¹Ÿå¯ä»¥æ˜¯ è‡ªå‡½å­èŒƒç•´ï¼‰ï¼Œå«åš Kleisli Catergoryï¼Œé‚£ä¹ˆ Kleisli çš„ç®­å¤´æ˜¯ä»€ä¹ˆï¼Ÿ

æˆ‘ä»¬çœ‹å®šä¹‰ï¼ŒKleisli Catergory
1. ç®­å¤´æ˜¯ Kleisli ç®­å¤´ =a -> T b=
2. ä¸œè¥¿å°±æ˜¯cèŒƒç•´ä¸­çš„ä¸œè¥¿. å› ä¸º a å’Œ b éƒ½æ˜¯ c èŒƒç•´ä¸Šçš„ï¼Œ ç”±äºTæ˜¯è‡ªå‡½å­ï¼Œæ‰€ä»¥ T b ä¹Ÿæ˜¯ c èŒƒç•´çš„

çœ‹åˆ°å›¾ä¸Šçš„ g' å’Œ \mu äº†æ²¡ï¼Ÿ

- g':: T b -> T^2 c
- \mu :: T^2 c -> T c

æ‰€ä»¥
- (>>=) = \mu . g'
- å¤§ç«ç®­ (<=<) = \mu . g' . f' = \mu . F g . f'

å¤§ç«ç®­æ»¡è¶³compose

(y -> T z) <=< (x -> T y) = (x -> T z)

æ²¿ç€å›¾ä¸Šè½¨è¿¹æ‰¾æ‰¾çœ‹

#+BEGIN_QUOTE
ç¬¬ä¸€éƒ¨åˆ†ç†è®ºéƒ¨åˆ†éƒ½è®²å®Œäº†ï¼Œ å¦‚æœä½ è¯»åˆ°è¿™é‡Œè¿˜æ²¡æœ‰è¢«è¿™äº›{{{ruby(åŠç‚¸å¤©,ä¹±ä¸ƒå…«ç³Ÿ)}}}çš„æ¦‚å¿µædazeï¼Œæ¥ä¸‹æ¥å¯ä»¥çœ‹çœ‹å®ƒåˆ°åº•è·Ÿæˆ‘ä»¬ç¼–ç¨‹æœ‰é¸Ÿå…³ç³»å‘¢ï¼Ÿç¬¬äºŒéƒ¨åˆ†å°†ä»‹ç»è¿™äº›æ¦‚å¿µäº§ç”Ÿçš„ä¸€äº›å®ç”¨çš„monad

å½“ç„¶æˆ‘è¿˜æ²¡ç©ºå…¨éƒ¨å†™å®Œï¼Œå¦‚æœæœ‰å¾ˆå¤šäºº{{{ruby(é¢„å®š,åªè¦998)}}} Gumroad ä¸Šçš„ @@html: <script src="https://gumroad.com/js/gumroad.js"></script><a class="gumroad-button" href="https://gum.co/grokking-monad" target="_blank">Grokking Monad</a>@@ ç”µå­ä¹¦çš„è¯ï¼Œæˆ‘å¯èƒ½ä¼šç¨å¾®å†™å¾—å¿«ä¸€äº›ã€‚æ¯•ç«Ÿï¼Œå†™äº†ä¹Ÿæ²¡äººæ„Ÿå…´è¶£ä¹Ÿæ€ªæµªè´¹æ—¶é—´çš„ã€‚ä¸è¿‡ï¼Œæˆ‘çŒœä¹Ÿæ²¡å‡ ä¸ªäººèƒ½çœ‹åˆ°è¿™ä¸€è¡Œã€‚
#+END_QUOTE

* TODO ç¬¬äºŒéƒ¨åˆ†ï¼š{{{ruby(é£Ÿç”¨çŒ«å‘¢, Practical Monads)}}}
ä¸€äº›æœ‰ç”¨çš„ Monad instances
** Applicative
*** Alternative
*** Arrow
*** Bifunctor

** Either
** Validate
** Reader
ç»™ä¸€ä¸ªcomputationå–‚æ•°æ®
è¾“å…¥ r
asks å¯ä»¥é€šè¿‡å‡½æ•° r->a å¾—åˆ°ä¸€ä¸ª Reader r a monad
#+BEGIN_SRC haskell
asks :: (r -> a) -> Reader r a
runReader :: Reader r a -> r -> a

import Control.Monad.Reader

data MyContext = MyContext
  { foo :: String
  , bar :: Int
  } deriving (Show)

computation :: Reader MyContext (Maybe String)
computation = do
  n <- asks bar
  x <- asks foo
  if n > 0
    then return (Just x)
    else return Nothing

ex1 :: Maybe String
ex1 = runReader computation $ MyContext "hello" 1

ex2 :: Maybe String
ex2 = runReader computation $ MyContext "haskell" 0
#+END_SRC
** Writter
é™¤äº†è¿”å›å€¼ï¼Œcomputationä¼šå†™ä¸€äº›é¢å¤–çš„æ•°æ®

è¿”å›å€¼ä¼šæ˜¯ä¸€ä¸ªè¿™æ · =(result, log)= çš„ tuple

é™åˆ¶æ˜¯ log çš„ç±»å‹å¿…é¡»æ˜¯ä¸ª monoid

#+BEGIN_SRC haskell
example  = do
  tell [1..3]
  tell [3..5]
  return "foo"

output :: (String, [Int])
output = runWriter example
-- ("foo", [1, 2, 3, 3, 4, 5])
#+END_SRC
** State

** RWS
** Expection
** Monad Transform
** Cont
** MonadPlus
** MonadFix
** ST
** Free Monad
** Eff

* References
- http://dev.stephendiehl.com/hask
- https://www.youtube.com/watch?v=ZKmodCApZwk
- https://en.wikibooks.org/wiki/Haskell/Category_theory
