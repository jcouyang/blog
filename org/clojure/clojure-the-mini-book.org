#+TITLE: Clojure The Mini Book
#+DESCRIPTION: Why we need to learn clojure and why it's so awesome
#+KEYWORDS: clojure,tutorial,emacs,lisp
#+DATE: <2015-02-26 Thu>

#+BEGIN_SRC emacs-lisp :exports none
;; please using cider version of ob-clojure 
(require 'ob-clojure)
(require 'ob-js)
;;(setq org-babel-clojure-backend 'cider)
#+END_SRC

#+RESULTS:
: cider

* æˆ‘æ¯å¤©ç”¨æ‹¬å·å½“æ—©é¥­
 :PROPERTIES:
  :header-args: :eval no
  :END:
** ä¸ºä»€ä¹ˆè¦å­¦ä¹ å…¨æ˜¯æ‹¬å·çš„è¯­è¨€
é€‰æ‹©Clojureæ˜¯å› ä¸º
- ä¸“é—¨ä¸ºå¤šçº¿ç¨‹å¹¶å‘ç¼–ç¨‹è®¾è®¡
- è·‘åœ¨JVMä¸Šï¼Œä½¿éƒ¨ç½²å˜å¾—ç®€å•
- lispè¯­æ³•å¤ªç®€å•äº†ï¼Œå‡½æ•°ï¼Œå‡½æ•°ï¼Œéƒ½æ˜¯å‡½æ•°
- åŠ¨æ€ç±»å‹ï¼Œæ›´çµæ´»
- æ•°æ®ç»“æ„éƒ½æ˜¯Immutableï¼Œmutable is evil
- ä¸Javaäº¤äº’
- ä¸°å¯Œçš„ç¬¬ä¸‰æ–¹åº“

*** lisp æ˜¯å¥½ä¸œè¥¿

[[./images/lisp_cycles.png]]

ä¸Šä¸–çºª50å¹´ä»£çš„å°±æœ‰äº†lispè¯­è¨€ï¼Œéƒ½ä¸èƒ½è¯´å®ƒä¸æ˜¯ä¸€é—¨è¯­è¨€ï¼Œå› ä¸ºä»–å¤ªå¤šç§æ–¹è¨€äº†ã€‚è™½ç„¶ä¸€ç›´éƒ½ä¸æ¸©ä¸ç«ï¼Œä½†æ˜¯éšç€ç³»ç»Ÿé€»è¾‘å’Œè®¡ç®—è¶Šæ¥è¶Šå¤æ‚ï¼Œå†åŠ ä¸Šåˆ†å¸ƒå¼å’Œå¹¶è¡Œè®¡ç®—ã€‚äººä»¬çªç„¶å‘ç°å‡½æ•°å¼æ˜¯ä¸€ä¸ªå¥½ä¸œè¥¿ï¼Œstate is evilã€‚ç›®å‰æ¯”è¾ƒæµè¡Œçš„lispæ–¹è¨€æ˜¯Clojureï¼ŒSchemeã€‚
  
*** å‡½æ•°å¼æ˜¯å¥½ä¸œè¥¿

OOå¹¶æ²¡æœ‰æƒ³è±¡ä¸­çš„å¥½ï¼Œå¸¦çŠ¶æ€å’Œmutableçš„ä»£ç ç‰¹åˆ«éš¾æ¨ç†ï¼Œéå¸¸éš¾è¯»ã€‚éœ€è¦ç‰¹åˆ«å¤šçš„ä¸Šä¸‹æ–‡æ‰èƒ½æ¨ç†å½“å‰å±äºå“ªç§çŠ¶æ€ï¼Œæœ‰å“ªäº›è¡Œä¸ºã€‚å¦‚æœå†åŠ ä¸Šå¤šçº¿ç¨‹ï¼Œé‚£å°±æ›´éš¾æ¨ç†ä»£ç çš„è¡Œä¸ºäº†ã€‚

*** å¤šæ€æ˜¯å¥½ä¸œè¥¿

OOçš„å¤šæ€çš„æ¦‚å¿µå€’æ˜¯æœ‰è¶£çš„å¥½ä¸œè¥¿ã€‚ä¸€ä¸ªå‡½æ•°åœ¨ä¸åŒç±»å‹çš„å‚æ•°èƒ½æœ‰ä¸åŒçš„è¡Œä¸ºï¼Œä½¿å¾—æˆ‘ä»¬çš„èƒ½å¤Ÿæ›´çµæ´»çš„å»ºç«‹æŠ½è±¡ã€‚
*** å¤šçº¿ç¨‹æ˜¯å¥½ä¸œè¥¿å¦‚æœç”¨çš„å¯¹

- Immutablility å‡å°‘äº†å¾ˆå¤šå¤šçº¿ç¨‹å¸¦æ¥çš„é—®é¢˜
- åŠ é”åªä¼šé˜»å¡å¹¶ä½¿äº‹æƒ…æ›´å¤æ‚ï¼ŒClojureç”¨æ›´å¦™çš„æ–¹å¼è§£å†³èµ„æºå…±äº«é—®é¢˜ã€‚
  
** TODO æ­å»ºç¯å¢ƒ

é¦–å…ˆå¾—æœ‰ä¸€ä¸ªç®¡ç†ä¾èµ–çš„ç©æ„ï¼Œå¦‚Rubyçš„bundlerï¼Œpythonçš„pipï¼Œjsçš„npmã€‚clojureç”¨leiningenã€‚

å¦‚æœä½ ç”¨macï¼Œç®€å•çš„ç”¨brewå®‰è£…leiningen

#+BEGIN_SRC bash :eval no
  brew install leiningen
#+END_SRC

clojureçš„ç¼–è¾‘å™¨æˆ‘æ¨èä½¿ç”¨emacsï¼Œå¦‚æœä½ è§‰å¾—emacså­¦ä¹ æ›²çº¿å¤ªé™¡å³­ï¼Œé‚£ä¹ˆ[[http://lighttable.com/][light table]]æ˜¯ä¸ªä¸é”™çš„é€‰æ‹©ã€‚


** æ¥è¯•è¯•ä¸ä¸€æ ·çš„Clojureæ•°æ®ç»“æ„

*** Number
Cojureæ”¯æŒå…¨é¢çš„æ•°å­—ç±»å‹ï¼Œç”šè‡³åŒ…æ‹¬åˆ†æ•°ã€‚
#+BEGIN_SRC clojure
1/2
#+END_SRC

#+RESULTS:
: => 1/2

*** String

å­—ç¬¦ä¸²åªèƒ½ç”¨åŒå¼•å·å®šä¹‰å“¦ï¼Œå­—ç¬¦ä¸²çš„è¿æ¥ä¸å†æ˜¯åŠ å·ï¼Œè€Œæ˜¯str

#+BEGIN_SRC clojure
(str "What's your name? " "I'm fine! " "thank you! " "and you?")
#+END_SRC

#+RESULTS:
: => "What's your name? I'm fine! thank you! and you?"

*** Vector

å‘é‡æ˜¯indexedçš„é›†åˆï¼Œç”¨æ–¹æ‹¬å·åˆå§‹åŒ–
#+BEGIN_SRC clojure
  [1 2 3 4]
  (vector 1 2 3 4)
#+END_SRC

#+RESULTS:
: => [1 2 3 4]

ç”±äºåŠ¨æ€ç±»å‹ï¼Œè¿˜æ”¯æŒå‘é‡å†…çš„å…ƒç´ å¯ä»¥æ˜¯ä»»ä½•ç±»å‹
#+BEGIN_SRC clojure
(get [1 "2" {3 "4"}] 2)
#+END_SRC

#+RESULTS:
: => {3 "4"}

*** List

å’Œvectorç±»ä¼¼ï¼Œä½†æ˜¯å´ç¨å¾®ä¸åŒ
#+BEGIN_SRC clojure 
'(1 2 3 4)
(list 1 2 3 4)
#+END_SRC

#+RESULTS:
: => (1 2 3 4)(1 2 3 4)

ä½†æ˜¯å–å…ƒç´ çš„æ—¶å€™å°±å’Œvectoræœ‰æ‰€ä¸åŒäº†
#+BEGIN_SRC clojure
  (nth '(1 2 3 4) 2)
#+END_SRC

#+RESULTS:
: => 3

*** Set
é›†åˆä¹Ÿä¸€æ ·ï¼Œå…ƒç´ ç±»å‹å¯ä»¥éšæ„
#+BEGIN_SRC clojure
#{"1" 2 :3}
(set ["1" 2 :3 :3])
#+END_SRC

#+RESULTS:
: => #{2 "1" :3}

*** Keyword
æ…¢ç€ï¼Œåˆšåˆšçš„ =:3= æ˜¯ä¸ªä»€ä¹ˆç©æ„

æ²¡é”™ï¼Œå¦‚æœä½ ç”¨è¿‡rubyï¼ŒåŸºæœ¬ä¸Šæ—¶ä¸€ä¸ªä¸œè¥¿,ä½†æ˜¯å¯ä»¥æ˜¯ä»»ä½•å­—æ¯ï¼Œæ•°å­—ï¼Œç¬¦å·ï¼Œç”šè‡³åŒ…æ‹¬unicodeï¼Œæ¯”å¦‚emoji

æ²¡æœ‰é”™äº†ï¼Œé‚£ä¹ˆæˆ‘ä»¬å…¶å®æ˜¯å¯ä»¥ç”¨ä¸­æ–‡å’Œå¯çˆ±çš„emojiç¼–ç¨‹çš„ï¼Œè™½ç„¶æœ‰ç‚¹æ€é©¬ç‰¹
#+BEGIN_SRC clojure
:abc
:34
:>_<b
:ä½ å¥½
:ğŸ˜±
#+END_SRC

#+RESULTS:
: => :abc:34:>_<b:ä½ å¥½:ğŸ˜±

*** Map
map éå¸¸ç®€å•ï¼Œå°±åƒå°†é”®å€¼å¯¹å†™åœ¨listé‡Œï¼Œä¸è¿‡éœ€è¦ç”¨èŠ±æ‹¬å·

è·Ÿå…¶ä»–è¯­è¨€ä¸ä¸€æ ·çš„æ˜¯keyå¯ä»¥æ˜¯ä»»ä½•ä¸œè¥¿ï¼Œç”šè‡³æ˜¯listéƒ½å¯ä»¥ä½œä¸ºkey
#+BEGIN_SRC clojure
{:smile ğŸ˜€}
(get-in {:first-name "NiMa" :last-name "Wang" :å±æ€§ {:é¢œå€¼ 0 :åæ§½èƒ½é‡ 100 }} [:å±æ€§ :é¢œå€¼])

#+END_SRC

#+RESULTS:
: => 0

=get-in= é€šè¿‡ä¸€ä¸ªpathæ•°ç»„æ¥æ‰¾åˆ°æ·±åº¦çš„æŸä¸ªå€¼ã€‚
*** lispä¸“ç”¨çš„ ' å¼•å·
å¦‚æœä½ è§‰å¾—å‰é¢è¿™äº›å…¶å®å…¶ä»–è¯­è¨€éƒ½æœ‰çš„è¯ï¼Œé‚£ä¹ˆä½ å¯èƒ½æ²¡æœ‰æ³¨æ„åˆ°åœ¨ä»‹ç»listæ—¶æœ‰è¿™æ ·ä¸€ä¸ªä¸èµ·çœ¼çš„ç©æ„ 'ã€‚

è¿™æ˜¯ä»€ä¹ˆå•Šï¼Ÿå…·ä½“æ˜¯ä»€ä¹ˆå¯èƒ½éœ€è¦ä¸“é—¨çš„ç¯‡å¹…æ¥ä»‹ç»ï¼Œä½†æ˜¯è¿™é‡Œæˆ‘å¯ä»¥è§£é‡Šå®ƒå¤§æ¦‚æ˜¯ç¥é©¬ã€‚

å¦‚æœåœ¨lispé‡Œé¢è§åˆ°å•å¼•å·ï¼Œé‚£ä¹ˆä½ å®Œå…¨å¯ä»¥ç†è§£æˆliterallyåé¢é‚£ä¸ªä¸œè¥¿ï¼Œä»€ä¹ˆæ„æ€å‘¢ã€‚

#+BEGIN_SRC clojure
  (let [ç”·ç¥ '(ç‹å°¼ç› ç‹å¤§é”¤ å¼ å…¨è›‹) å¥³ç¥ '(å­”è¿é¡º)]
    (first ç”·ç¥);=> ç‹å°¼ç›
    (first å¥³ç¥);=> å­”è¿é¡º
    (first ['ç”·ç¥ 'å¥³ç¥]);=>ç”·ç¥
    )
                                          
#+END_SRC
å¯ä»¥çœ‹åˆ° =ç”·ç¥= =å¥³ç¥= éƒ½æ˜¯listï¼Œä½†æ˜¯å¦‚æœåœ¨ä»–ä»¬å‰é¢åŠ ä¸ªå•å¼•å·åï¼Œä»–ä»¬å°±å˜æˆäº†å­—é¢çš„å€¼ï¼Œä»–ä»¬ç¬¦å·æœ¬èº«ï¼Œè€Œä¸ä¼šè¢«evalæˆä¸€ä¸ªlistã€‚

æ‰€ä»¥ç”±äºlispé‡Œé¢æ‰€æœ‰çš„ =()= æ‹¬å·éƒ½æ˜¯listï¼Œä½†æ˜¯ä»–ä»¬æ˜¯ä¼šè¢«evalçš„listï¼Œä»–ä»¬çš„ä¼šè¿”å›evalåçš„å€¼ï¼Œä½†æ˜¯å¦‚æœåœ¨å‰é¢åŠ ä¸Šå•å¼•å·ï¼Œä»–ä»¬è¿”å›ä»–ä»¬æœ¬èº«ï¼Œlistï¼Œä¸ä¼šè¢«evalã€‚
*** åå¼•å· =`=
** Special Forms
*** def
=def= åˆ›å»ºä¸€ä¸ªå…¨å±€çš„ç»‘å®š
#+BEGIN_SRC clojure
(def a-symbol 'init)
#+END_SRC

#+RESULTS:
: => #'user/a-symbol

ä¸ç®¡æ˜¯åœ¨å“ªé‡Œ(ç”šè‡³æ˜¯threadé‡Œ)è°ƒç”¨ =def= éƒ½ä¼šåˆ›å»ºæˆå…¨å±€ç»‘å®š
*** let
letå…³é”®å­—éå¸¸æœ‰æ„æ€ï¼Œåœ¨å…¶ä»–è¯­è¨€å¦‚jsé‡Œè™½ç„¶æ²¡æœ‰è¿™ä¸ªå…³é”®å­—ï¼Œä½†æ˜¯åŠŸèƒ½å¤§è‡´å¯ä»¥ç¿»è¯‘æˆ
#+BEGIN_SRC js
  (function(ç”·ç¥,å¥³ç¥){
    ç”·ç¥[0]
    å¥³ç¥[0]
  }).call(this, ['ç‹å°¼ç›','ç‹å¤§é”¤','å¼ å…¨è›‹'],['å­”è¿é¡º'])
#+END_SRC

ä½†æ˜¯jsé‡Œé¢å¾ˆå°‘è¿™ä¹ˆå¹²ï¼Œä¸æ˜¯ä¹ˆã€‚æˆ‘ä»¬é€šå¸¸ä¼šç›´æ¥ã€‚
#+BEGIN_SRC js
var ç”·ç¥=['ç‹å°¼ç›','ç‹å¤§é”¤','å¼ å…¨è›‹'],å¥³ç¥=['å­”è¿é¡º'];
ç”·ç¥[0];
å¥³ç¥[0];
#+END_SRC

ç”¨ =var= æœ‰ä»€ä¹ˆåŒºåˆ«ã€‚å½“ç„¶å°±æ˜¯scopeä¸ä¸€æ ·ï¼Œå‰ä¾‹ä¸­å‡½æ•°å†…éƒ¨çš„ =ç”·ç¥= =å¥³ç¥= ä¸¤ä¸ªå€¼çš„ç»‘å®šä¸ä¼šå—åˆ°å‡½æ•°å¤–çš„å½±å“ï¼ŒåŒæ ·ä¹Ÿä¸ä¼šå¯¹å¤–ç•Œé€ æˆä»»ä½•å½±å“ã€‚

æ¯”å¦‚
#+BEGIN_SRC js
  var ç”·ç¥='è‘«èŠ¦å¨ƒ';
    (function(ç”·ç¥,å¥³ç¥){
      ç”·ç¥[0]; //=> ç‹å°¼ç›
    }).call(this, ['ç‹å°¼ç›','ç‹å¤§é”¤','å¼ å…¨è›‹'],['å­”è¿é¡º'])
  ç”·ç¥; //=> è‘«èŠ¦å¨ƒ
#+END_SRC

æ‰€ä»¥ =let= ç†è§£æˆä¸€ä¸ªå‡½æ•°, bindingå…¶å®å°±æ˜¯å‚æ•°
*** do
clojureæ²¡æœ‰statement, å…¨æ˜¯è¡¨è¾¾å¼, æœ‰äº†do, å¯ä»¥åƒstatementä¸€æ ·æŒ‰é¡ºåº eval è¡¨è¾¾å¼, è¿”å›æœ€åä¸€ä¸ª.

*** loop recur
clojureçš„æ•°æ®ç»“æ„éƒ½æ˜¯immutableçš„ï¼Œæ„å‘³ç€ä½ ï¼ˆå¦‚æœä¸ç”¨macroçš„è¯ï¼‰ä¸èƒ½åƒå…¶ä»–è¯­è¨€ä¸€æ ·å†™forå¾ªç¯ï¼Œä¹Ÿä¸èƒ½åƒå…¶ä»–è¯­è¨€è¿™æ ·è¿™æ ·çš„...
#+BEGIN_SRC js
  var ç”·ç¥=['ç‹å°¼ç›','ç‹å¤§é”¤','å¼ å…¨è›‹']
  ç”·ç¥[0]='è‘«èŠ¦å¨ƒ'
  ç”·ç¥ // => ['è‘«èŠ¦å¨ƒ','ç‹å¤§é”¤','å¼ å…¨è›‹']
#+END_SRC

åä¸€ç§å¥½è§£å†³ï¼Œå¤§ä¸äº†åˆ›å»ºä¸€ä¸ªæ–°çš„ =ç”·ç¥= ä½†æ˜¯forå¾ªç¯æ€ä¹ˆæï¼Ÿæˆ‘åˆä¸èƒ½æ”¹å˜ä¸€ä¸ªå€¼.
#+BEGIN_SRC js
  var sum=0;
  for(var i=0; i<10;i++)
    sum+=i
#+END_SRC

åœ¨å‡½æ•°å¼è¯­è¨€ä¸­ï¼Œå¾ªç¯å’Œéå†éƒ½å¿…é¡»è¦é€šè¿‡é€’å½’æ¥å®ç°å‘¢ã€‚ä¹Ÿå°±æ˜¯æˆ‘ä¸èƒ½æ”¹å˜å€¼,ä½†æ˜¯æˆ‘èƒ½åˆ©ç”¨å‡½æ•°é€’å½’è°ƒç”¨é‡æ–°ç»‘å®šå‚æ•°

è€Œåœ¨clojureä¸­ï¼Œå†™ä¸€ä¸ªé€’å½’æ˜¯å¦‚æ­¤çš„ç®€å•ã€‚
#+BEGIN_SRC clojure
  (do
    (defn sum-to-10 [sum i]
      (if (> i 10) 
        sum
        (recur (+ sum i) (inc i))))
    (sum-to-10 0 0))
#+END_SRC

#+RESULTS:
: => 55

è¿˜æœ‰æ›´ç®€å•çš„, ä¸éœ€è¦å®šä¹‰å‡½æ•°çš„é€’å½’, æ›´åƒforå¾ªç¯
#+BEGIN_SRC clojure
  (loop [sum 0 i 0]
    (if (> i 10)
      sum
      (recur (+ sum i) (inc i))))
#+END_SRC

#+RESULTS:
: => 55

recuræ€»æ˜¯ä¼šé€’å½’åˆ°ç¦»å®ƒæœ€è¿‘çš„ =loop= æˆ–è€…å‡½æ•°

å®Œå…¨å¯ä»¥å§ =loop= ç†è§£æˆé€’å½’ç‰ˆæœ¬çš„ =let= å‡½æ•°, ç”¨èµ·æ¥è·Ÿ =let= ä¸€æ¨¡ä¸€æ ·

** code? data?
list æ˜¯æ•°æ®, ä½†æ˜¯ä»–æ˜¯å¯ä»¥evalçš„æ•°æ®, evalçš„è¿‡ç¨‹ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ å°±å˜æˆäº†å‡½æ•°, å•Šå“ˆå“ˆå“ˆ, ç”šè‡³æ˜¯åŠ å‡ä¹˜é™¤. æ¯”å¦‚ =(+ 1 2)=,  ä½ å¯èƒ½è§‰å¾—è¯»ç€åˆ«æ‰­. ä½†æ˜¯å¦‚æœ
#+BEGIN_SRC clojure
(+ 1 2 3 4 5)
#+END_SRC

æ‰€ä»¥listæ˜¯å¯ä»¥æ‰§è¡Œçš„, list ä¹Ÿæ˜¯ä»£ç , å› æ­¤ lisp å«åš list processing è¯­è¨€.

å› æ­¤åœ¨ lisp è¯­è¨€é‡Œ, æ•°æ®å³ä»£ç , ä»£ç ä¹Ÿå³æ•°æ®. è€Œè¿™æ ·çš„ list ä¹Ÿå°±æ˜¯è‘—åçš„ s-expression

æ˜¯ä¸æ˜¯æ„Ÿè§‰åˆ°å¤´æ™•äº†, æ¥çœ‹çœ‹ clojure åˆ°åº•æ˜¯æ€ä¹ˆåšåˆ°çš„.

1. expand macro
2. eval list ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ 
3. ç”¨ç¬¬ä¸€ä¸ªå…ƒç´ ä½œä¸ºå‡½æ•°, åè¾¹æ‰€æœ‰å…ƒç´ ä½œä¸ºå‚æ•°
   #+BEGIN_SRC clojure
     ((or nil +) 1 2 (+ 3 4))
     ; => (+ 1 2 7)
   #+END_SRC

   #+RESULTS:
   : => 10
 
ç¬¬ä¸€éƒ¨ expand macro æˆ‘ä»¬åˆ°åé¢macroçš„æ—¶å€™è®¨è®º

*** Reader
è¿˜è®°å¾—æ­å»ºç¯å¢ƒæ˜¯æåˆ°çš„ REPL å—? ä¹Ÿå°±æ˜¯ Read Eval Print Loop

æ­£å¸¸çš„Clojureç¨‹åºçš„è¿è¡Œåªç»è¿‡å‰ä¸¤ä¸ªæ­¥éª¤, Read å’Œ Eval. å› æ­¤æˆ‘ä»¬å¯ä»¥ç†è§£
1. æœ‰ä¸€ä¸ªReaderå»è¯»å–list
2. ç”Ÿæˆå¯¹åº”çš„clojureæ•°æ®ç»“æ„
3. æ‰”ç»™Evaluator
4. Evaluatorå¯¹å…¶æ±‚å€¼

Readerçš„å·¥ä½œæœ‰äº›åƒJavaScriptçš„ =JSON.parse=, è¯»å–json, è½¬æ¢æˆJavaScriptå¯¹è±¡.
*** Macro
æœ‰äº†Reader, åœ¨evalä¹‹å‰clojureè¿˜å¯ä»¥å†ä½œä¸€äº›å·¥ä½œ -- macro

macro å¯ä»¥æ‰©å±•ä¸€ä¸ª form æˆå¦ä¸€ç§ form, æ¯”å¦‚ =when= macro

#+BEGIN_SRC clojure
(macroexpand '(when (> 1 2) (println "you suck")))
#+END_SRC

#+RESULTS:
: => (if (> 1 2) (do (println "you suck")))

* TODO Functional Programming
* TODO Collection

* TODO Concurrency

* TODO å¤šæ€
