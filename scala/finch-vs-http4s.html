<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-08-28 Sun 14:10 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Finch vs Http4s, which is FPer</title>
<meta name="author" content="Jichao Ouyang" />
<meta name="description" content="This is purely personal overall comparation from Functional Programming point of view, which only consider composible, extensible, and joy of FP. Performance and eco system are out of the scope." />
<meta name="generator" content="Org Mode" />
<link rel="icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/toc.css"/>
<link rel="stylesheet" href="/style/tufte.css"/>
<link rel="stylesheet" href="/style/main.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="https://feeds.oyanglul.us/JichaoOuyangsBlog"/>
</head>
<body>
<div id="preamble" class="status">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJRFJGX"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<header>
    <a accesskey="h" href="/index.html"> HOME </a> |
    <a href="#" id="edit-in-github">EDIT</a> |
    <a href="https://feeds.oyanglul.us/JichaoOuyangsBlog">RSS</a> |
    <a href="https://blog.oyanglul.us/theindex">INDEX</a> |
    <a accesskey="H" href="/jichao.ouyang.html">ABOUT</a> |
    <a href="https://github.com/jcouyang/blog">GITHUB</a>
</header>
</div>
<div id="content" class="content">
<header>
<h1 class="title">Finch vs Http4s, which is FPer</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgffa5625">Finch</a>
<ul>
<li><a href="#orgb357125">composible: ğŸ ğŸ ğŸ ğŸ</a></li>
<li><a href="#orga059b0d">extensible: ğŸ ğŸ</a></li>
<li><a href="#org3c18ac0">joy of FP: ğŸ ğŸ ğŸ</a></li>
</ul>
</li>
<li><a href="#orgd4e776b">Http4s</a>
<ul>
<li><a href="#orgdda0a4a">composible: ğŸ ğŸ ğŸ ğŸ ğŸ</a></li>
<li><a href="#org64928b2">extensible: ğŸ ğŸ ğŸ ğŸ ğŸ</a></li>
<li><a href="#orgd013416">joy of FP: ğŸ ğŸ ğŸ ğŸ ğŸ</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<p>
This is purely personal overall comparation from Functional Programming point of view, which only
consider composible, extensible, and joy of FP. Performance and eco system are out of the scope.
</p>

<p>
The explicit version that I'm comparing here is finch 0.26.1 and Http4s 0.20-M4
</p>

<p>
Definition:
</p>

<ul class="org-ul">
<li><i>composible</i>: how easy to build blocks from existing components</li>
<li><i>extensible</i>: how easy to add support for new type</li>
<li><i>joy of FP</i>: how many FP knowledges are actually practiced</li>
</ul>

<p>
Scale from 1 to 5:
</p>

<div id="outline-container-orgffa5625" class="outline-2">
<h2 id="orgffa5625">Finch</h2>
<div class="outline-text-2" id="text-orgffa5625">
</div>
<div id="outline-container-orgb357125" class="outline-3">
<h3 id="orgb357125">composible: ğŸ ğŸ ğŸ ğŸ</h3>
<div class="outline-text-3" id="text-orgb357125">
<p>
finch takes full advantage of shapeless' product and coproduct to routes <b>Matcher</b>
</p>
<pre class="code"><code><span style="color: #81A1C1;">val</span> <span style="font-weight: bold;">getApples</span> <span style="color: #81A1C1;">=</span> get(<span style="color: #D08770;">"apple"</span>) { <span style="color: #81A1C1;">Ok</span>(<span style="color: #D08770;">"&#127822;&#127822;"</span>)} 
<span style="color: #81A1C1;">val</span> <span style="font-weight: bold;">getApple</span> <span style="color: #81A1C1;">=</span> get(<span style="color: #D08770;">"apple"</span> :: path[<span style="color: #81A1C1;">Int</span>]) { (id<span style="color: #81A1C1;">:</span> <span style="color: #81A1C1;">Int</span>) <span style="color: #81A1C1;">=&gt;</span> <span style="color: #81A1C1;">Ok</span>(<span style="color: #D08770;">"&#127822;"</span>)}

<span style="color: #81A1C1;">val</span> <span style="font-weight: bold;">routes</span> <span style="color: #81A1C1;">=</span> getApples :+: getApple
</code></pre>

<p>
<code>::</code> here is a product, means the path will match if there is an <code>"apple"</code> and an Int in the path <code>path[Int]</code>
</p>

<p>
<code>:+:</code> constructs a coproduct, which means either getApples or getApple matched route will match
</p>

<p>
About <b>Middleware</b>, finch need to mix finagle filter to do the job. so it will end up very ugly and inconsistent from the routes above
</p>
<pre class="code"><code><span style="color: #81A1C1;">class</span> <span style="color: #81A1C1;">AuthFilter</span>(<span style="color: #81A1C1;">implicit</span> ttf<span style="color: #81A1C1;">:</span> <span style="color: #81A1C1;">ToTwitterFuture</span>[<span style="color: #81A1C1;">ProgramF</span>]) <span style="color: #81A1C1;">extends</span> <span style="color: #81A1C1;">SimpleFilter</span>[<span style="color: #81A1C1;">Request</span>, <span style="color: #81A1C1;">Response</span>] {
  <span style="color: #81A1C1;">def</span> <span style="font-weight: bold;">apply</span>(req<span style="color: #81A1C1;">:</span> <span style="color: #81A1C1;">Request</span>, service<span style="color: #81A1C1;">:</span> <span style="color: #81A1C1;">Service</span>[<span style="color: #81A1C1;">Request</span>, <span style="color: #81A1C1;">Response</span>])<span style="color: #81A1C1;">:</span> <span style="color: #81A1C1;">Future</span>[<span style="color: #81A1C1;">Response</span>] <span style="color: #81A1C1;">=</span> {
    (req.path, req.headerMap.get(<span style="color: #D08770;">"TOKEN"</span>)) <span style="color: #81A1C1;">match</span> {
      <span style="color: #81A1C1;">case</span> (<span style="color: #D08770;">"/login"</span>, <span style="color: #81A1C1;">_</span>)        <span style="color: #81A1C1;">=&gt;</span> service(req)
      <span style="color: #81A1C1;">case</span> (<span style="font-weight: bold;">url</span>, <span style="color: #81A1C1;">Some</span>(<span style="font-weight: bold;">token</span>)) <span style="color: #81A1C1;">=&gt;</span> ??? <span style="color: #677691;">// </span><span style="color: #677691;">fetch user info and pass to service</span>
</code></pre>

<p>
and then compose filter and service
</p>
<pre class="code"><code><span style="color: #81A1C1;">new</span> <span style="color: #81A1C1;">AuthFilter</span> andThen routes.toServiceAs[<span style="color: #81A1C1;">Application</span>.<span style="color: #81A1C1;">Json</span>]
</code></pre>

<p>
you may have notice that the finangle filter is more lower level verbose code and inconsistent with the previous shapeless DSL.
</p>
</div>
</div>

<div id="outline-container-orga059b0d" class="outline-3">
<h3 id="orga059b0d">extensible: ğŸ ğŸ</h3>
<div class="outline-text-3" id="text-orga059b0d">
<p>
finch has a lot of internal custom types, e.g. the magic happen behind the DSL above:
</p>
<pre class="code"><code><span style="color: #81A1C1;">val</span> <span style="font-weight: bold;">getApples</span> <span style="color: #81A1C1;">=</span> get(<span style="color: #D08770;">"apple"</span>) { <span style="color: #81A1C1;">Ok</span>(<span style="color: #D08770;">"&#127822;&#127822;"</span>)} 
</code></pre>
<p>
is:
</p>

<ol class="org-ol">
<li>string "apple" will implicitly convert into <code>Endpoint[Unit]</code></li>
<li><code>get("apple")</code> will covert <code>Endpoint[Unit]</code> into function <code>Mapper[F, In] =&gt; Endpoint[F, Out]</code></li>
</ol>
<p>
basically just <code>Cont</code>, taking Mapper as parameter and wrapping itself.
</p>
<ol class="org-ol">
<li>Another implicit conversion will take place in <code>Ok("")</code>, from <code>Output[String] =&gt; Mapper[F, String]</code></li>
</ol>

<p>
If you didn't follow, that's fine, because there is so many implicit conversion and internal custom types
took place here.
</p>

<p>
But think about it, because all implicit conversion was well-defined in finch internally
we've restricted to the types they provided.
</p>

<p>
For example my controller will actually return me a <a href="https://typelevel.org/cats/datatypes/freemonad.html">Free Monad</a> i.e. <code>Free[Program, Output[String]]</code>
</p>

<p>
How can I get it to work with the router?
</p>

<pre class="code"><code><span style="color: #81A1C1;">val</span> <span style="font-weight: bold;">getApples</span> <span style="color: #81A1C1;">=</span> get(<span style="color: #D08770;">"apple"</span>) { <span style="color: #81A1C1;">Free</span>[<span style="color: #81A1C1;">Program</span>, <span style="color: #81A1C1;">Output</span>[<span style="color: #81A1C1;">String</span>]].pure(<span style="color: #81A1C1;">Ok</span>(<span style="color: #D08770;">"&#127822;&#127822;"</span>))} 
</code></pre>

<p>
it won't compile because the implicit conversion expecting an <code>Output[_]</code> type
</p>

<p>
actually it only supports <code>IO[_]</code>, <code>Output[_]</code>, <code>Response</code>
</p>

<p>
UPDATE: from <a href="https://github.com/finagle/finch/pull/1045">0.27.0</a> it supports custom converter to convert any user custom type to IO
</p>

<pre class="code"><code><span style="color: #81A1C1;">implicit</span> <span style="color: #81A1C1;">val</span> <span style="font-weight: bold;">conv</span> <span style="color: #81A1C1;">=</span> <span style="color: #81A1C1;">new</span> <span style="color: #81A1C1;">ToEffect</span>[<span style="color: #81A1C1;">Free</span>[<span style="color: #81A1C1;">Program</span>, ?], <span style="color: #81A1C1;">IO</span>] {
<span style="color: #81A1C1;">def</span> <span style="font-weight: bold;">apply</span>[<span style="color: #81A1C1;">A</span>](a<span style="color: #81A1C1;">:</span> <span style="color: #81A1C1;">Free</span>[<span style="color: #81A1C1;">Program</span>, <span style="color: #81A1C1;">A</span>])<span style="color: #81A1C1;">:</span> <span style="color: #81A1C1;">IO</span>[<span style="color: #81A1C1;">A</span>] <span style="color: #81A1C1;">=</span> ???
}
<span style="color: #81A1C1;">val</span> <span style="font-weight: bold;">getApples</span> <span style="color: #81A1C1;">=</span> get(<span style="color: #D08770;">"apple"</span>) { <span style="color: #81A1C1;">Free</span>[<span style="color: #81A1C1;">Program</span>, <span style="color: #81A1C1;">Output</span>[<span style="color: #81A1C1;">String</span>]].pure(<span style="color: #81A1C1;">Ok</span>(<span style="color: #D08770;">"&#127822;&#127822;"</span>))} 
</code></pre>

<p>
But still, it's so many implicits magic happen behind and the journey wasn't so fun.
</p>
</div>
</div>


<div id="outline-container-org3c18ac0" class="outline-3">
<h3 id="org3c18ac0">joy of FP: ğŸ ğŸ ğŸ</h3>
<div class="outline-text-3" id="text-org3c18ac0">
<p>
except some funs from shapeless there aren't actually any cats interop during composition of routes
</p>

<p>
While that could be much more attractive to beginner friendly though, since user don't have to have
any knowledge about cats before using finch.
</p>
</div>
</div>
</div>

<div id="outline-container-orgd4e776b" class="outline-2">
<h2 id="orgd4e776b">Http4s</h2>
<div class="outline-text-2" id="text-orgd4e776b">
</div>
<div id="outline-container-orgdda0a4a" class="outline-3">
<h3 id="orgdda0a4a">composible: ğŸ ğŸ ğŸ ğŸ ğŸ</h3>
<div class="outline-text-3" id="text-orgdda0a4a">
<p>
meanwhile, http4s takes advantage of cats to achieve path <b>Matcher</b>
</p>
<pre class="code"><code><span style="color: #81A1C1;">val</span> <span style="font-weight: bold;">getApples</span> <span style="color: #81A1C1;">=</span> <span style="color: #81A1C1;">HttpRoutes</span>.of[<span style="color: #81A1C1;">IO</span>] {
  <span style="color: #81A1C1;">case</span> <span style="color: #81A1C1;">GET</span> <span style="color: #81A1C1;">-&gt;</span> <span style="color: #81A1C1;">Root</span> <span style="color: #81A1C1;">/</span> <span style="color: #D08770;">"apple"</span> <span style="color: #81A1C1;">=&gt;</span> <span style="color: #81A1C1;">Ok</span>(<span style="color: #D08770;">"&#127822;&#127822;"</span>)
}
<span style="color: #81A1C1;">val</span> <span style="font-weight: bold;">getApple</span> <span style="color: #81A1C1;">=</span> <span style="color: #81A1C1;">HttpRoutes</span>.of[<span style="color: #81A1C1;">IO</span>] {
  <span style="color: #81A1C1;">case</span> <span style="color: #81A1C1;">GET</span> <span style="color: #81A1C1;">-&gt;</span> <span style="color: #81A1C1;">Root</span> <span style="color: #81A1C1;">/</span> <span style="color: #D08770;">"apple"</span> <span style="color: #81A1C1;">/</span> <span style="color: #81A1C1;">id</span> <span style="color: #81A1C1;">=&gt;</span> <span style="color: #81A1C1;">Ok</span>(<span style="color: #D08770;">"&#127822;"</span>)
}

<span style="color: #81A1C1;">val</span> <span style="font-weight: bold;">routes</span> <span style="color: #81A1C1;">=</span> getApples &lt;+&gt; getApple
</code></pre>

<p>
what happen here is <code>HttpRoutes.of[IO] {...}</code> return a data type <a href="https://typelevel.org/cats/datatypes/kleisli.html"><code>Kleisli{OptionT{F, ?}, Request{F}, F{Response{F}}}</code></a>
</p>

<p>
<code>&lt;+&gt;</code> is <a href="https://typelevel.org/cats/typeclasses/semigroupk.html">combindK</a> of <code>SemigroupK[Kleisli[OptionT[F, ?], Request[F], ?]]</code>
</p>

<p>
You may already realize that nothing of above make any sense to you if you aren't
familiar with data types and typeclasses defined in cats or scalaz.
</p>

<p>
It requires some knowledge background from cats, just like you should know some sort of shapeless to fully understand what the hell is <code>::</code> and <code>:+:</code> about.
</p>

<p>
Short story, <i>Kleisli</i> is a generic data type representing a function <code>A =&gt; F[B]</code>
</p>

<p>
so you could imagine that <code>Kleisli[OptionT[F, ?], Request[F], F[Response[F]]]</code> is just something like
<code>Request[F] =&gt; OptionT[F, F[Response[F]]]</code>
</p>

<p>
while <code>&lt;+&gt;</code> is very like <code>:+:</code>, it combines these Kleisli, but any of these match, it will
return that matched Kleisli
</p>

<p>
About <b>Middleware</b>, it's nothing more just compose a Kleisli of type <code>Kleisli[Option[F,?], Request[F], F[Request[F]]]</code> before
or compose a Kleisli of type <code>Kleisli[Option[F,?], Response[F], F[Response[F]]]</code> after
</p>

<p>
e.g. auth user before <code>getApple</code>
</p>
<pre class="code"><code><span style="color: #81A1C1;">def</span> <span style="font-weight: bold;">auth</span> <span style="color: #81A1C1;">=</span> <span style="color: #81A1C1;">Kleisli</span> { req<span style="color: #81A1C1;">:</span> <span style="color: #81A1C1;">Request</span>[<span style="color: #81A1C1;">IO</span>] <span style="color: #81A1C1;">=&gt;</span>
  findUserInDatabase(req) <span style="color: #81A1C1;">match</span> {
    <span style="color: #81A1C1;">case</span> <span style="color: #81A1C1;">true</span> <span style="color: #81A1C1;">=&gt;</span> <span style="color: #81A1C1;">OptionT</span>(<span style="color: #81A1C1;">IO</span>(<span style="color: #81A1C1;">Some</span>(req)))
    <span style="color: #81A1C1;">case</span> <span style="color: #81A1C1;">false</span> <span style="color: #81A1C1;">=&gt;</span> <span style="color: #81A1C1;">OptionT</span>.fromOption[<span style="color: #81A1C1;">IO</span>](<span style="color: #81A1C1;">None</span>)
  }
}

auth andThen getApple
</code></pre>
</div>
</div>
<div id="outline-container-org64928b2" class="outline-3">
<h3 id="org64928b2">extensible: ğŸ ğŸ ğŸ ğŸ ğŸ</h3>
<div class="outline-text-3" id="text-org64928b2">
<p>
Since route matcher is simply just Kleisli, extending http4s to support types other than <code>F[Response[F]]</code> will
be much simpler.
</p>

<p>
For the same example as above in finch, that my controller will return a free program <code>Free[Program, IO[Response[IO]]]</code> instead of <code>IO[Response[IO]]</code>
</p>

<pre class="code"><code><span style="color: #677691;">// </span><span style="color: #677691;">type alias for route that return free monad</span>
<span style="color: #81A1C1;">type</span> <span style="color: #81A1C1;">FreeRoute</span>[<span style="color: #81A1C1;">F</span>[<span style="color: #81A1C1;">_</span>]] <span style="color: #81A1C1;">=</span>
  <span style="color: #81A1C1;">Kleisli</span>[<span style="color: #81A1C1;">OptionT</span>[<span style="color: #81A1C1;">F</span>, ?], <span style="color: #81A1C1;">Request</span>[<span style="color: #81A1C1;">F</span>], <span style="color: #81A1C1;">ProgramF</span>[<span style="color: #81A1C1;">F</span>[<span style="color: #81A1C1;">Response</span>[<span style="color: #81A1C1;">F</span>]]]]

<span style="color: #677691;">// </span><span style="color: #677691;">custom dsl</span>
<span style="color: #81A1C1;">def</span> <span style="font-weight: bold;">route</span>[<span style="color: #81A1C1;">F</span>[<span style="color: #81A1C1;">_</span>]<span style="color: #81A1C1;">:</span> <span style="color: #81A1C1;">Monad</span>](
  pf<span style="color: #81A1C1;">:</span> <span style="color: #81A1C1;">PartialFunction</span>[<span style="color: #81A1C1;">Request</span>[<span style="color: #81A1C1;">F</span>], <span style="color: #81A1C1;">ProgramF</span>[<span style="color: #81A1C1;">F</span>[<span style="color: #81A1C1;">Response</span>[<span style="color: #81A1C1;">F</span>]]]])<span style="color: #81A1C1;">:</span> <span style="color: #81A1C1;">FreeRoute</span>[<span style="color: #81A1C1;">F</span>] <span style="color: #81A1C1;">=</span>
  <span style="color: #81A1C1;">Kleisli</span>(
    (req<span style="color: #81A1C1;">:</span> <span style="color: #81A1C1;">Request</span>[<span style="color: #81A1C1;">F</span>]) <span style="color: #81A1C1;">=&gt;</span> <span style="color: #81A1C1;">OptionT</span>(implicitly[<span style="color: #81A1C1;">Monad</span>[<span style="color: #81A1C1;">F</span>]].pure(pf.lift(req))))

<span style="color: #81A1C1;">val</span> <span style="font-weight: bold;">getApples</span> <span style="color: #81A1C1;">=</span> route {
  <span style="color: #81A1C1;">case</span> <span style="color: #81A1C1;">GET</span> <span style="color: #81A1C1;">-&gt;</span> <span style="color: #81A1C1;">Root</span> <span style="color: #81A1C1;">/</span> <span style="color: #D08770;">"apple"</span> <span style="color: #81A1C1;">=&gt;</span> <span style="color: #81A1C1;">Ok</span>(<span style="color: #D08770;">"&#127822;&#127822;"</span>).pure[<span style="color: #81A1C1;">Free</span>[<span style="color: #81A1C1;">Program</span>,?]]
}
</code></pre>

<p>
since getApples is still Kleisli, all the methods such as <code>&lt;+&gt;</code> are still available
</p>

<p>
to hook it back to http4s route, simply map interpreter to <code>getApples</code>
</p>

<pre class="code"><code><span style="color: #81A1C1;">val</span> <span style="font-weight: bold;">interp</span><span style="color: #81A1C1;">:</span> <span style="color: #81A1C1;">Program</span> ~&gt; <span style="color: #81A1C1;">IO</span> <span style="color: #81A1C1;">=</span> ???

<span style="color: #81A1C1;">val</span> <span style="font-weight: bold;">router</span> <span style="color: #81A1C1;">=</span> getApples flatMapF interp
</code></pre>

<p>
here I used flatMapF because interp will give it another <code>IO</code>, which need to be flatten
</p>
</div>
</div>


<div id="outline-container-orgd013416" class="outline-3">
<h3 id="orgd013416">joy of FP: ğŸ ğŸ ğŸ ğŸ ğŸ</h3>
<div class="outline-text-3" id="text-orgd013416">
<p>
Since Http4s takes full power of data type Kleisli, since Kleisli at the end is just a function, it's much more composable and extensible in every way.
</p>

<p>
Once you have some knowledge around cats data types and typeclasses, you'll be able to enable all cats power in http4s for free. Since Kleisli has instances
for:
</p>
<ul class="org-ul">
<li>Functor</li>
<li>Applicative</li>
<li>Monad</li>
<li>Alternative</li>
<li>Choice</li>
<li>Arrow</li>
<li>Parallel</li>
<li>Monoid</li>
<li>MonoidK</li>
</ul>
<p>
&#x2026;
</p>


<figure id="org7ab1602">
<img src="https://cdn.rawgit.com/tpolecat/cats-infographic/master/cats.svg" alt="cats.svg" class="org-svg">

</figure>

<p>
As you can see it already cover most of the cats typeclasses, plus, those typeclasses are almost the most popular typeclasses in FP and cats. 
</p>

<p>
And you will get all the chance to practiceall thee fun in your http4s server
by just using Kleisli data type.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<footer>
  <p>Author: Jichao Ouyang
    <a class="github-button" href="https://github.com/sponsors/jcouyang" data-icon="octicon-heart" aria-label="Sponsor @jcouyang on GitHub">Sponsor</a>
    <a aria-label="Follow @jcouyang on GitHub" data-count-aria-label="# followers on GitHub" data-count-api="/users/jcouyang#followers" data-count-href="/jcouyang/followers" href="https://github.com/jcouyang" class="github-button">Follow</a>
    <a href="https://twitter.com/oyanglulu" class="twitter-follow-button" data-show-screen-name="false" data-show-count="false">Follow @oyanglulu</a>
  </p>
  <p>Created: 2018-12-11 Tue 00:00</p>
  <p>Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 28.1 (<a href="https://orgmode.org">Org</a> mode 9.5.3) &#215; <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.
  <input type="swiftype" class="st-default-search-input" placeholder="Search"/>
  <a class="gumroad-button" href="https://gum.co/grokking-monad?wanted=true" target="_blank" data-gumroad-single-product="true">èŒƒç•´è®ºè£…é€¼æŒ‡å—ï¼Œè¯·è‡ªè§‰æ’é˜Ÿè£…é€¼</a>
  <div id="danmaku-comments"></div>
  <div id="disqus_thread"></div>
</footer>
</div>
</body>
</html>
