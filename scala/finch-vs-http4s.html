<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2020-03-06 Fri 12:33 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Finch vs Http4s, which is FPer</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Jichao Ouyang">
<meta name="description" content="This is purely personal overall comparation from Functional Programming point of view, which only consider composible, extensible, and joy of FP. Performance and eco system are out of the scope."
>
<link rel="icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/toc.css"/>
<link rel="stylesheet" href="/style/tufte.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="https://feeds.oyanglul.us/JichaoOuyangsBlog"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJRFJGX"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<header>
    <a accesskey="h" href="/index.html"> HOME </a> |
    <a href="#" id="edit-in-github">EDIT</a> |
    <a href="https://feeds.oyanglul.us/JichaoOuyangsBlog">RSS</a> |
    <a href="https://blog.oyanglul.us/theindex">INDEX</a> |
    <a accesskey="H" href="/jichao.ouyang.html">ABOUT</a> |
    <a href="https://github.com/jcouyang/blog">GITHUB</a>
</header>
</div>
<div id="content">
<header>
<h1 class="title">Finch vs Http4s, which is FPer</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org83e386a">Finch</a>
<ul>
<li><a href="#org89968a1">composible: 🍎 🍎 🍎 🍎</a></li>
<li><a href="#org84c5042">extensible: 🍎 🍎</a></li>
<li><a href="#org7e47757">joy of FP: 🍎 🍎 🍎</a></li>
</ul>
</li>
<li><a href="#org094b4e8">Http4s</a>
<ul>
<li><a href="#orgb100e6b">composible: 🍎 🍎 🍎 🍎 🍎</a></li>
<li><a href="#org35b3700">extensible: 🍎 🍎 🍎 🍎 🍎</a></li>
<li><a href="#org1e61e52">joy of FP: 🍎 🍎 🍎 🍎 🍎</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<p>
This is purely personal overall comparation from Functional Programming point of view, which only
consider composible, extensible, and joy of FP. Performance and eco system are out of the scope.
</p>

<p>
The explicit version that I'm comparing here is finch 0.26.1 and Http4s 0.20-M4
</p>

<p>
Definition:
</p>

<ul class="org-ul">
<li><i>composible</i>: how easy to build blocks from existing components</li>
<li><i>extensible</i>: how easy to add support for new type</li>
<li><i>joy of FP</i>: how many FP knowledges are actually practiced</li>
</ul>

<p>
Scale from 1 to 5:
</p>

<div id="outline-container-org83e386a" class="outline-2">
<h2 id="org83e386a">Finch</h2>
<div class="outline-text-2" id="text-org83e386a">
</div>
<div id="outline-container-org89968a1" class="outline-3">
<h3 id="org89968a1">composible: 🍎 🍎 🍎 🍎</h3>
<div class="outline-text-3" id="text-org89968a1">
<p>
finch takes full advantage of shapeless' product and coproduct to routes <b>Matcher</b>
</p>
<pre class="code"><code><span style="color: #00008b;">val</span> <span style="color: #b8860b;">getApples</span> <span style="color: #00008b;">=</span> get(<span style="color: #8b0000;">"apple"</span>) { <span style="color: #6b8e23;">Ok</span>(<span style="color: #8b0000;">"&#127822;&#127822;"</span>)} 
<span style="color: #00008b;">val</span> <span style="color: #b8860b;">getApple</span> <span style="color: #00008b;">=</span> get(<span style="color: #8b0000;">"apple"</span> :: path[<span style="color: #6b8e23;">Int</span>]) { (id<span style="color: #00008b;">:</span> <span style="color: #36648b;">Int</span>) <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">Ok</span>(<span style="color: #8b0000;">"&#127822;"</span>)}

<span style="color: #00008b;">val</span> <span style="color: #b8860b;">routes</span> <span style="color: #00008b;">=</span> getApples :+: getApple
</code></pre>

<p>
<code>::</code> here is a product, means the path will match if there is an <code>"apple"</code> and an Int in the path <code>path[Int]</code>
</p>

<p>
<code>:+:</code> constructs a coproduct, which means either getApples or getApple matched route will match
</p>

<p>
About <b>Middleware</b>, finch need to mix finagle filter to do the job. so it will end up very ugly and inconsistent from the routes above
</p>
<pre class="code"><code><span style="color: #00008b;">class</span> <span style="color: #36648b;">AuthFilter</span>(<span style="color: #228b22;">implicit</span> ttf<span style="color: #00008b;">:</span> <span style="color: #36648b;">ToTwitterFuture</span>[<span style="color: #6b8e23;">ProgramF</span>]) <span style="color: #00008b;">extends</span> <span style="color: #36648b;">SimpleFilter</span>[<span style="color: #6b8e23;">Request</span>, <span style="color: #6b8e23;">Response</span>] {
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">apply</span>(req<span style="color: #00008b;">:</span> <span style="color: #36648b;">Request</span>, service<span style="color: #00008b;">:</span> <span style="color: #36648b;">Service</span>[<span style="color: #6b8e23;">Request</span>, <span style="color: #6b8e23;">Response</span>])<span style="color: #00008b;">:</span> <span style="color: #36648b;">Future</span>[<span style="color: #6b8e23;">Response</span>] <span style="color: #00008b;">=</span> {
    (req.path, req.headerMap.get(<span style="color: #8b0000;">"TOKEN"</span>)) <span style="color: #00008b;">match</span> {
      <span style="color: #00008b;">case</span> (<span style="color: #8b0000;">"/login"</span>, <span style="color: #00008b;">_</span>)        <span style="color: #00008b;">=&gt;</span> service(req)
      <span style="color: #00008b;">case</span> (<span style="color: #b8860b;">url</span>, <span style="color: #36648b;">Some</span>(<span style="color: #b8860b;">token</span>)) <span style="color: #00008b;">=&gt;</span> ??? <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">fetch user info and pass to service</span>
</code></pre>

<p>
and then compose filter and service
</p>
<pre class="code"><code><span style="color: #00008b;">new</span> <span style="color: #36648b;">AuthFilter</span> andThen routes.toServiceAs[<span style="color: #6b8e23;">Application</span>.<span style="color: #6b8e23;">Json</span>]
</code></pre>

<p>
you may have notice that the finangle filter is more lower level verbose code and inconsistent with the previous shapeless DSL.
</p>
</div>
</div>

<div id="outline-container-org84c5042" class="outline-3">
<h3 id="org84c5042">extensible: 🍎 🍎</h3>
<div class="outline-text-3" id="text-org84c5042">
<p>
finch has a lot of internal custom types, e.g. the magic happen behind the DSL above:
</p>
<pre class="code"><code><span style="color: #00008b;">val</span> <span style="color: #b8860b;">getApples</span> <span style="color: #00008b;">=</span> get(<span style="color: #8b0000;">"apple"</span>) { <span style="color: #6b8e23;">Ok</span>(<span style="color: #8b0000;">"&#127822;&#127822;"</span>)} 
</code></pre>
<p>
is:
</p>

<ol class="org-ol">
<li>string "apple" will implicitly convert into <code>Endpoint[Unit]</code></li>
<li><code>get("apple")</code> will covert <code>Endpoint[Unit]</code> into function <code>Mapper[F, In] =&gt; Endpoint[F, Out]</code></li>
</ol>
<p>
basically just <code>Cont</code>, taking Mapper as parameter and wrapping itself.
</p>
<ol class="org-ol">
<li>Another implicit conversion will take place in <code>Ok("")</code>, from <code>Output[String] =&gt; Mapper[F, String]</code></li>
</ol>

<p>
If you didn't follow, that's fine, because there is so many implicit conversion and internal custom types
took place here.
</p>

<p>
But think about it, because all implicit conversion was well-defined in finch internally
we've restricted to the types they provided.
</p>

<p>
For example my controller will actually return me a <a href="https://typelevel.org/cats/datatypes/freemonad.html">Free Monad</a> i.e. <code>Free[Program, Output[String]]</code>
</p>

<p>
How can I get it to work with the router?
</p>

<pre class="code"><code><span style="color: #00008b;">val</span> <span style="color: #b8860b;">getApples</span> <span style="color: #00008b;">=</span> get(<span style="color: #8b0000;">"apple"</span>) { <span style="color: #6b8e23;">Free</span>[<span style="color: #6b8e23;">Program</span>, <span style="color: #6b8e23;">Output</span>[<span style="color: #6b8e23;">String</span>]].pure(<span style="color: #6b8e23;">Ok</span>(<span style="color: #8b0000;">"&#127822;&#127822;"</span>))} 
</code></pre>

<p>
it won't compile because the implicit conversion expecting an <code>Output[_]</code> type
</p>

<p>
actually it only supports <code>IO[_]</code>, <code>Output[_]</code>, <code>Response</code>
</p>

<p>
UPDATE: from <a href="https://github.com/finagle/finch/pull/1045">0.27.0</a> it supports custom converter to convert any user custom type to IO
</p>

<pre class="code"><code><span style="color: #228b22;">implicit</span> <span style="color: #00008b;">val</span> <span style="color: #b8860b;">conv</span> <span style="color: #00008b;">=</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">ToEffect</span>[<span style="color: #6b8e23;">Free</span>[<span style="color: #6b8e23;">Program</span>, ?], <span style="color: #6b8e23;">IO</span>] {
<span style="color: #00008b;">def</span> <span style="color: #6a5acd;">apply</span>[<span style="color: #6b8e23;">A</span>](a<span style="color: #00008b;">:</span> <span style="color: #36648b;">Free</span>[<span style="color: #6b8e23;">Program</span>, <span style="color: #6b8e23;">A</span>])<span style="color: #00008b;">:</span> <span style="color: #36648b;">IO</span>[<span style="color: #6b8e23;">A</span>] <span style="color: #00008b;">=</span> ???
}
<span style="color: #00008b;">val</span> <span style="color: #b8860b;">getApples</span> <span style="color: #00008b;">=</span> get(<span style="color: #8b0000;">"apple"</span>) { <span style="color: #6b8e23;">Free</span>[<span style="color: #6b8e23;">Program</span>, <span style="color: #6b8e23;">Output</span>[<span style="color: #6b8e23;">String</span>]].pure(<span style="color: #6b8e23;">Ok</span>(<span style="color: #8b0000;">"&#127822;&#127822;"</span>))} 
</code></pre>

<p>
But still, it's so many implicits magic happen behind and the journey wasn't so fun.
</p>
</div>
</div>


<div id="outline-container-org7e47757" class="outline-3">
<h3 id="org7e47757">joy of FP: 🍎 🍎 🍎</h3>
<div class="outline-text-3" id="text-org7e47757">
<p>
except some funs from shapeless there aren't actually any cats interop during composition of routes
</p>

<p>
While that could be much more attractive to beginner friendly though, since user don't have to have
any knowledge about cats before using finch.
</p>
</div>
</div>
</div>

<div id="outline-container-org094b4e8" class="outline-2">
<h2 id="org094b4e8">Http4s</h2>
<div class="outline-text-2" id="text-org094b4e8">
</div>
<div id="outline-container-orgb100e6b" class="outline-3">
<h3 id="orgb100e6b">composible: 🍎 🍎 🍎 🍎 🍎</h3>
<div class="outline-text-3" id="text-orgb100e6b">
<p>
meanwhile, http4s takes advantage of cats to achieve path <b>Matcher</b>
</p>
<pre class="code"><code><span style="color: #00008b;">val</span> <span style="color: #b8860b;">getApples</span> <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">HttpRoutes</span>.of[<span style="color: #6b8e23;">IO</span>] {
  <span style="color: #00008b;">case</span> <span style="color: #6b8e23;">GET</span> <span style="color: #36648b;">-&gt;</span> <span style="color: #6b8e23;">Root</span> <span style="color: #36648b;">/</span> <span style="color: #8b0000;">"apple"</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">Ok</span>(<span style="color: #8b0000;">"&#127822;&#127822;"</span>)
}
<span style="color: #00008b;">val</span> <span style="color: #b8860b;">getApple</span> <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">HttpRoutes</span>.of[<span style="color: #6b8e23;">IO</span>] {
  <span style="color: #00008b;">case</span> <span style="color: #6b8e23;">GET</span> <span style="color: #36648b;">-&gt;</span> <span style="color: #6b8e23;">Root</span> <span style="color: #36648b;">/</span> <span style="color: #8b0000;">"apple"</span> <span style="color: #6b8e23;">/</span> <span style="color: #36648b;">id</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">Ok</span>(<span style="color: #8b0000;">"&#127822;"</span>)
}

<span style="color: #00008b;">val</span> <span style="color: #b8860b;">routes</span> <span style="color: #00008b;">=</span> getApples &lt;+&gt; getApple
</code></pre>

<p>
what happen here is <code>HttpRoutes.of[IO] {...}</code> return a data type <a href="https://typelevel.org/cats/datatypes/kleisli.html"><code>Kleisli{OptionT{F, ?}, Request{F}, F{Response{F}}}</code></a>
</p>

<p>
<code>&lt;+&gt;</code> is <a href="https://typelevel.org/cats/typeclasses/semigroupk.html">combindK</a> of <code>SemigroupK[Kleisli[OptionT[F, ?], Request[F], ?]]</code>
</p>

<p>
You may already realize that nothing of above make any sense to you if you aren't
familiar with data types and typeclasses defined in cats or scalaz.
</p>

<p>
It requires some knowledge background from cats, just like you should know some sort of shapeless to fully understand what the hell is <code>::</code> and <code>:+:</code> about.
</p>

<p>
Short story, <i>Kleisli</i> is a generic data type representing a function <code>A =&gt; F[B]</code>
</p>

<p>
so you could imagine that <code>Kleisli[OptionT[F, ?], Request[F], F[Response[F]]]</code> is just something like
<code>Request[F] =&gt; OptionT[F, F[Response[F]]]</code>
</p>

<p>
while <code>&lt;+&gt;</code> is very like <code>:+:</code>, it combines these Kleisli, but any of these match, it will
return that matched Kleisli
</p>

<p>
About <b>Middleware</b>, it's nothing more just compose a Kleisli of type <code>Kleisli[Option[F,?], Request[F], F[Request[F]]]</code> before
or compose a Kleisli of type <code>Kleisli[Option[F,?], Response[F], F[Response[F]]]</code> after
</p>

<p>
e.g. auth user before <code>getApple</code>
</p>
<pre class="code"><code><span style="color: #00008b;">def</span> <span style="color: #6a5acd;">auth</span> <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">Kleisli</span> { req<span style="color: #00008b;">:</span> <span style="color: #36648b;">Request</span>[<span style="color: #6b8e23;">IO</span>] <span style="color: #00008b;">=&gt;</span>
  findUserInDatabase(req) <span style="color: #00008b;">match</span> {
    <span style="color: #00008b;">case</span> <span style="color: #6b8e23;">true</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">OptionT</span>(<span style="color: #6b8e23;">IO</span>(<span style="color: #6b8e23;">Some</span>(req)))
    <span style="color: #00008b;">case</span> <span style="color: #6b8e23;">false</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">OptionT</span>.fromOption[<span style="color: #6b8e23;">IO</span>](<span style="color: #6b8e23;">None</span>)
  }
}

auth andThen getApple
</code></pre>
</div>
</div>
<div id="outline-container-org35b3700" class="outline-3">
<h3 id="org35b3700">extensible: 🍎 🍎 🍎 🍎 🍎</h3>
<div class="outline-text-3" id="text-org35b3700">
<p>
Since route matcher is simply just Kleisli, extending http4s to support types other than <code>F[Response[F]]</code> will
be much simpler.
</p>

<p>
For the same example as above in finch, that my controller will return a free program <code>Free[Program, IO[Response[IO]]]</code> instead of <code>IO[Response[IO]]</code>
</p>

<pre class="code"><code><span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">type alias for route that return free monad</span>
<span style="color: #00008b;">type</span> <span style="color: #6b8e23;">FreeRoute</span>[<span style="color: #6b8e23;">F</span>[<span style="color: #00008b;">_</span>]] <span style="color: #00008b;">=</span>
  <span style="color: #6b8e23;">Kleisli</span>[<span style="color: #6b8e23;">OptionT</span>[<span style="color: #6b8e23;">F</span>, ?], <span style="color: #6b8e23;">Request</span>[<span style="color: #6b8e23;">F</span>], <span style="color: #6b8e23;">ProgramF</span>[<span style="color: #6b8e23;">F</span>[<span style="color: #6b8e23;">Response</span>[<span style="color: #6b8e23;">F</span>]]]]

<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">custom dsl</span>
<span style="color: #00008b;">def</span> <span style="color: #6a5acd;">route</span>[<span style="color: #6b8e23;">F</span>[<span style="color: #00008b;">_</span>]<span style="color: #00008b;">:</span> <span style="color: #36648b;">Monad</span>](
  pf<span style="color: #00008b;">:</span> <span style="color: #36648b;">PartialFunction</span>[<span style="color: #6b8e23;">Request</span>[<span style="color: #6b8e23;">F</span>], <span style="color: #6b8e23;">ProgramF</span>[<span style="color: #6b8e23;">F</span>[<span style="color: #6b8e23;">Response</span>[<span style="color: #6b8e23;">F</span>]]]])<span style="color: #00008b;">:</span> <span style="color: #36648b;">FreeRoute</span>[<span style="color: #6b8e23;">F</span>] <span style="color: #00008b;">=</span>
  <span style="color: #6b8e23;">Kleisli</span>(
    (req<span style="color: #00008b;">:</span> <span style="color: #36648b;">Request</span>[<span style="color: #6b8e23;">F</span>]) <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">OptionT</span>(implicitly[<span style="color: #6b8e23;">Monad</span>[<span style="color: #6b8e23;">F</span>]].pure(pf.lift(req))))

<span style="color: #00008b;">val</span> <span style="color: #b8860b;">getApples</span> <span style="color: #00008b;">=</span> route {
  <span style="color: #00008b;">case</span> <span style="color: #6b8e23;">GET</span> <span style="color: #36648b;">-&gt;</span> <span style="color: #6b8e23;">Root</span> <span style="color: #36648b;">/</span> <span style="color: #8b0000;">"apple"</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">Ok</span>(<span style="color: #8b0000;">"&#127822;&#127822;"</span>).pure[<span style="color: #6b8e23;">Free</span>[<span style="color: #6b8e23;">Program</span>,?]]
}
</code></pre>

<p>
since getApples is still Kleisli, all the methods such as <code>&lt;+&gt;</code> are still available
</p>

<p>
to hook it back to http4s route, simply map interpreter to <code>getApples</code>
</p>

<pre class="code"><code><span style="color: #00008b;">val</span> <span style="color: #b8860b;">interp</span><span style="color: #00008b;">:</span> <span style="color: #36648b;">Program</span> ~&gt; <span style="color: #6b8e23;">IO</span> <span style="color: #00008b;">=</span> ???

<span style="color: #00008b;">val</span> <span style="color: #b8860b;">router</span> <span style="color: #00008b;">=</span> getApples flatMapF interp
</code></pre>

<p>
here I used flatMapF because interp will give it another <code>IO</code>, which need to be flatten
</p>
</div>
</div>


<div id="outline-container-org1e61e52" class="outline-3">
<h3 id="org1e61e52">joy of FP: 🍎 🍎 🍎 🍎 🍎</h3>
<div class="outline-text-3" id="text-org1e61e52">
<p>
Since Http4s takes full power of data type Kleisli, since Kleisli at the end is just a function, it's much more composable and extensible in every way.
</p>

<p>
Once you have some knowledge around cats data types and typeclasses, you'll be able to enable all cats power in http4s for free. Since Kleisli has instances
for:
</p>
<ul class="org-ul">
<li>Functor</li>
<li>Applicative</li>
<li>Monad</li>
<li>Alternative</li>
<li>Choice</li>
<li>Arrow</li>
<li>Parallel</li>
<li>Monoid</li>
<li>MonoidK</li>
</ul>
<p>
&#x2026;
</p>


<figure>
<object type="image/svg+xml" data="https://cdn.rawgit.com/tpolecat/cats-infographic/master/cats.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>

</figure>

<p>
As you can see it already cover most of the cats typeclasses, plus, those typeclasses are almost the most popular typeclasses in FP and cats. 
</p>

<p>
And you will get all the chance to practiceall thee fun in your http4s server
by just using Kleisli data type.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<footer>
  <p>Author: Jichao Ouyang
    <a class="github-button" href="https://github.com/sponsors/jcouyang" data-icon="octicon-heart" aria-label="Sponsor @jcouyang on GitHub">Sponsor</a>
    <a aria-label="Follow @jcouyang on GitHub" data-count-aria-label="# followers on GitHub" data-count-api="/users/jcouyang#followers" data-count-href="/jcouyang/followers" href="https://github.com/jcouyang" class="github-button">Follow</a>
  </p>
  <p>Created: 2018-12-11 Tue 00:00</p>
  <p>Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.2 (<a href="https://orgmode.org">Org</a> mode 9.2.6) &#215; <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.
  <input type="swiftype" class="st-default-search-input" placeholder="Search"/>
  <a class="gumroad-button" href="https://gum.co/grokking-monad?wanted=true" target="_blank" data-gumroad-single-product="true">范畴论装逼指南，请自觉排队装逼</a>
  <div id="danmaku-comments"></div>
  <div id="disqus_thread"></div>
</footer>
</div>
</body>
</html>
