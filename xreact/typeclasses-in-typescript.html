<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2020-03-08 Sun 02:13 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Type Classes in TypeScript</title>
<meta name="generator" content="Org mode">
<meta name="author" content="欧阳继超">
<link rel="icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/toc.css"/>
<link rel="stylesheet" href="/style/tufte.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="https://feeds.oyanglul.us/JichaoOuyangsBlog"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJRFJGX"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<header>
    <a accesskey="h" href="/index.html"> HOME </a> |
    <a href="#" id="edit-in-github">EDIT</a> |
    <a href="https://feeds.oyanglul.us/JichaoOuyangsBlog">RSS</a> |
    <a href="https://blog.oyanglul.us/theindex">INDEX</a> |
    <a accesskey="H" href="/jichao.ouyang.html">ABOUT</a> |
    <a href="https://github.com/jcouyang/blog">GITHUB</a>
</header>
</div>
<div id="content">
<header>
<h1 class="title">Type Classes in TypeScript</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org3d1af7d">Functor</a>
<ul>
<li><a href="#org668ec21">Higher Kind Type</a></li>
<li><a href="#orga64b06e">多态</a></li>
<li><a href="#orge7fe94f">Reflect Metadata</a></li>
</ul>
</li>
<li><a href="#org3b4efd5">Cartesian</a></li>
<li><a href="#org9624c2a">Apply</a></li>
</ul>
</div>
</nav>
<p>
Typeclass 可以想象为函数式编程的一种设计模式, 虽然并没有设计模式这一说. 在 Haskell 是非常烂大街的一个概念.
</p>

<p>
在面向对象中, 我们对数据结构的表示为一个包含数据的 Class, 然后在这个 Class 里定义对数据的操作.
</p>

<p>
但是函数式不是这样的, 数据的定义与其操作的定义是完全分开的.
</p>

<p>
这就导致了 Type Class 的概念, 就像 Class 一样,我们需要给一些特定的操作归类, 按照可操作的类型.
</p>

<p>
例如现在有个数据类型 <code>Xstream</code>
</p>

<pre class="code"><code><span style="color: #00008b;">class</span> Xstream&lt;T&gt; {
  value: T
  constructor(v: T) {
    <span style="color: #6b8e23;">this</span>.value = v
  }
}
</code></pre>

<p>
如果是面向对象, 我们想让它能够被 map, 那么通常会抽象出接口 <code>Mapable</code>
</p>

<pre class="code"><code><span style="color: #00008b;">interface</span> Mapable&lt;A&gt; {
  map&lt;B&gt;(f: (v:A)=&gt;B): Mapable&lt;B&gt;
}
</code></pre>

<p>
然后猥琐的打开  <code>Xstream</code> 来实现 <code>Mapable</code> 的 <code>map</code> 方法.
</p>

<pre class="code"><code><span style="color: #00008b;">class</span> Xstream&lt;T&gt; <span style="color: #00008b;">implements</span> Mapable&lt;T&gt; {
  value: T
  constructor(v: T) {
    <span style="color: #6b8e23;">this</span>.value = v
  }

  map&lt;B&gt;(f: (v: T) =&gt; B): Mapable&lt;B&gt; {
    <span style="color: #00008b;">return</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">Xstream</span>(f(<span style="color: #6b8e23;">this</span>.value))
  }
}
</code></pre>

<p>
那么如果我还想要让这个数据结构能 fold, 就需要再打开一次:
</p>

<pre class="code"><code><span style="color: #00008b;">class</span> Xstream&lt;T&gt; <span style="color: #00008b;">implements</span> Mapable&lt;T&gt;, Foldable&lt;T&gt; {
   ...
  fold&lt;B&gt;(f:(acc:B,v:T)=&gt;B, base:B):B {
    <span style="color: #00008b;">return</span> f(<span style="color: #6b8e23;">this</span>.value, base)
  }
}
</code></pre>

<p>
现在, 面向对象抽象数据结构的坏味道出来了, 对操作的添加是一点也不开放呢.
</p>

<p>
而函数式, 正好相反, 对操作的添加尤其开放.
</p>

<div id="outline-container-org3d1af7d" class="outline-2">
<h2 id="org3d1af7d">Functor</h2>
<div class="outline-text-2" id="text-org3d1af7d">
<p>
函数式中的这个 Mapable 接口就叫做 Functor type class, 
</p>

<p>
函数式不会这样做
</p>
<pre class="code"><code><span style="color: #00008b;">class</span> Xstream&lt;T&gt; <span style="color: #00008b;">implements</span> Mapable&lt;T&gt; {...}
</code></pre>

<p>
相反, 我们需要数据类型作为接口的类型参数
</p>

<pre class="code"><code><span style="color: #00008b;">interface</span> Functor&lt;F&gt; {
  map&lt;A, B&gt;(f: (a: A) =&gt; B, fa: F&lt;A&gt;): F&lt;B&gt;
}
</code></pre>

<p>
然后为 Xstream 实现 map 方法.
</p>
<pre class="code"><code><span style="color: #00008b;">class</span> XstreamFunctor implement Functor&lt;Xstream&lt;any&gt;&gt; {
  map&lt;A, B&gt;(f: (v: A) =&gt; B, fa: Xstream&lt;A&gt;): Xstream&lt;B&gt; {
    <span style="color: #00008b;">return</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">Xstream</span>(f(<span style="color: #6b8e23;">this</span>.value))
  }
}
</code></pre>

<p>
注意: 现在 map 是 <code>Functor&lt;Xstream&lt;any&gt;&gt;</code> 的方法, 而不是 <code>Xstream&lt;any&gt;</code> 自己的方法
</p>

<p>
使用起来就像这样:
</p>

<pre class="code"><code><span style="color: #00008b;">new</span> <span style="color: #36648b;">XstreamFunctor.map</span>((a)=&gt;a+1, <span style="color: #00008b;">new</span> <span style="color: #36648b;">Xstream</span>(1))
</code></pre>
</div>


<div id="outline-container-org668ec21" class="outline-3">
<h3 id="org668ec21">Higher Kind Type</h3>
<div class="outline-text-3" id="text-org668ec21">
<p>
但是问题是, 上面的代码放到 TypeScript 是不编译的. 因为 TypeScript 并没有 Higher Kind Type(HKT)
</p>

<pre class="code"><code><span style="color: #00008b;">interface</span> Functor&lt;F&gt; {
  map&lt;A, B&gt;(f: (a: A) =&gt; B, fa: F&lt;A&gt;): F&lt;B&gt;
}
</code></pre>

<p>
比如这里的 <code>F</code> 就是 HKT, <code>F</code> 不是一个具体类型, <code>F&lt;number&gt;</code> 才是, <code>F</code> 是相对 <code>F&lt;number&gt;</code> 更高阶的类型
</p>

<p>
大概就像高阶函数
</p>

<pre class="code"><code><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">a</span>(<span style="color: #b8860b;">b</span>){
  <span style="color: #00008b;">return</span> <span style="color: #00008b;">function</span>(){
     b + 1
  }
}
</code></pre>

<p>
<code>a</code> 是高阶函数, <code>a(1)</code> 是普通函数.
</p>

<p>
受到 <a href="https://github.com/gcanti/fp-ts">https://github.com/gcanti/fp-ts</a> 的启发, 幸好我们可以在 TypeScript 中模拟 HKT
</p>

<p>
需要一个 <code>_&lt;A&gt;</code> 借口来存放 HKT, 就像一个 类型的字典, 给一个高阶类型和一个类型, 可以给你查到具体类型:
</p>

<pre class="code"><code><span style="color: #00008b;">interface</span> _&lt;A&gt; { }
</code></pre>

<p>
<code>HKT</code> 就是所有高阶类型的 key, 注意到TypeScript 有 string literal type, 所以 key 其实就是 String Literal Type.
</p>

<pre class="code"><code>type HKT = keyof _&lt;any&gt;
</code></pre>

<p>
使用 <code>$&lt;F,A&gt;</code> 可以方便而且美观的查到到一个高阶与低阶类型组成的具体类型:
</p>
<pre class="code"><code>type $&lt;F <span style="color: #00008b;">extends</span> HKT, A&gt; = _&lt;A&gt;[F]
</code></pre>

<p>
欢迎来到 <b>Type Level Programming</b>, 至今为止我们都还没有值的操作, 全部都是类型, 而这些代码都不会编译到 JS 中
</p>

<p>
再试试用这个HKT来实现 Functor
</p>
<pre class="code"><code><span style="color: #00008b;">interface</span> Functor&lt;F <span style="color: #00008b;">extends</span> HKT&gt; {
  map&lt;A, B&gt;(f: (a: A) =&gt; B, fa: $&lt;F, A&gt;): $&lt;F, B&gt;
}
</code></pre>

<p>
现在, 可以试想 Xstream's Functor 实例了
</p>

<ol class="org-ol">
<li><code>Xstream</code> 类型的 key 是 <code>"Xstream"</code></li>
</ol>
<pre class="code"><code><span style="color: #00008b;">interface</span> _&lt;A&gt; {
  <span style="color: #8b0000;">"Xstream"</span>: Xstream&lt;A&gt;
}
</code></pre>

<ol class="org-ol">
<li>虽然 <code>Functor&lt;"Xstream"&gt;</code> 中的 <code>"Xstream"</code> 看起来像是字符串, 但其实它是类型, 而且是类型安全的, 敲错字符会导致编译错误.</li>
</ol>

<pre class="code"><code><span style="color: #00008b;">class</span> XstreamFunctor <span style="color: #00008b;">implements</span> Functor&lt;<span style="color: #8b0000;">"Xstream"</span>&gt; {
  map&lt;A, B&gt;(f: (v: A) =&gt; B, fa: Xstream&lt;A&gt;): Xstream&lt;B&gt; {
    <span style="color: #00008b;">return</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">Xstream</span>(f(fa.value))
  }
}
</code></pre>
</div>
</div>

<div id="outline-container-orga64b06e" class="outline-3">
<h3 id="orga64b06e">多态</h3>
<div class="outline-text-3" id="text-orga64b06e">
<p>
但是, 用起来好难看, 每次用map还要 new 这么个 Functor 出来, 比如
</p>

<pre class="code"><code><span style="color: #00008b;">new</span> <span style="color: #36648b;">XstreamFunctor.map</span>(a=&gt;a+1, <span style="color: #00008b;">new</span> <span style="color: #36648b;">Xstream</span>(1))
</code></pre>

<p>
面向对象的多态如何能找到对应解决方法呢? 比如现在多出来一个类型叫 <code>Ystream</code>.
</p>

<p>
如何实现一个多态的 <code>map</code> 能作用到所有 Functor 的实例上呢?
</p>

<p>
理论上 map 应该是这样的:
</p>

<pre class="code"><code><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">map</span>&lt;F <span style="color: #00008b;">extends</span> FunctorInstance, A, B&gt;(f: (v: A) =&gt; B, fa: $&lt;F, A&gt;): $&lt;F, B&gt; {
  <span style="color: #00008b;">return</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">Functor</span>&lt;F&gt;().map(f, fa)
}
</code></pre>

<p>
但是 TypeScript 的弱弱的类型系统不会帮你找到 <code>Functor&lt;F&gt;</code> 的实例, Typescript 无法通过类型 <code>Functor&lt;"Xstream"&gt;</code> 就能找到
<code>XstreamFunctor</code>. 这种从类型找实例的技能就像 Scala 中 <code>implicit</code> .但是由于TypeScript最终会编译成 JS, 除非编译时有 macro, 不然没办法把类型的计算和信息带到 JS 代码中.
</p>

<p>
解决方法有些麻烦, 类似于类型 <code>_</code> , 我们还需要一个字典, 但是这次是值字典而不是类型字典
</p>
<pre class="code"><code>namespace Functor {
  <span style="color: #00008b;">const</span> <span style="color: #b8860b;">Xstream</span> = <span style="color: #00008b;">new</span> <span style="color: #36648b;">XstreamFunctor</span>
  <span style="color: #00008b;">const</span> <span style="color: #b8860b;">Ystream</span> = <span style="color: #00008b;">new</span> <span style="color: #36648b;">YstreamFunctor</span>
}
</code></pre>

<p>
Functor 字典存放所有 Functor 实例, 以类型名为 key
</p>

<pre class="code"><code>Functor[<span style="color: #8b0000;">'Xstream'</span>].map(a=&gt;a+1, <span style="color: #00008b;">new</span> <span style="color: #36648b;">Xstream</span>(1))
Functor[<span style="color: #8b0000;">'Ystream'</span>].map(a=&gt;a+1, <span style="color: #00008b;">new</span> <span style="color: #36648b;">Ystream</span>(1))
</code></pre>

<p>
用的时候用类型名查找, 但问题是, 类型名是个 String 值, 不是一个类型
</p>

<p>
不管了, 先看看实现 <code>map</code> 还缺些什么
</p>

<pre class="code"><code>type FunctorInstance = keyof <span style="color: #00008b;">typeof</span> Functor
</code></pre>

<p>
<code>FunctorInstance</code> 目前来说是 <code>'Xstream' | 'Ystream'</code>
</p>

<pre class="code"><code><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">map</span>&lt;F <span style="color: #00008b;">extends</span> FunctorInstance, A, B&gt;(f: (v: A) =&gt; B, fa: $&lt;F, A&gt;): $&lt;F, B&gt; {
  <span style="color: #00008b;">return</span> Functor[F].map(f, fa)
}
</code></pre>

<p>
这样还是编译不过的, 正如刚刚说的, <code>F</code> 是类型 <code>Functor[F]</code> 需要的 <code>F</code> 是值.
</p>

<p>
使用 TypeScript 是办不到的, 因为最终 <code>Functor[F]</code> 是会留到 JS 中, 而类型 <code>F</code> 会被丢掉.
</p>

<p>
JS 中没法得到 <code>F</code> 的任何信息.
</p>

<p>
但是反过来想, 不能从类型中拿到值, 那么能不能从值中提取出类型信息呢?
</p>

<p>
例如我们都知道 <code>fa</code> 的 constructor.name 是 <code>'Xstream'</code>
</p>
<pre class="code"><code><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">map</span>&lt;F <span style="color: #00008b;">extends</span> FunctorInstance, A, B&gt;(f: (v: A) =&gt; B, fa: $&lt;F, A&gt;): $&lt;F, B&gt; {
  <span style="color: #00008b;">return</span> Functor[fa.constructor.name as F].map(f, fa)
}
</code></pre>

<p>
马德这还是编译不过
</p>

<p>
因为 <code>Functor[fa.constructor.name as F]</code> 有可能是类型 <code>XstreamFunctor</code> 或 <code>YstreamFunctor</code>, <code>fa</code> 有可能是 <code>Xstream</code> 或 <code>Ystream</code>, 编译器会发现有可能出现 <code>Functor[fa.constructor.name as F]</code> 是 <code>XstreamFunctor</code> 而 <code>fa</code> 是 <code>Ystream</code> 的情况, 那就该编译错误了.
</p>

<p>
但是我们明明知道 <code>Xstream</code> 一定会叨叨 <code>XstreamFunctor</code> 而 <code>Ystream</code> 一定会找到  <code>YStreamFunctor</code>, 只能越过 TypeScript 的萨比检查了.
</p>

<pre class="code"><code><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">map</span>&lt;F <span style="color: #00008b;">extends</span> FunctorInstance, A, B&gt;(f: (v: A) =&gt; B, fa: $&lt;F, A&gt;): $&lt;F, B&gt; {
  <span style="color: #00008b;">return</span> (&lt;any&gt;Functor[fa.constructor.name as F]).map(f, fa) as $&lt;F, B&gt;
}
</code></pre>


<p>
让我试试类型多态的 map
</p>
<pre class="code"><code>map&lt;<span style="color: #8b0000;">"Xstream"</span>, number, number&gt;(a=&gt;a+1, <span style="color: #00008b;">new</span> <span style="color: #36648b;">Xstream</span>(1))
map&lt;<span style="color: #8b0000;">"Ystream"</span>, number, number&gt;(a=&gt;a+1, <span style="color: #00008b;">new</span> <span style="color: #36648b;">Ystream</span>(1))
</code></pre>

<p>
终于工作了
</p>

<p>
但是, 还是有问题. 如果我们 minify 代码, 还是会挂, 因为我们依赖了 constructor name压缩后如何保证 Functor 中的 <code>Xstream</code> 变量和这个构造函数的名会压缩成同样的字母呢?
</p>
</div>
</div>

<div id="outline-container-orge7fe94f" class="outline-3">
<h3 id="orge7fe94f">Reflect Metadata</h3>
<div class="outline-text-3" id="text-orge7fe94f">
<p>
比较妥善的办法是通过 <a href="https://github.com/rbuckton/reflect-metadata">Reflect Metadata</a>, 已经是 ECMA 的一个 proposal 但是不知什么时候会通过, 也不知道现在是stage 几, 反正 TypeScript 在推, Angular 在用, 也有polyfill
</p>

<p>
可以声明俩函数来存头数据和取头数据.
</p>

<ul class="org-ul">
<li><code>datatype</code> 给数据类型打赏类型标签</li>
<li><code>kind</code> 取出来</li>
</ul>

<pre class="code"><code><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">datatype</span>(<span style="color: #b8860b;">name</span>: <span style="color: #b8860b;">string</span>) {
  <span style="color: #00008b;">return</span> (constructor: Function) =&gt; {
    Reflect.defineMetadata(<span style="color: #8b0000;">'design:type'</span>, name, constructor);
  }
}

<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">kind</span>(<span style="color: #b8860b;">target</span>: <span style="color: #b8860b;">any</span>) {
  <span style="color: #00008b;">return</span> Reflect.getMetadata(<span style="color: #8b0000;">'design:type'</span>, target.constructor);
}
</code></pre>

<p>
比如 Tag Xstream
</p>
<pre class="code"><code>datatype(<span style="color: #8b0000;">'Xstream'</span>)(Xstream)
</code></pre>

<p>
或是用 decorator 在声明class时加
</p>
<pre class="code"><code>@datatype(<span style="color: #8b0000;">'Xstream'</span>)
<span style="color: #00008b;">class</span> Xstream&lt;A&gt; {...}
</code></pre>

<p>
这样, 就可在 <code>map</code> 上使用 kind 拿到可靠的 key 了.
</p>
<pre class="code"><code><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">map</span>&lt;F <span style="color: #00008b;">extends</span> FunctorInstance, A, B&gt;(f: (v: A) =&gt; B, fa: $&lt;F, A&gt;): $&lt;F, B&gt; {
  <span style="color: #00008b;">return</span> (&lt;any&gt;Functor[kind(fa) as F]).map(f, fa) as $&lt;F, B&gt;
}
</code></pre>
</div>
</div>
</div>


<div id="outline-container-org3b4efd5" class="outline-2">
<h2 id="org3b4efd5">Cartesian</h2>
<div class="outline-text-2" id="text-org3b4efd5">
<p>
这么久就讲了一个 Type Class, 下面随便讲两个常用的, 体会体会用 TypeClass 的好处吧
</p>

<p>
现在我们再想给 Xstream 加操作, 就完全不需要动以前的代码了.
</p>

<p>
比如加 Cartesian Type Class
</p>

<p>
Cartesian 只有一个函数 <code>product</code>, 可以把两个数据类型合并成一个, 其内部数据合并成 tuple
</p>

<pre class="code"><code>type CartesianInstances = keyof <span style="color: #00008b;">typeof</span> Cartesian

<span style="color: #00008b;">interface</span> Cartesian&lt;F <span style="color: #00008b;">extends</span> HKT&gt; {
  product&lt;A, B&gt;(fa: $&lt;F, A&gt;, fb: $&lt;F, B&gt;): $&lt;F, [A, B]&gt;
}
</code></pre>

<p>
羡慕我们来实现 Xstream  的 Cartesian 实例
</p>
<pre class="code"><code>namespace Cartesian {
  <span style="color: #00008b;">export</span> <span style="color: #00008b;">let</span> <span style="color: #b8860b;">Xstream</span>: Cartesian&lt;<span style="color: #8b0000;">"Xstream"</span>&gt;
}

<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">product</span>&lt;F <span style="color: #00008b;">extends</span> CartesianInstances, A, B&gt;(fa: $&lt;F, A&gt;, fb: $&lt;F, B&gt;): $&lt;F, [A, B]&gt; {
  <span style="color: #00008b;">let</span> <span style="color: #b8860b;">instance</span> = (&lt;any&gt;Cartesian)[kind(fa)]
  <span style="color: #00008b;">return</span> instance.product(fa, fb) as $&lt;F, [A, B]&gt;
}

<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">Cartesian Xstream instance</span>
<span style="color: #00008b;">class</span> XstreamCartesian <span style="color: #00008b;">implements</span> Cartesian&lt;<span style="color: #8b0000;">"Xstream"</span>&gt; {
  product&lt;A, B&gt;(fa: Xstream&lt;A&gt;, fb: Xstream&lt;B&gt;): Xstream&lt;[A, B]&gt; {
    <span style="color: #00008b;">return</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">Xstream</span>([fa.value, fb.value] as [A, B])
  }
}

Cartesian.Xstream = <span style="color: #00008b;">new</span> <span style="color: #36648b;">XstreamCartesian</span>

<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">product of two Xstream</span>
product&lt;<span style="color: #8b0000;">"Xstream"</span>, number, number&gt;(<span style="color: #00008b;">new</span> <span style="color: #36648b;">Xstream</span>(1), <span style="color: #00008b;">new</span> <span style="color: #36648b;">Xstream</span>(2))
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; Xstream([1,2])</span>
</code></pre>

<p>
一个新的能作用在 <code>Xstream</code> 类型上的函数就这么定义好了.
</p>
</div>
</div>

<div id="outline-container-org9624c2a" class="outline-2">
<h2 id="org9624c2a">Apply</h2>
<div class="outline-text-2" id="text-org9624c2a">
<p>
同样还可以扩展 TypeClass, 比如 Apply 就扩展了 Cartesian 和 Functor
</p>

<pre class="code"><code><span style="color: #00008b;">interface</span> Apply&lt;F <span style="color: #00008b;">extends</span> HKT&gt; <span style="color: #00008b;">extends</span> Cartesian&lt;F&gt;, Functor&lt;F&gt; {
  ap&lt;A, B&gt;(fab: $&lt;F, (a: A) =&gt; B&gt;, fa: $&lt;F, A&gt;): $&lt;F, B&gt;
}

type ApplyInstances = keyof <span style="color: #00008b;">typeof</span> Apply

namespace Apply {
  <span style="color: #00008b;">export</span> <span style="color: #00008b;">let</span> <span style="color: #b8860b;">Xstream</span>: Apply&lt;<span style="color: #8b0000;">"Xstream"</span>&gt;
}

<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">ap</span>&lt;F <span style="color: #00008b;">extends</span> ApplyInstances, A, B&gt;(fab: $&lt;F, (a: A) =&gt; B&gt;, fa: $&lt;F, A&gt;): $&lt;F, B&gt; {
  <span style="color: #00008b;">let</span> <span style="color: #b8860b;">instance</span> = (&lt;any&gt;Functor)[kind(fab)]
  <span style="color: #00008b;">return</span> instance.ap(fab, fa) as $&lt;F, B&gt;
}
</code></pre>

<p>
在实现 Xstream 的实例时, 别忘了吧 map 和 product 都 alias到对应 Type Class 的方法上.
</p>

<pre class="code"><code><span style="color: #00008b;">class</span> XstreamApply <span style="color: #00008b;">implements</span> Apply&lt;<span style="color: #8b0000;">"Xstream"</span>&gt; {
  ap&lt;A, B&gt;(fab: Xstream&lt;(a: A) =&gt; B&gt;, fa: Xstream&lt;A&gt;): Xstream&lt;B&gt; {
    <span style="color: #00008b;">return</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">Xstream</span>(fab.value(fa.value))
  }
  map = Functor.Xstream.map
  product = Cartesian.Xstream.product
}
</code></pre>

<p>
如果我们给 TypeClass 上加方法, 所有的实例也立马可以享受到
</p>
<pre class="code"><code><span style="color: #00008b;">export</span> <span style="color: #00008b;">function</span> ap2&lt;F <span style="color: #00008b;">extends</span> ApplyInstances, A, B, C&gt;(fabc: $&lt;F, (a: A, b: B) =&gt; C&gt;, fa: $&lt;F, A&gt;, fb: $&lt;F, B&gt;): $&lt;F, C&gt; {
  <span style="color: #00008b;">let</span> <span style="color: #b8860b;">instance</span>: any = Apply[kind(fabc) as F]
  <span style="color: #00008b;">return</span> instance.ap(
    instance.map(
      (f: (a: A, b: B) =&gt; C) =&gt; (([a, b]: [A, B]) =&gt; f(a, b))
      , fabc)
    , instance.product(fa, fb)
  ) as $&lt;F, C&gt;
}
</code></pre>

<p>
现在 Xstream 自然就可以 <code>ap2</code> 了
</p>
<pre class="code"><code>ap2&lt;<span style="color: #8b0000;">"Xstream"</span>, number, number, number&gt;(
  <span style="color: #00008b;">new</span> <span style="color: #36648b;">Xstream</span>((a: number, b: number) =&gt; a + b),
  <span style="color: #00008b;">new</span> <span style="color: #36648b;">Xstream</span>(2),
  <span style="color: #00008b;">new</span> <span style="color: #36648b;">Xstream</span>(3)
)
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; Xstream(5)</span>
</code></pre>


<p>
<a href="https://github.com/reactive-react/xreact/tree/6ac7c192cfb5186a74e36593c121901cddd2225d/src/fantasy/typeclasses">更多 Type Classes 请看 XREACT 源码&#x2026;</a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<footer>
  <p>Author: 欧阳继超
    <a class="github-button" href="https://github.com/sponsors/jcouyang" data-icon="octicon-heart" aria-label="Sponsor @jcouyang on GitHub">Sponsor</a>
    <a aria-label="Follow @jcouyang on GitHub" data-count-aria-label="# followers on GitHub" data-count-api="/users/jcouyang#followers" data-count-href="/jcouyang/followers" href="https://github.com/jcouyang" class="github-button">Follow</a>
  </p>
  <p>Created: 2017-09-09 Sat 00:00</p>
  <p>Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.3 (<a href="https://orgmode.org">Org</a> mode 9.3.6) &#215; <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.
  <input type="swiftype" class="st-default-search-input" placeholder="Search"/>
  <a class="gumroad-button" href="https://gum.co/grokking-monad?wanted=true" target="_blank" data-gumroad-single-product="true">范畴论装逼指南，请自觉排队装逼</a>
  <div id="danmaku-comments"></div>
  <div id="disqus_thread"></div>
</footer>
</div>
</body>
</html>
