<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2022-09-17 Sat 08:03 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rethinking React Dataflow</title>
<meta name="author" content="unknown" />
<meta name="generator" content="Org Mode" />
<link rel="icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/toc.css"/>
<link rel="stylesheet" href="/style/tufte.css"/>
<link rel="stylesheet" href="/style/main.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="https://feeds.oyanglul.us/JichaoOuyangsBlog"/>
</head>
<body>
<div id="preamble" class="status">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJRFJGX"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<header>
    <a accesskey="h" href="/index.html"> HOME </a> |
    <a href="#" id="edit-in-github">EDIT</a> |
    <a href="https://feeds.oyanglul.us/JichaoOuyangsBlog">RSS</a> |
    <a href="https://blog.oyanglul.us/theindex">INDEX</a> |
    <a accesskey="H" href="/jichao.ouyang.html">ABOUT</a> |
    <a href="https://github.com/jcouyang/blog">GITHUB</a>
</header>
</div>
<div id="content" class="content">
<header>
<h1 class="title">Rethinking React Dataflow</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org2838c74">Reactive</a></li>
<li><a href="#orgb4deb1d">Monadic</a></li>
<li><a href="#orgd6327cf">🌰</a>
<ul>
<li><a href="#orge443e9c">一个简单的 Pure Component</a></li>
<li><a href="#org16a276a">Debounce</a></li>
<li><a href="#org96b5d33">发送 API 请求</a></li>
<li><a href="#org2309d28">继续 flatMap 结果到流上</a></li>
<li><a href="#org80f20da">Model</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<div class="epigraph"><blockquote>
<p>
所谓 redux，就是将动作(action) 变换成 state 转换函数(reducer)，然后放到一个统一的地方(store)来 setState 而已。
</p>

</blockquote></div>

<p>
Redux 现在红的一塌糊涂，写这篇文章并不是专门来踢馆的，因为已经<a href="http://staltz.com/why-react-redux-is-an-inferior-paradigm.html">有人踢过了</a>， <a href="https://www.zhihu.com/question/38591713">过了</a>， <a href="http://blog.dev/javascript/react-transdux-the-clojure-approach-of-flux.html">了</a>。
我用过裸的 React，确实代码 scale 了会很难过，也用过 redux，predictable 不是吹的，但是这不该归功于 redux，而应该是纯函数，一个函数式编程顺带的最基本的好处。所以，撇开 redux 不聊，来看看除了纯函数，让我们来重新思考下函数式的其他一些奇技淫巧如何能帮助我们提升状态的可预测性。
</p>

<div id="outline-container-org2838c74" class="outline-2">
<h2 id="org2838c74">Reactive</h2>
<div class="outline-text-2" id="text-org2838c74">
<p>
相对于命令式的在各个地方 setState，setState 的顺序非常难确定， 就跟可变变量赋值一样，谁先谁后对结果影响巨大。这也是函数式要消灭的赋值。但是话说回来，我特么为什么要去推测状态呢？你永远无法列举完用户交互的操作顺序，即使可以也太头疼了。
</p>

<p>
比起推测整个状态，我们不如只关心数据流的一部分，而后组合这些数据流编程一颗大数据流。跟纯函数一样，只要保证每一个函数都是纯函数，组合出来的函数也是纯函数。
</p>


<figure id="orge629868">
<img src="https://raw.githubusercontent.com/jcouyang/react-most/master/docs/images/flow.dot.png" alt="flow.dot.png">

</figure>

<p>
所以我们把问题分解成一个个数据流，数据流又有可能有更小的数据流组成。数据流接收用户的输入，返回一个从旧状态到新状态的映射。
</p>

<p>
现在，真正 setState 的时序并不重要，也不需要关心，只需要关系数据流的逻辑，爱什么时候 set 什么时候 setState。
</p>
</div>
</div>

<div id="outline-container-orgb4deb1d" class="outline-2">
<h2 id="orgb4deb1d">Monadic</h2>
<div class="outline-text-2" id="text-orgb4deb1d">
<p>
不用纠结于 Monad 到底是什么，只要会用 flatmap 就好。例如 redux 非常头疼的问题，Async Action 怎么办？
</p>

<p>
有了 flatmap，还怕 async 吗？通通 flat 掉。
</p>
</div>
</div>

<div id="outline-container-orgd6327cf" class="outline-2">
<h2 id="orgd6327cf">🌰</h2>
<div class="outline-text-2" id="text-orgd6327cf">
<p>
要不直接看效果，怕是干讲连 flatmap 都讲不明白。
</p>

<div class="org-center">
<p>
例子源码在 👉  <a href="https://github.com/jcouyang/react-most/tree/master/examples/type-n-search">这里</a>
</p>
</div>


<p>
下面，我们来实现一个非常常见但有可能使用其他库实现比较复杂的功能。在输入的同时搜索并将结果更新到页面上。这么一个功能需要完成：
</p>

<ol class="org-ol">
<li>响应用户（键盘输入）事件，</li>
<li>但是又不能每次变动都响应，这样频繁请求会给服务器过大压力。我们设置在 500ms 响应一次。</li>
<li>500ms 后异步的发送到搜索的服务器（假设是 github api）</li>
<li>数据返回后显示对应搜索结果的 repository 名字，作者名字，以及收藏数量。</li>
</ol>

<p>
完成后的效果应该是这样的：
</p>


<figure id="org8f10c5c">
<img src="https://raw.githubusercontent.com/jcouyang/clojure-flavored-javascript/master/book/images/Type_N_Search.png" alt="Type_N_Search.png">

</figure>
</div>

<div id="outline-container-orge443e9c" class="outline-3">
<h3 id="orge443e9c">一个简单的 Pure Component</h3>
<div class="outline-text-3" id="text-orge443e9c">
<p>
使用 React 创建一个 Component
</p>
<pre class="code"><code><span style="color: #81A1C1;">const</span> <span style="font-weight: bold;">TypeNsearch</span> = (props)=&gt;{
    <span style="color: #81A1C1;">let</span> {search} = props.actions
    <span style="color: #81A1C1;">return</span> &lt;div&gt;
        &lt;input onChange={e=&gt;search(e.target.value)}&gt;&lt;/input&gt;
        &lt;ul&gt;
        {
            props.results&amp;&amp;props.results.map(item=&gt;{
                <span style="color: #81A1C1;">return</span> &lt;li key={item.id}&gt;&lt;a href={item.html_url}&gt;{item.full_name} ({item.stargazers_count})&lt;/a&gt;&lt;/li&gt;
            })
        }
        &lt;/ul&gt;
    &lt;/div&gt;
}
</code></pre>

<p>
return 的地方就是 Virtual DOM 了，一个输入框 <code>input</code> ，底下是一堆 <code>li</code> 。当输入框内容发生改变，会调用 <code>search</code> 函数，该函数将输入框的值加入到一个叫 <i>Intent Stream</i> 的流中。
</p>

<p>
好了，关于 React要做的事情我们只需要了解这么多就好了。下面我看看到底怎么 reactive。
</p>
</div>
</div>

<div id="outline-container-org16a276a" class="outline-3">
<h3 id="org16a276a">Debounce</h3>
<div class="outline-text-3" id="text-org16a276a">
<p>
一旦把用户事件的值发送到 Intent Stream，响应事件的工作就算已经做完了。接下来实现第二步， 至少间隔 500ms 才发送 API 请求。这意味着我们可以开始构建数据流了，让数据流中的类型为 <code>search</code> 的值 debounce 500ms 就好。
</p>

<pre class="code"><code><span style="color: #81A1C1;">function</span>(<span style="font-weight: bold;">intent$</span>){
  <span style="color: #81A1C1;">let</span> <span style="font-weight: bold;">updateSink$</span> = intent$.filter(i=&gt;i.type==<span style="color: #D08770;">'search'</span>)
                       .debounce(500)
  ...
</code></pre>

<p>
<code>debounce</code> 会把一个流转换成一个值间的间隔至少在给定时间的流。
</p>
<pre class="code"><code>--&#20919;-&#20919;&#31505;--&#20919;&#31505;&#35805;--&gt;

--------&#20919;&#31505;&#35805;--&gt;
</code></pre>
</div>
</div>

<div id="outline-container-org96b5d33" class="outline-3">
<h3 id="org96b5d33">发送 API 请求</h3>
<div class="outline-text-3" id="text-org96b5d33">
<p>
接下来的事情就简单的，流上的值之间一定是间隔 500ms 以上，我们可以放心的直接通过这些值构造响应的 API 地址并发送请求。
</p>
<pre class="code"><code>...
.map(intent=&gt;intent.value)
.filter(query=&gt;query.length &gt; 0)
.map(query=&gt;GITHUB_SEARCH_API + query)
.map(rest)
...
</code></pre>

<p>
rest 是一个 Isomophic 的 JavaScript Restful 客户端。在拼好地址后可以简单的利用 rest 来发送请求，得到一个 Promise。
</p>
</div>
</div>

<div id="outline-container-org2309d28" class="outline-3">
<h3 id="org2309d28">继续 flatMap 结果到流上</h3>
<div class="outline-text-3" id="text-org2309d28">
<p>
精彩的地方来了，当我们获得一个 Promise 后，如何将 Promise 内的一个异步的结果在作为流输出呢？这时候就可以派上我们的 Monad， monadic 的连接 promise 和 Intent Stream。
</p>

<pre class="code"><code>.flatMap(request=&gt;most.fromPromise(
                         request.then(resp=&gt;({
                           type: <span style="color: #D08770;">'dataUpdate'</span>,
                           value: resp.entity
                         }))))
</code></pre>

<p>
 其中的 <code>request</code> 是上一步 rest 返回的 Promise，在简单的格式转换后，使用 <code>most.fromPromise</code> 将其也转换成流。
当得到 API 的返回组成的流之后，使用 <code>flatMap</code> 连到 Intent Stream 上。下面是 <code>flatMap</code> 两个API 结果流的示意图，以防读者忘了上一节的 <code>flatMap</code> 例子。
</p>
<pre class="example" id="org460d7a3">
intentStream --urlA---urlB---&gt;
rest(urlA)   -------respA----&gt;
rest(urlB)   ---------respB--&gt;
flatMap(rest)-------respA--respB---&gt;
</pre>


<figure id="orgc1969ac">
<img src="https://github.com/jcouyang/clojure-flavored-javascript/raw/master/book/images/flatmap-stream.png" alt="flatmap-stream.png">

</figure>
</div>
</div>

<div id="outline-container-org80f20da" class="outline-3">
<h3 id="org80f20da">Model</h3>
<div class="outline-text-3" id="text-org80f20da">
<p>
在得到一个里面都是 API 返回值的流之后，可以简单的 model 话一下这条流的数据：
</p>
<pre class="code"><code>.filter(i=&gt;i.type==<span style="color: #D08770;">'dataUpdate'</span>)
.map(data=&gt;JSON.parse(data.value).items)
.map(items=&gt;items.slice(0,10))
</code></pre>

<p>
只取前 10 个结果作为例子。
</p>

<p>
最后，把结果映射成为 state 到新 state 的映射函数：
</p>
<pre class="code"><code>.map(items=&gt;state=&gt;({results: items}))
</code></pre>

<pre class="example" id="org44fae54">
modleStream ---mA---mB---&gt;
stateStream ---state=&gt;({results:mA})---state=&gt;({results:mB})---&gt;
</pre>

<p>
接下来，react-most 会利用输出的 state 流中的函数调用 React 的 <code>setState</code> 方法。
</p>

<p>
到这里，我们利用 Monadic Reactive Programming 的方式，Declarative 的构造出了一整条从输入（用户事件），到该事件所产生的结果的数据流。其中 <b>没有</b> 一个 <b>变量</b> 与 <b>赋值</b> 操作，也没有任何状态和全局依赖，这样的数据流就跟纯函数一样，更易于推理和预测结果。而且由于 Promise 也是时间相关的容器，也轻松的可以转换成 Stream，因此无需关心异步编程，只需要掌控好数据流向与变换就好了。
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<footer>
  <p>Author: unknown
    <a class="github-button" href="https://github.com/sponsors/jcouyang" data-icon="octicon-heart" aria-label="Sponsor @jcouyang on GitHub">Sponsor</a>
    <a aria-label="Follow @jcouyang on GitHub" data-count-aria-label="# followers on GitHub" data-count-api="/users/jcouyang#followers" data-count-href="/jcouyang/followers" href="https://github.com/jcouyang" class="github-button">Follow</a>
    <a href="https://twitter.com/oyanglulu" class="twitter-follow-button" data-show-screen-name="false" data-show-count="false">Follow @oyanglulu</a>
  </p>
  <p>Created: 2016-03-01 Tue 00:00</p>
  <p>Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 28.1 (<a href="https://orgmode.org">Org</a> mode 9.5.3) &#215; <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.
  <input type="swiftype" class="st-default-search-input" placeholder="Search"/>
  <a class="gumroad-button" href="https://gum.co/grokking-monad?wanted=true" target="_blank" data-gumroad-single-product="true">范畴论装逼指南，请自觉排队装逼</a>
  <div id="danmaku-comments"></div>
  <div id="disqus_thread"></div>
</footer>
</div>
</body>
</html>
