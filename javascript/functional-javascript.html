<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-08-22 Sun 09:36 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Functional JavaScript Mini Book</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Jichao Ouyang">
<link rel="icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/toc.css"/>
<link rel="stylesheet" href="/style/tufte.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="https://feeds.oyanglul.us/JichaoOuyangsBlog"/>

<script type="text/javascript" src="https://orgmode.org/org-info.js">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
// @license-end
</script>

<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "4");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "0");
org_html_manager.set("VIEW", "info");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
// @license-end
</script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="preamble" class="status">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJRFJGX"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<header>
    <a accesskey="h" href="/index.html"> HOME </a> |
    <a href="#" id="edit-in-github">EDIT</a> |
    <a href="https://feeds.oyanglul.us/JichaoOuyangsBlog">RSS</a> |
    <a href="https://blog.oyanglul.us/theindex">INDEX</a> |
    <a accesskey="H" href="/jichao.ouyang.html">ABOUT</a> |
    <a href="https://github.com/jcouyang/blog">GITHUB</a>
</header>
</div>
<div id="content">
<header>
<h1 class="title">Functional JavaScript Mini Book</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org675b31d">1. Preface</a></li>
<li><a href="#orga72630f">2. Lambda</a>
<ul>
<li><a href="#org289775f">2.1. 箭头函数(arrow function)</a>
<ul>
<li><a href="#org0cc26af">2.1.1. 声明一个箭头函数</a></li>
<li><a href="#orgfeb529a">2.1.2. 为什么要用箭头函数</a></li>
<li><a href="#org0301e6e">2.1.3. Lexical <code>this</code></a></li>
</ul>
</li>
<li><a href="#org961f9c8">2.2. JavaScript的匿名函数(anonymous function)</a>
<ul>
<li><a href="#org1733ae0">2.2.1. 创建一个匿名函数</a></li>
<li><a href="#org3c72302">2.2.2. 使用匿名函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org589ddad">3. 高阶函数(Higher-order function)</a>
<ul>
<li><a href="#orgfb8a189">3.1. Higher-order function</a>
<ul>
<li><a href="#orgc36b72f">3.1.1. 函数作为参数</a></li>
<li><a href="#org9dcfa62">3.1.2. 函数作为返回值</a></li>
</ul>
</li>
<li><a href="#orgc6fa5cf">3.2. 柯里化 currying</a>
<ul>
<li><a href="#org9d68875">3.2.1. 我们来看一个问题</a>
<ul>
<li><a href="#org4ef6c2b">写一个函数, 可以连接字符数组, 如 f(['1','2']) =&gt; '12'</a></li>
<li><a href="#orgaae5a9c">现在我要其中所有数字加1, 然后在连接</a></li>
<li><a href="#orgfa21a85">所有数字乘以2, 再重构试试看</a></li>
</ul>
</li>
<li><a href="#orgb2b4305">3.2.2. 柯里化函数接口</a></li>
<li><a href="#org5118c19">3.2.3. 自动柯里化</a></li>
</ul>
</li>
<li><a href="#org5a78310">3.3. 函数组合 function composition</a>
<ul>
<li><a href="#org60201ca">3.3.1. Compose</a></li>
<li><a href="#org1eed985">3.3.2. pipe</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd96bfe5">4. Transducers</a>
<ul>
<li><a href="#orgbfe0537">4.1. Reducer</a>
<ul>
<li><a href="#org71dbcb7">4.1.1. transform</a></li>
<li><a href="#org5444796">4.1.2. Reducer</a>
<ul>
<li><a href="#org18e2277">Reducible</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org362ac0c">4.2. Transducer</a></li>
<li><a href="#org9b5d2eb">4.3. Is it Curry?</a></li>
<li><a href="#org1fb9d37">4.4. 完整例子</a></li>
</ul>
</li>
<li><a href="#orge261dbb">5. Functor</a>
<ul>
<li><a href="#orga5be50c">5.1. Functor</a></li>
<li><a href="#org275921a">5.2. 举个栗子🌰</a></li>
<li><a href="#org6ab7600">5.3. Functor in JavaScript</a></li>
</ul>
</li>
<li><a href="#org4f73a27">6. Monad</a>
<ul>
<li><a href="#org8dec7d7">6.1. Either</a></li>
<li><a href="#orgffb6c2b">6.2. 走钢索</a>
<ul>
<li><a href="#org1728e35">6.2.1. 一般解法</a></li>
<li><a href="#org074fc4b">6.2.2. 现在来试试用 Either</a></li>
</ul>
</li>
<li><a href="#org27af63c">6.3. 到底有什么用呢, Monad</a></li>
<li><a href="#org276320c">6.4. Monad 在 JavaScript 中的应用</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<p>
<a href="https://blog.oyanglul.us/shutting-down-gulugulu">📣 不要再找了, 弹幕功能已关闭</a>
</p>
<div class="org-center">
<p>
⚠ DEPRETICATED ⚠
</p>

<p>
本书已 <del>过时</del> 停更，请转到新书 
</p>

<p>
👉 <a href="https://oyanglul.us/clojure-flavored-javascript/">《Clojure Flavored JavaScript》</a> 👈
</p>

<p>
当然，你依然可以请<a href="https://gum.co/fpjs">我喝一杯咖啡</a> ☕
</p>


<figure id="org0dae701">
<img src="./images/shut-up-and-take-my-money.gif" alt="shut-up-and-take-my-money.gif">

</figure>
</div>

<div id="outline-container-org675b31d" class="outline-2">
<h2 id="org675b31d"><span class="section-number-2">1.</span> Preface</h2>
<div class="outline-text-2" id="text-1">
<p>
这是本可能2小时就能看完的小书，但是涵盖了基本所有函数式编程的内容，还包含了一些
ECMAScript 6 定义的函数式新特性, 如箭头函数, 模式匹配等等.
还会介绍函数式一些重要概念在 JavaScript是如何实现即应用,
以及如何以函数式的思想编写 JavaScript 代码.
</p>

<div class="epigraph"><blockquote>
<p>
本书虽然与我翻译的Michael Fogus的<a href="http://book.douban.com/subject/22733640/">Functional JavaScript</a>同名, 但是请不要当成是Fogus大师的mini版本, 
这里的内容完全跟Fogus大师的不一样, 可能比大师的要再"函数式"一些<label for="1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="1" class="margin-toggle"/><span class="sidenote">
Fogus同时是The Joy of Clojure的作者,我
特别奇怪为什么不把Clojure真正Good part写进Functional JavaScript里
</span>, 用js实现了一些其他函数式语言(Clojure, Haskell)特有的函数式features.
</p>

</blockquote></div>

<p>
对果JavaScript的基本概念对你来说:
</p>


<figure id="org6945e13">
<img src="./images/preface/what_you_talking.gif" alt="what_you_talking.gif">

</figure>

<p>
可能本书并不适合你, 请先移步 <a href="https://leanpub.com/javascript-allonge">JavaScript Allonge</a>,
但是如果你学习函数式编程时感到费解:
</p>


<figure id="orga9e8bdb">
<img src="./images/preface/summarize_in_one_word.gif" alt="summarize_in_one_word.gif">

<figcaption><span class="figure-number">Figure 1: </span>I'm not reading the crap, summarize in one word</figcaption>
</figure>

<p>
那么这本书将会对你会有所帮助.
</p>

<p>
我选用的 JavaScript 函数式库是
<a href="https://rawgit.com/CrossEye/eweda/master/docs/eweda.html">Eweda</a>(<a href="https://ramdajs.com">Ramda</a> 的最初实现，更遵守函数式教条，但由于
javascript 的栈很容易爆，Ramda的实现要更 pratical
一些而且可以用的产品代码中， 千万不要在产品中用
eweda,这里只用eweda做介绍目的)
</p>

<div class="epigraph"><blockquote>
<p>
<a href="https://fr.umio.us/why-ramda/">为什么不用 Underscore/Lodash</a> 请移步第二章
</p>

</blockquote></div>

<div class="epigraph"><blockquote>
<p>
由于会介绍 ECMAScript 6 的新特性, 书中很多写法都是 ECMAScript
6 标准, 只能在实现这些 feature 的浏览器(如 Firefox,
请目前参照各浏览器的<a href="https://kangax.github.io/compat-table/es6/">实现情况</a>) 里运行.
另外, 大多数的例子源码都会在文章里的 jsbin 链接里.
</p>

</blockquote></div>
</div>
</div>

<div id="outline-container-orga72630f" class="outline-2">
<h2 id="orga72630f"><span class="section-number-2">2.</span> Lambda</h2>
<div class="outline-text-2" id="text-2">
<p>
为什么讲 lambda, 如果小时候玩过游戏"半条命",那么你早都见过 lambda 了.
</p>


<figure id="org6611d57">
<img src="./images/lambda/Lambda_reactor_complex_logo.png" alt="Lambda_reactor_complex_logo.png">

</figure>

<p>
我从wikipedia里面粘出来了这么一段定义:
</p>
<div class="epigraph"><blockquote>
<p>
lambda包括一条变换规则（变量替换）和一条函数定义方式，Lambda演算之通用在于，任何一个可计算函数都能用这种形式来表达和求值。因而，它是等价于图灵机的.
</p>

</blockquote></div>

<p>
好吧, 跟没解释一样. 简单来说lambda其实就是 <code>x</code> 到 <code>y</code> 的映射关系, 但在大部分支持函数式的编程语言中,
它等价于匿名函数. 被称为 lambda 表达式.
因为这些函数只需要用一次, 而且变换不复杂, 完全不需要命名.
</p>


<figure id="org24afa15">
<img src="./images/lambda/parallel-universe.gif" alt="parallel-universe.gif">

</figure>

<p>
匿名函数在程序中的作用是可以作为参数传给高阶函数<label for="2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="2" class="margin-toggle"/><span class="sidenote">
第二章会详细解释高阶函数和闭包.
</span>, 或者作为闭包被返回.
</p>

<p>
但是匿名函数并不是原本的 lambda 算子, 因为匿名函数也可以接受多个参数, 如
</p>

<pre class="example" id="orgd56f2f6">
multiple(x, y) = x*y
</pre>

<p>
写成简单映射的形式, 把名字去掉
</p>

<pre class="example" id="org0294ac3">
(x,y) -&gt; x*y
</pre>

<p>
这就是 lambda 了吗, 不是, lambda的用意是简化这个映射关系以至不需要名字,
更重要的是只映射一个 x.
</p>

<p>
什么意思呢? 让我们来分解一下上面的这个映射的过程.
</p>

<ol class="org-ol">
<li><p>
lambda 接受第一个参数 <code>5</code>, 返回另一个 lambda
</p>

<pre class="example" id="org6fb5faf">
(5) -&gt; (y -&gt; 5*y) 
</pre></li>

<li>该返回的 lambda <code>y -&gt; 5*y</code> 接收 <code>y</code> 并且返回 <code>5*y</code>, 若在用 <code>4</code> 调用该 lambda</li>
</ol>

<pre class="example" id="org2af4be9">
es6 -&gt; 5*4
</pre>

<p>
因此这里的匿名函数 <code>(x,y)-&gt;x*y</code> 看似一个 lambda, 其实是两个 lambda
的结合.
</p>

<p>
而这种接受一个参数返回另一个接收第二个参数的函数叫柯里化<label for="3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="3" class="margin-toggle"/><span class="sidenote">
柯里化会在第二章详细讨论.
</span>.
</p>

<p>
这里我们先忍一忍, 来看下 JavaScript 中的 lambda 表达式.
</p>
</div>
<div id="outline-container-org289775f" class="outline-3">
<h3 id="org289775f"><span class="section-number-3">2.1.</span> 箭头函数(arrow function)</h3>
<div class="outline-text-3" id="text-2-1">
<p>
来看看越来越函数式の JavaScript
</p>

<p>
新的草案<a href="https://kangax.github.io/compat-table/es6/">ECMAScript 6</a>
(虽然说是草案,但你可以看到 Firefox 其实已经实现大部分的
feature)里我们越来越近了, 借助一下transcompiler例如<a href="https://babeljs.io">Babel</a> 我们完全可以在项目中开始使用es6了<label for="4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="4" class="margin-toggle"/><span class="sidenote">
可以看看es6比较有意思的新特性 <a href="https://blog.oyanglul.us/javascript/essential-ecmascript6.html">https://blog.oyanglul.us/javascript/essential-ecmascript6.html</a>
</span>。
</p>

<p>
看看里面有一行 arrow
function，为什么叫箭头函数，还记得前面说lambda是提到的箭头吗。而且如果你之前用过
Haskell(单箭头) 或者Scala(双箭头), 会发现都用的是箭头来表示简单映射关系.
</p>

<div class="epigraph"><blockquote>
<p>
由于 arrow function 只在Firefox 22以上版本实现,
本节的所有代码都可以在Firefox的Console中调试, 其他chrome 什么的都没有实现(完全)<label for="5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="5" class="margin-toggle"/><span class="sidenote">
Chrome有一个 feature toggle 可以打开部分 es6 功能 <code>chrome://flags/#enable-javascript-harmony</code>
</span>.
另外每节的最后我都会给出完整代码的可执行的 jsbin 链接.
</p>

</blockquote></div>
</div>

<div id="outline-container-org0cc26af" class="outline-4">
<h4 id="org0cc26af"><span class="section-number-4">2.1.1.</span> 声明一个箭头函数</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
你可以用两种方式定义一个箭头函数
</p>

<pre class="example" id="orgbfb46eb">
([param] [, param]) =&gt; {
   statements
}
// or
param =&gt; expression
</pre>

<p>
单个表达式可以写成一行, 而多行语句则需要 block <code>{}</code> 括起来.
</p>
</div>
</div>

<div id="outline-container-orgfeb529a" class="outline-4">
<h4 id="orgfeb529a"><span class="section-number-4">2.1.2.</span> 为什么要用箭头函数</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
看看旧的匿名函数怎么写一个使数组中数字都乘2的函数.
</p>

<pre class="example" id="org2f63ddc">
var a = [1,2,curry,es6,5];
a.map(function(x){ return x*2 });
</pre>

<p>
用箭头函数会变成
</p>

<pre class="example" id="org2b87e29">
a.map(x =&gt; x*2);
</pre>

<p>
只是少了 <code>function</code> 和 <code>return</code> 以及 block, 不是吗? 如果觉得差不多,
因为你看惯了 JavaScript 的匿名函数,
你的大脑编译器自动的忽略了,因为他们不需要显示的存在.
</p>

<p>
而 <code>map(x =&gt; x*2)</code> 要更 make sense,
因为我们需要的匿名函数只需要做一件事情, 我们需要的是 一个函数 <code>f</code>,
可以将给定 <code>x</code>, 映射到 <code>y</code>.
翻译这句话的最简单的方式不就是 <code>f = (x =&gt; x*2)</code>
</p>
</div>
</div>

<div id="outline-container-org0301e6e" class="outline-4">
<h4 id="org0301e6e"><span class="section-number-4">2.1.3.</span> Lexical <code>this</code></h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
如果你觉得这还不足以说服改变匿名函数的写法,
那么想想以前写匿名函数中的经常需要 <code>var self=this</code> 的苦恼.
</p>

<pre class="code"><code>    <span style="color: #00008b;">var</span> <span style="color: #b8860b;">Multipler</span> = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">inc</span>){
      <span style="color: #6b8e23;">this</span>.inc = inc;
    }
    Multipler.<span style="color: #6b8e23;">prototype</span>.multiple = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">numbers</span>){
      <span style="color: #00008b;">return</span> numbers.map(<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">number</span>){
        <span style="color: #00008b;">return</span> <span style="color: #6b8e23;">this</span>.inc * number;
      })
    }
    <span style="color: #00008b;">new</span> <span style="color: #36648b;">Multipler</span>(2).multiple([1,2,curry,es6]) 
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; [NaN, NaN, NaN, NaN]  &#19981; work, &#22240;&#20026; map &#37324;&#38754;&#30340; this &#25351;&#21521;&#30340;&#26159;&#20840;&#23616;&#21464;&#37327;( window)</span>

    Multipler.<span style="color: #6b8e23;">prototype</span>.multiple = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">numbers</span>){
      <span style="color: #00008b;">var</span> <span style="color: #b8860b;">self</span> = <span style="color: #6b8e23;">this</span>; <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">&#20445;&#25345; Multipler &#30340; this &#30340;&#32531;&#23384;</span>
      <span style="color: #00008b;">return</span> numbers.map(<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">number</span>){
        <span style="color: #00008b;">return</span> self.inc * number;
      })
    }
    <span style="color: #00008b;">new</span> <span style="color: #36648b;">Multipler</span>(2).multiple([1,2,curry,es6]) <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; [ 2, es6, 6, 8 ]</span>
</code></pre>

<p>
很怪不是吗, 确实是 Javascript 的一个 bug, 因此经常出现在各种面试题中, 问 <code>this</code> 到底是谁.
</p>


<figure id="orgbeb5fe1">
<img src="./images/lambda/which-leela.gif" alt="which-leela.gif">

</figure>

<p>
试试替换成 arrow function
</p>

<pre class="code"><code>Multipler.<span style="color: #6b8e23;">prototype</span>.multiple = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">numbers</span>){
  <span style="color: #00008b;">return</span> numbers.map((number) =&gt; number*<span style="color: #6b8e23;">this</span>.inc);
};

console.log(<span style="color: #00008b;">new</span> <span style="color: #36648b;">Multipler</span>(2).multiple([1,2,curry,es6]));<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; [ 2, es6, 6, 8 ]</span>
</code></pre>

<p>
不需要 <code>var self=this</code> 了是不是很开心☺️现在, arrow function 里面的
this 会自动 capture 外层函数的 <code>this</code> 值.
</p>

<a class="jsbin-embed" href="https://jsbin.com/vawobe/1/embed?js,console">完整代码</a><script src="https://static.jsbin.com/js/embed.js"></script>
</div>
</div>
</div>

<div id="outline-container-org961f9c8" class="outline-3">
<h3 id="org961f9c8"><span class="section-number-3">2.2.</span> JavaScript的匿名函数(anonymous function)</h3>
<div class="outline-text-3" id="text-2-2">
<p>
支持匿名函数, 也就意味着函数可以作为一等公民. 可以被当做参数,
也可以被当做返回值.因此, JavaScript 的支持一等函数的函数式语言,
而且定义一个匿名函数式如此简单.
</p>
</div>

<div id="outline-container-org1733ae0" class="outline-4">
<h4 id="org1733ae0"><span class="section-number-4">2.2.1.</span> 创建一个匿名函数</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
在JavaScript里创建一个函数是如此的 <del>简单</del> &#x2026; 比如:
</p>
<pre class="code"><code><span style="color: #00008b;">function</span>(<span style="color: #b8860b;">x</span>){
    <span style="color: #00008b;">return</span> x*x;
}<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; SyntaxError: function statement requires a name</span>
</code></pre>

<p>
但是, 为什么报错了这里. 因为创建一个匿名函数需要用表达式(function
expression). 表达式是会返回值的:
</p>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">a</span> = <span style="color: #00008b;">new</span> <span style="color: #36648b;">Array</span>() <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">new Array &#26159;&#34920;&#36798;&#24335;, &#32780;&#36825;&#25972;&#34892;&#21483;&#35821;&#21477; statement</span>
</code></pre>

<p>
但为什么说 <code>function statement requires a name</code>. 因为 JavaScript
<b>还有一种</b> 创建函数的方法--<i>function statement</i>.
而在上面这种写法会被认为是一个 function 语句, 因为并没有期待值. 而
function 语句声明是需要名字的.
</p>

<p>
简单将这个函数赋给一个变量或当参数传都不会报错,
因为这时他没有歧义,只能是表达式.比如:
</p>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">squareA</span> = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">x</span>){
    <span style="color: #00008b;">return</span> x*x;
}
</code></pre>

<p>
但是这里比较 tricky 的是这下 <code>squareA</code> 其实是一个具名函数了.
</p>

<pre class="example" id="org4bd3bd9">
console.log(squareA) // =&gt; function squareA()
</pre>

<p>
虽然结果是具名函数,但是过程却与下面这种声明的方式不一样.
</p>

<pre class="code"><code><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">squareB</span>(<span style="color: #b8860b;">x</span>){
    <span style="color: #00008b;">return</span> x*x;
} <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; undefined</span>
</code></pre>

<p>
<code>squareB</code> 用的是 function statement 直接声明(显然 statement 没有返回),
而 <code>squareA</code> 则是先用 function expression 创建一个匿名函数,
然后将返回的函数赋给了名为 <code>squareA</code> 的变量. 因为表达式是有返回的:
</p>

<pre class="code"><code>console.log(<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">x</span>){ <span style="color: #00008b;">return</span> x*x});
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; undefined</span>
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; function ()</span>
</code></pre>

<p>
第一个 <code>undefined</code> 是 <code>console.log</code> 的返回值, 因此
<code>function()</code> 则是打印出来的 function 表达式创建的匿名函数.
</p>
</div>
</div>

<div id="outline-container-org3c72302" class="outline-4">
<h4 id="org3c72302"><span class="section-number-4">2.2.2.</span> 使用匿名函数</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
JavaScript 的函数是一等函数. 这意味着我们的函数跟值的待遇是一样的,于是它
</p>

<p>
可以赋给变量:
</p>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">square</span> = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">x</span>) {<span style="color: #00008b;">return</span> x*x}
</code></pre>

<p>
可以当参数, 如刚才见到的:
</p>

<pre class="code"><code>console.log(<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">x</span>){<span style="color: #00008b;">return</span> x*x})
</code></pre>

<p>
将函数传给了 <code>console.log</code>
</p>

<p>
可以被返回:
</p>

<pre class="code"><code><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">multiply</span>(<span style="color: #b8860b;">x</span>){
    <span style="color: #00008b;">return</span> <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">y</span>){
        <span style="color: #00008b;">return</span> x*y;
    }
}
multiply(1)(2) <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; 2</span>
</code></pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org589ddad" class="outline-2">
<h2 id="org589ddad"><span class="section-number-2">3.</span> 高阶函数(Higher-order function)</h2>
<div class="outline-text-2" id="text-3">
<p>
我们已经见识到了匿名函数和箭头函数的用法, 匿名的一等函数到底有什么用呢?
来看看高阶函数的应用.
</p>

<p>
高阶函数意思是它接收另一个函数作为参数. 为什么叫 <b>高阶</b>: 来看看这个函数
<code>f(x, y) = x(y)</code> 按照 lambda 的简化过程则是
</p>

<pre class="example" id="org29563d6">
f(x) =&gt; (y -&gt; x(y))
(y) =&gt; x(y)
</pre>

<p>
可以看出来调用 f 时却又返回了一个函数x.
</p>

<p>
还记得高等数学里面的导数吗, 两阶以上的导数叫高阶导数.
因为求导一次以后返回的可以求导.
</p>

<p>
概念是一样的,
如同<a href="https://en.wikipedia.org/wiki/Matryoshka_doll">俄罗斯套娃</a> 当函数执行以后还需执行或者要对参数执行,
因此叫高阶函数.
</p>


<figure id="orgf7cba44">
<img src="./images/higherorder/recursion.png" alt="recursion.png">

</figure>

<p>
高阶函数最常见的应用如 <code>map</code>, <code>reduce</code>.
他们都是以传入不同的函数来以不同的方式操作数组元素.
</p>

<p>
另外 <i>柯里化</i>, 则是每次消费一个参数并返回一个逐步被配置好的函数.
</p>
<p>
高阶函数的这些应用都是为函数的组合提供灵活性.
在本章结束相信你会很好的体会到函数组合的强大之处.
</p>
</div>

<div id="outline-container-orgfb8a189" class="outline-3">
<h3 id="orgfb8a189"><span class="section-number-3">3.1.</span> Higher-order function</h3>
<div class="outline-text-3" id="text-3-1">
<p>
函数在 JavaScript 中是一等公民, 因此在 JavaScript 中, 使用高阶函数是非常方便的.
</p>
</div>

<div id="outline-container-orgc36b72f" class="outline-4">
<h4 id="orgc36b72f"><span class="section-number-4">3.1.1.</span> 函数作为参数</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
假设我现在要对一个数组排序, 用我们熟悉的 <code>sort</code>
</p>

<pre class="code"><code>[1,3,2,5,4].sort( (x, y) =&gt; x - y )
</code></pre>

<p>
如果我们要逆序的排序, 把减号左右的 <code>x</code> 和 <code>y</code> 呼唤,就这么简单,
但如果我是一个对象数组, 要根据对象的 <code>id</code> 排序:
</p>

<pre class="code"><code>[{id:1, name:<span style="color: #8b0000;">'one'</span>},
 {id:3, name:<span style="color: #8b0000;">'three'</span>}, 
 {id:2, name:<span style="color: #8b0000;">'two'</span>}, 
 {id:5, name:<span style="color: #8b0000;">'five'</span>},  
 {id:4, name:<span style="color: #8b0000;">'four'</span>}].sort((x,y) =&gt; x.id - y.id)
</code></pre>

<p>
是不是已经能够感受到高阶函数与匿名函数组合的灵活性.
</p>
</div>
</div>

<div id="outline-container-org9dcfa62" class="outline-4">
<h4 id="org9dcfa62"><span class="section-number-4">3.1.2.</span> 函数作为返回值</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
函数的返回值可以不只是值, 同样也可以是一个函数, 来看 Eweda
内部的一个工具函数 <code>aliasFor</code>, 他的作用是给函数 E 的一些方法起一些别名:
</p>

<div class="epigraph"><blockquote>
<p>
听起来很怪不是吗, 函数怎么有方法, 实际上 JavaScript 的 <code>function</code>
是一个特殊 <b>对象</b>, 试试在 Firefox console 里敲 <code>console.log.</code>
是不是看到了一些方法, 但是 <code>typeof console.log</code> 是 function
</p>

</blockquote></div>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">E</span> = () =&gt; {}
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">aliasFor</span> = oldName =&gt; {
    <span style="color: #00008b;">var</span> <span style="color: #b8860b;">fn</span> = newName =&gt; {
      E[newName] = E[oldName];
      <span style="color: #00008b;">return</span> fn;
    };
    <span style="color: #00008b;">return</span> (fn.is = fn.are = fn.and = fn);
};
</code></pre>

<p>
这里有两个 <code>return</code>, 一个是 <code>fn</code> 返回自己, 另一个是 <code>aliasFor</code> 也返回
<code>fn</code>, 并且给 <code>fn</code> 了几个别名 <code>fn.is</code> <code>fn.are</code>&#x2026;
</p>

<p>
什么意思呢? <code>fn</code> 返回 <code>fn</code>. 很简单就是 <code>fn() =&gt; fn</code>,
那么 <code>fn()()=&gt;fn()=&gt;fn</code> &#x2026;以此类推, 无论调用 fn 多少次,都最终返回 fn.
</p>


<figure id="org913a336">
<img src="./images/higherorder/1qUCC8s.png" alt="1qUCC8s.png">

</figure>

<p>
这到底有什么用呢, 由于这里使用了 <code>fn</code> 的副作用(side affect)
来干了一些事情 <code>E[newName]=E[oldName]</code>, 也就是给 E 的方法起一个别名,
因此每次调用 fn 都会给 <code>E</code> 起一个别名. <code>aliasFor</code> 最后返回的是 <code>fn</code>
自己的一些别名, 使得可以 chain 起来更可读一些:
</p>

<pre class="code"><code>aliasFor(<span style="color: #8b0000;">'reduce'</span>).is(<span style="color: #8b0000;">'reduceLeft'</span>).is(<span style="color: #8b0000;">'foldl'</span>)
</code></pre>

<a class="jsbin-embed" href="https://jsbin.com/qohil/1/embed?js,console">完整代码</a><script src="https://static.jsbin.com/js/embed.js"></script>

<div class="epigraph"><blockquote>
<p>
另外, 函数作为返回值的重要应用, 柯里化与闭包,
将会在在后面专门介绍. 我们先来看下以函数作为参数的高阶函数的典型应用.
</p>

</blockquote></div>
</div>
</div>
</div>

<div id="outline-container-orgc6fa5cf" class="outline-3">
<h3 id="orgc6fa5cf"><span class="section-number-3">3.2.</span> 柯里化 currying</h3>
<div class="outline-text-3" id="text-3-2">
<p>
还记得 Haskell Curry吗
</p>


<figure id="org0000f7e">
<img src="./images/higherorder/curry.png" alt="curry.png">

</figure>

<p>
多巧啊, 人家姓 Curry 名 Haskell, 难怪 Haskell 语言会自动柯里化, 呵呵.
但是不奇怪吗, 为什么要柯里化呢. 为什么如此重要得让 Haskell
会默认自动柯里化所有函数, 不就是返回一个部分配置好的函数吗.
</p>

<p>
我们来看一个 Haskell 的代码.
</p>

<pre class="code"><code><span style="color: #6a5acd;">max</span> 3 4
(max 3) 4
</code></pre>

<p>
结果都是4, 这有什么用呢.
</p>

<p>
这里看不出来, 放到 <code>高阶函数</code> 试试. 什么? 看不懂天书 Haskell, 来看看
JavaScript 吧.
</p>
</div>

<div id="outline-container-org9d68875" class="outline-4">
<h4 id="org9d68875"><span class="section-number-4">3.2.1.</span> 我们来看一个问题</h4>
<div class="outline-text-4" id="text-3-2-1">
</div>
<div id="outline-container-org4ef6c2b" class="outline-5">
<h5 id="org4ef6c2b">写一个函数, 可以连接字符数组, 如 f(['1','2']) =&gt; '12'</h5>
<div class="outline-text-5" id="text-org4ef6c2b">
<p>
好吧,如果不用柯里化, 怎么写? 啊哈 <code>reduce</code>
</p>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">concatArray</span> = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">chars</span>){
  <span style="color: #00008b;">return</span> chars.reduce(<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">a</span>, <span style="color: #b8860b;">b</span>){
    <span style="color: #00008b;">return</span> a.concat(b);
  });
}
concat([<span style="color: #8b0000;">'1'</span>,<span style="color: #8b0000;">'2'</span>,<span style="color: #8b0000;">'3'</span>]) <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; '123'</span>
</code></pre>

<p>
很简单,对吧.
</p>
</div>
</div>

<div id="outline-container-orgaae5a9c" class="outline-5">
<h5 id="orgaae5a9c">现在我要其中所有数字加1, 然后在连接</h5>
<div class="outline-text-5" id="text-orgaae5a9c">
<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">concatArray</span> = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">chars</span>, <span style="color: #b8860b;">inc</span>){
  <span style="color: #00008b;">return</span> chars.map(<span style="color: #00008b;">function</span>(<span style="color: #36648b;">char</span>){
    <span style="color: #00008b;">return</span> (+<span style="color: #36648b;">char</span>)+inc + <span style="color: #8b0000;">''</span>;
  }).reduce(<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">a</span>,<span style="color: #b8860b;">b</span>){
      <span style="color: #00008b;">return</span> a.concat(b)
  });
}
console.log(concatArray([<span style="color: #8b0000;">'1'</span>,<span style="color: #8b0000;">'2'</span>,<span style="color: #8b0000;">'3'</span>], 1))<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; '234'</span>
</code></pre>
</div>
</div>

<div id="outline-container-orgfa21a85" class="outline-5">
<h5 id="orgfa21a85">所有数字乘以2, 再重构试试看</h5>
<div class="outline-text-5" id="text-orgfa21a85">
<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">multiple</span> = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">a</span>, <span style="color: #b8860b;">b</span>){
  <span style="color: #00008b;">return</span> +a*b + <span style="color: #8b0000;">''</span>
}
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">concatArray</span> = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">chars</span>, <span style="color: #b8860b;">inc</span>){
  <span style="color: #00008b;">return</span> chars.map(<span style="color: #00008b;">function</span>(<span style="color: #36648b;">char</span>){
    <span style="color: #00008b;">return</span> multiple(<span style="color: #36648b;">char</span>, inc);
  }).reduce(<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">a</span>,<span style="color: #b8860b;">b</span>){
      <span style="color: #00008b;">return</span> a.concat(b)
  });
}
console.log(concatArray([<span style="color: #8b0000;">'1'</span>,<span style="color: #8b0000;">'2'</span>,<span style="color: #8b0000;">'3'</span>], 2)) <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; '246'</span>
</code></pre>

<p>
是不是已经看出问题了呢?
如果我在需要每个数字都减2,是不是很麻烦呢.需要将 <code>map</code> 参数匿名函数中的
multiple 函数换掉. 这样一来 <code>concatArray</code> 就不能同时处理加, 乘和减?
那么怎么能把他提取出来呢? 来对比下柯里化的解法.
</p>
</div>
</div>
</div>

<div id="outline-container-orgb2b4305" class="outline-4">
<h4 id="orgb2b4305"><span class="section-number-4">3.2.2.</span> 柯里化函数接口</h4>
<div class="outline-text-4" id="text-3-2-2">
<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">multiple</span> = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">a</span>){
  <span style="color: #00008b;">return</span> <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">b</span>){
    <span style="color: #00008b;">return</span> +b*a + <span style="color: #8b0000;">''</span>
  }
}

<span style="color: #00008b;">var</span> <span style="color: #b8860b;">plus</span> = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">a</span>){
  <span style="color: #00008b;">return</span> <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">b</span>){
    <span style="color: #00008b;">return</span> (+b)+a + <span style="color: #8b0000;">''</span>
  }
}
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">concatArray</span> = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">chars</span>, <span style="color: #b8860b;">stylishChar</span>){
  <span style="color: #00008b;">return</span> chars.map(stylishChar)
    .reduce(<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">a</span>,<span style="color: #b8860b;">b</span>){
      <span style="color: #00008b;">return</span> a.concat(b)
  });
}
console.log(concatArray([<span style="color: #8b0000;">'1'</span>,<span style="color: #8b0000;">'2'</span>,<span style="color: #8b0000;">'3'</span>], multiple(2)))
console.log(concatArray([<span style="color: #8b0000;">'1'</span>,<span style="color: #8b0000;">'2'</span>,<span style="color: #8b0000;">'3'</span>], plus(2)))
</code></pre>

<p>
有什么不一样呢 1. 处理数组中字符的函数被提取出来, 作为参数传入 2.
提取成柯里化的函数, 部分配置好后传入, 好处显而易见, 这下接口非常通畅
无论是外层调用
</p>

<pre class="example" id="orgb8a5ab2">
concatArray(['1','2','3'], multiple(2))
</pre>

<p>
还是内部的 map 函数
</p>

<pre class="example" id="org92d1df2">
chars.map(stylishChar)
</pre>

<p>
这些接口都清晰了很多, 不是吗
</p>

<p>
这就是函数式的思想, 用已有的函数组合出新的函数, 而柯里化每消费一个参数,
都会返回一个新的部分配置的函数, 这为函数组合提供了更灵活的手段,
并且使得接口更为流畅.
</p>
</div>
</div>

<div id="outline-container-org5118c19" class="outline-4">
<h4 id="org5118c19"><span class="section-number-4">3.2.3.</span> 自动柯里化</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
在 Haskell 语言中, 函数是会自动柯里化的:
</p>

<pre class="code"><code><span style="color: #6a5acd;">max</span> 3 4
</code></pre>

<p>
其实就是
</p>

<pre class="example" id="orgfe1f4ec">
(max 3) 4
</pre>

<p>
可以看看 <code>max</code> 与 <code>max 3</code> 函数的 类型
</p>

<pre class="code"><code>ghci<span style="color: #6a5acd;">&gt;</span> <span style="color: #36648b;">:</span>t max
<span style="color: #6a5acd;">max</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">Ord</span> a <span style="color: #b8860b;">=&gt;</span> a <span style="color: #b8860b;">-&gt;</span> a <span style="color: #b8860b;">-&gt;</span> a
</code></pre>

<p>
看明白了么, <code>Ord a =&gt;</code> 表示类型约束为可以比较大小的类型, 因此 <code>max</code>
的类型可以翻译成: 当给定一个 <code>a</code>, 会得到 <code>a -&gt; a</code>,
再看看 <code>max 3</code> 的类型就好理解了
</p>

<pre class="example" id="org41356de">
ghci&gt; :t max 3
(Num a, Ord a) =&gt; a -&gt; a
</pre>

<p>
左侧表示类型约束 <code>a</code> 可以是 <code>Ord</code> 或者 <code>Num</code>,
意思是 <code>max 3</code> 还是一个函数,如果给定一个 <code>Ord</code> 或者 <code>Num</code> 类型的参数
则返回一个 <code>Ord</code> 或者 <code>Num</code>.
</p>

<p>
现在是不是清晰了, 在 Haskell 中每给定一个参数, 函数如果是多参数的,
该函数还会返回一个处理余下参数的函数. 这就是自动柯里化.
</p>

<p>
而在 Javascript(以及大多数语言) 中不是的, 如果给定多参函数的部分参数,
函数会默认其他参数是 <code>undefined</code>, 而不会返回处理剩余参数的函数.
</p>

<pre class="code"><code><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">willNotCurry</span>(<span style="color: #b8860b;">a</span>, <span style="color: #b8860b;">b</span>, <span style="color: #b8860b;">c</span>) {
    console.log(a, b, c)
    <span style="color: #00008b;">return</span> a*b-c;
}
willNotCurry(1)
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; NaN</span>
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; 1 undefined undefined</span>
</code></pre>

<p>
如果使用自动柯里化的库 <a href="https://github.com/CrossEye/eweda">eweda</a>,
前面的例子简直就完美了
</p>

<pre class="example" id="org6edd443">
var multiple = curry(function(a, b){
  return +b*a + ''
})
var plus = curry(function(a, b){
  return (+b)+a + ''
})
</pre>

<a class="jsbin-embed" href="https://jsbin.com/hamoq/6/embed?js,console">完整代码</a><script src="https://static.jsbin.com/js/embed.js"></script>
</div>
</div>
</div>

<div id="outline-container-org5a78310" class="outline-3">
<h3 id="org5a78310"><span class="section-number-3">3.3.</span> 函数组合 function composition</h3>
<div class="outline-text-3" id="text-3-3">
<p>
通过前面介绍的高阶函数, map, fold 以及柯里化,
其实已经见识到什么是函数组合了. 如之前例子中的 map 就是 由 fold 函数与
reverse 函数组合出来的.
</p>

<p>
这就是函数式的思想, 不断地用已有函数, 来组合出新的函数.
</p>


<figure id="orgc07f36d">
<img src="./images/higherorder/composition.jpg" alt="composition.jpg">

</figure>

<p>
如图就是函数组合，来自
<a href="https://en.wikipedia.org/wiki/Category_theory">Catgory Theory</a>（Funtor 也是从这来的，后面会讲到）, 既然从 A到B
有对应的映射f，B到 C有对应的映射g， 那么 <code>(g.f)(x)</code> 也就是 <code>f</code> 与 <code>g</code>
的组合 <code>g(f(x))</code> 就是 A到 C 的映射。上一章实现的 map 函数就相当于
<code>reverse.fold</code>.
</p>
</div>

<div id="outline-container-org60201ca" class="outline-4">
<h4 id="org60201ca"><span class="section-number-4">3.3.1.</span> Compose</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
我们可以用 Eweda 非常方便的 compose 方法来组合函数
</p>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">gf</span> = E.compose(f, g)
</code></pre>

<p>
说到了函数组合, 柯里化, 我想现在终于可以解释清楚为什么在这里选用
Eweda/Ramda 而不是 Underscore 了.
</p>

<p>
举个例子🌰 如果我现在想要 tasks 列表中所有属性为 <code>completed</code> 为 <code>true</code>
的元素, 并按照 <code>id</code> 排序.
</p>

<p>
underscore 里会这样写:
</p>

<pre class="code"><code>_(tasks)
    .chain()
    .filter( task =&gt; task.completed===<span style="color: #6b8e23;">true</span>)
    .sortBy( task =&gt; task.id)
    .value();
</code></pre>

<p>
这种方式怎么看都不是函数式, 而是以对象/容器为中心的串联，有些像 jquery
对象的链式调用, 或者我们可以写的函数式一些, 如
</p>

<pre class="code"><code>_.sortBy(_.filter(tasks, task =&gt; task.completed===<span style="color: #6b8e23;">true</span>), task =&gt; task.id)
</code></pre>

<p>
恩恩, 看起来不错嘛, 但是有谁是这么用 underscore的呢. 一般都会只见过
链式调用才是 underscore 的标准写法。
</p>

<p>
来对比一下用 Eweda/Ramda 解决的过程 :
</p>

<pre class="code"><code>compose(sortBy(task=&gt;task.id), filter(task=&gt;task.completed===<span style="color: #6b8e23;">true</span>))(tasks)
</code></pre>

<p>
好像没什么区别啊? 不就是用了 compose 吗?
</p>

<p>
区别大了这, 看见 <code>tasks</code> 是最后当参数传给 <code>E.compose()</code> 的吗?
而不是写死在filter 的参数中. 这意味着在接到需要处理的数据前,
我已经组合好一个新的函数在等待数据, 而不是把数据混杂在中间,
或是保持在一个中间对象中. 而 underscore
的写法导致这一长串 <code>_.sortBy(_.filter())</code> 其实根本无法重用。
</p>

<p>
好吧如果你还看不出来这样做的好处. 那么来如果我有一个包含几组 tasks的列表
groupedTasks, 我要按类型选出 completed 为 true 并按 id 排序.
如我现在数据是这个：
</p>

<pre class="example" id="orgfd13f2b">
groupedTasks = [
  [{completed:false, id:1},{completed:true, id:2}],
  [{completed:false, id:4},{completed:true, id:3}]
]
</pre>

<p>
underscore:
</p>

<pre class="code"><code>_.map(groupedTasks,
   tasks =&gt; _.sortBy(_.filter(tasks, task =&gt; task.completed===<span style="color: #6b8e23;">true</span>), task =&gt; task.id))
</code></pre>

<p>
看见我们又把 <code>_.sortBy(_.filter())</code> 这一长串原封不动的拷贝到了 map 里。
因为 underscore
一开始就要消费数据，使得很难重用，除非在套在另一个函数里：
</p>

<pre class="code"><code><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">completedAndSorted</span>(<span style="color: #b8860b;">tasks</span>){
  <span style="color: #00008b;">return</span> _.sortBy(_.filter(tasks, task =&gt; task.completed===<span style="color: #6b8e23;">true</span>), task =&gt; task.id))
}
_.map(groupedTasks, completedAndSorted)
</code></pre>

<p>
只有这样才能重用已有的一些函数。或者虽然 underscore 也有 <code>_.compose</code>
方法，但是 几乎所有 underscore
的方法都是先消费数据（也就是第一个参数是数据），使得很难放到 <code>compose</code>
方法中，不信可以尝试把 filter 和 sortBy 搁进去，反正我是做不到。
</p>

<p>
来看看真正的函数组合
</p>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">completedAndSorted</span> = compose(sortBy(task=&gt;task.id),
                                 filter(task=&gt;task.completed===<span style="color: #6b8e23;">true</span>))
map(completedAndSorted, groupedTasks)
</code></pre>

<p>
看出来思想完全不一样了吧.
</p>

<p>
由于 Eweda/Ramda 的函数都是自动柯里化,而且数据总是最后一个参数,
因此可以随意组合, 最终将需要处理的数据扔给组合好的函数就好了.
这才是函数式的思想. 先写好一个公式，在把数据扔给
公式。而不是算好一部分再把结果给另一个公式。
</p>


<figure id="orge2b79c3">
<img src="./images/higherorder/ThreeFunctionMachines.jpg" alt="ThreeFunctionMachines.jpg">

</figure>

<p>
而 underscore 要么是以对象保持中间数据, 用 chaining
的方式对目标应用各种函数（书上会写这是Flow-Base
programming，但我觉得其实是 Monad，会在下一章中介绍）,
要么用函数嵌套函数, 将目标一层层传递下去.
</p>
</div>
</div>

<div id="outline-container-org1eed985" class="outline-4">
<h4 id="org1eed985"><span class="section-number-4">3.3.2.</span> pipe</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
类似 compose, eweda/ramda 还有一个方法叫 pipe, pipe 的函数执行方向刚好与
compose 相反. 比如 <code>pipe(f, g)</code>, <code>f</code> 会先执行, 然后结果传给 <code>g</code>,
是不是让你想起了 bash 的 pipe
</p>

<pre class="example" id="orgf1d7319">
find / | grep porno
</pre>

<p>
实际上就是 <code>pipe(find, grep(porno))(/)</code>
</p>

<p>
没错,他们都是一个意思. 而且这个函数执行的方向更适合人脑编译(可读)一些.
</p>

<p>
如果你已经习惯 underscore 的这种写法
</p>

<pre class="code"><code>_(data)
  .chain()
  .map(data1,fn1)
  .filter(data2, fn2)
  .value()
</code></pre>

<p>
那么转换成 pipe 是很容易的一件事情，而且更简单明了易于重用和组合。
</p>

<pre class="code"><code>pipe(
  map(fn1),
  filter(fn2)
)(data)
</code></pre>

<a class="jsbin-embed" href="https://jsbin.com/hivaje/2/embed?js,console">完整代码</a><script src="https://static.jsbin.com/js/embed.js"></script>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd96bfe5" class="outline-2">
<h2 id="orgd96bfe5"><span class="section-number-2">4.</span> Transducers</h2>
<div class="outline-text-2" id="text-4">
<p>
通过上一篇<a href="./clojure-core.async-essence-in-native-javascript.html">Clojure风格的JavaScript并发编程</a>介绍了如何用JavaScript享受到Clojure在并发编程的优势. 我决定
写一系列关于如何用JavaScript玩转Clojure大法的文章. 这回要用JavaScript玩转另一个
Clojure全新的概念 &#x2013; <i>Transducer</i>.
</p>

<p>
Transducer 是 Rich Hickey<label for="6" class="margin-toggle sidenote-number"></label><input type="checkbox" id="6" class="margin-toggle"/><span class="sidenote">
Clojure的作者
</span> <a href="http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming">高调宣布</a> 的在Clojure 1.7 版本加入的又一大法. 在之前的另一个概念
<a href="http://clojure.com/blog/2012/05/15/anatomy-of-reducer.html">Reducer</a> 却没那么 <b>高调</b>. 在解释transducer之前, 先看看什么是Reducer, 如果能看懂, 再接着看Transducer.
</p>
</div>

<div id="outline-container-orgbfe0537" class="outline-3">
<h3 id="orgbfe0537"><span class="section-number-3">4.1.</span> Reducer</h3>
<div class="outline-text-3" id="text-4-1">
<p>
说道reduce这个词, 想必JS Developer大多会用过underscore<label for="7" class="margin-toggle sidenote-number"></label><input type="checkbox" id="7" class="margin-toggle"/><span class="sidenote">
我是故意吧reduce的参数顺序写"反"的, 原来underscore是先消费collection的. 至于为什么要反过来
可以参考<a href="https://blog.oyanglul.us/javascript/functional-javascript.html#sec-3-2">这个解释</a>
</span>(或类似)的reduce方法, 大概形式是这样
</p>
<pre class="code"><code>_.reduce(fn, 0, [1,2,3])
</code></pre>
<p>
大概意思是初始为0, 应用fn到每一个collection(检测coll)元素上,得到一个新的值.
</p>

<p>
如果加上map, 比如(我要开始用<a href="https://github.com/swannodette/mori">mori</a><label for="8" class="margin-toggle sidenote-number"></label><input type="checkbox" id="8" class="margin-toggle"/><span class="sidenote">
clojurescript作者把clojurescript的一些数据结构和函数编译成javascript, 这样就可以用普通js使用
clojure中的数据结构和函数. document严重过时, 建议看导入的<a href="https://github.com/swannodette/mori/blob/master/src/mori.cljs">源代码</a>, 以及clojure的文档, 接口和clojure基本一致.
</span> 了)
</p>
<pre class="code"><code>reduce(sum, 0, map(inc [1,2,3]))
</code></pre>

<div class="epigraph"><blockquote>
<p>
Terminology:
</p>
<ol class="org-ol">
<li>reducing 函数: 用来reduce的函数, 比如sum</li>
<li>transform: 变换, 从一个函数变另一个函数</li>
<li>xf: xform, transform 函数</li>
<li>reducible: 可被reduce的,也就是实现reduce接口的,比如所有的collection</li>
</ol>

</blockquote></div>

<p>
让我们一步一步分析一下这次reduce到底干了什么
</p>
<ol class="org-ol">
<li>map 函数 inc 到 coll 每一个元素, 得到一个新的 coll <code>[2,3,4]</code></li>
<li>reduce 把新coll的每个元素用sum函数, 得到一个新的值.</li>
</ol>

<p>
好吧这就是reduce了, 用一个reducing函数sum去计算coll得出一个新的值.
</p>

<p>
来看看更好的解法
</p>
</div>
<div id="outline-container-org71dbcb7" class="outline-4">
<h4 id="org71dbcb7"><span class="section-number-4">4.1.1.</span> transform</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
reduce函数需要等待map返回新的coll后才能reduce, 那么可不可以一步直接算出来呢?
</p>

<p>
假如我们有一个函数xf可以变换reducing函数(上例的sum是reducing函数)的形式, 比如
</p>
<pre class="example" id="org13356bb">
xf(reduceFn) -&gt; anotherReduceFn
</pre>

<p>
再假如我们的新map函数可以做这种转换
</p>
<pre class="code"><code>map(inc)(sum) -&gt; aShinyNewReduceFn
</code></pre>

<div class="epigraph"><blockquote>
<p>
map 函数的简单transform实现可以这样实现,如果你感兴趣的话
</p>
<pre class="code"><code><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">map</span>(<span style="color: #b8860b;">fn</span>){
  <span style="color: #00008b;">return</span> <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">reduceFn</span>){
    <span style="color: #00008b;">return</span> <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">result</span>, <span style="color: #b8860b;">input</span>){
      reduceFn(result, fn(input))
    }
  }
}
</code></pre>

</blockquote></div>

<p>
那么我们之前的reduce就可以写成
</p>

<pre class="code"><code>reduce(map(inc)(sum),0,[1,2,3])
</code></pre>

<p>
yeah, 现在只需要一步就reduce出来结果了, reduce应用 <code>map(inc)(sum)</code> 来计算值, 只需要遍历一遍coll
</p>
</div>
</div>

<div id="outline-container-org5444796" class="outline-4">
<h4 id="org5444796"><span class="section-number-4">4.1.2.</span> <a href="https://clojure.org/reducers">Reducer</a></h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
但是如果我们不想改变map函数的接口, 原始形式的接口还是比较好写好读的
</p>
<pre class="code"><code>reduce(sum, 0, map(inc [1,2,3]))
</code></pre>
<p>
那么需要进一步的抽象, 我把新的map函数叫做rmap好了
</p>
<pre class="code"><code><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">rmap</span>(<span style="color: #b8860b;">fn</span>, <span style="color: #b8860b;">coll</span>){
  reducer(coll, map(fn))
}
</code></pre>
<p>
跟以前接口一样,接收函数和coll,但是返回一个由reducer生成的reducible, 所以就变成了
</p>
<pre class="code"><code>reduce(sum, 0, reducer([1,2,3], map(inc)))
</code></pre>

<p>
等等,怎么做到的&#x2026;你已经消费了coll了, 那reducing函数怎么进来的, reducer怎么知道用sum去reduce呢.
</p>
</div>


<div id="outline-container-org18e2277" class="outline-5">
<h5 id="org18e2277">Reducible</h5>
<div class="outline-text-5" id="text-org18e2277">
<p>
答案是, 反转reduce的关系, 原来reduce用sum去计算结果, 现在,我们调用reducible的reduce方法来计算结果
</p>


<figure id="org10b5b7b">
<img src="./images/came-out.gif" alt="came-out.gif">

</figure>

<p>
如果你还没有被我弄晕的话, 准备好, 又来一个新单词 <i>reducible</i>. 也就是可以被reduce的东西.
</p>

<p>
于是我们需要coll实现reduce方法,这样就成为reducible了.
</p>

<p>
也就是reduce函数现在应该长这样, 我们暂且叫它 <code>rreduce</code>
</p>
<pre class="code"><code><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">rreduce</span>(<span style="color: #b8860b;">reduceFn</span>, <span style="color: #b8860b;">init</span>, <span style="color: #b8860b;">reducible</span>){
  reducible(reduceFn, init)
}
</code></pre>
<p>
那么我们的例子就变成了这样
</p>
<pre class="code"><code>reducer([1,2,3], map(inc))(sum, 0)
</code></pre>
<p>
reducer接收coll和xf, 返回reducible函数. 这一切都是lazy的, 直到rreduce调用<a href="#coderef-coll" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-coll');" onmouseout="CodeHighlightOff(this, 'coderef-coll');">第coll行</a>才执行.
</p>
<pre class="code"><code><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">reducer</span>(<span style="color: #b8860b;">coll</span>, <span style="color: #b8860b;">xf</span>){
  <span style="color: #00008b;">return</span> <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">reduceFn</span>, <span style="color: #b8860b;">init</span>){
<span id="coderef-coll" class="coderef-off">    <span style="color: #00008b;">return</span> coll.reduce(xf(reduceFn), init) (coll)</span>
  }
}
</code></pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org362ac0c" class="outline-3">
<h3 id="org362ac0c"><span class="section-number-3">4.2.</span> Transducer</h3>
<div class="outline-text-3" id="text-4-2">
<p>
说了半天Reducer,明明说好的要解释的Transducer呢?
</p>

<p>
如果你还能follow, 那么现在要开始解释Transducer了
</p>

<p>
其实你已经见过Transducer了, 再回顾一下之前说的Reducer
</p>
<ol class="org-ol">
<li>接收一个xf函数和一个coll</li>
<li>用xf转换reducing函数, 并应用到coll</li>
</ol>

<p>
Transducer就是那个xf
</p>
<pre class="code"><code>reduce(map(inc)(sum),0,[1,2,3])
</code></pre>
<p>
也就是这里面的 <code>map(inc)</code>
</p>

<p>
靠, 就这么简单?
</p>

<p>
就是这么简单, 前面说了reducer的出现是因为想保持原始reduce的api不便, 那么tranducer则提供了
另外一种reduce api
</p>

<pre class="code"><code>transduce(map(inc), sum, 0, [1,2,3])
</code></pre>
<p>
transduce接收一个transducer,一个reducing function, 一个初始值, 一个coll. 这段代码跟前面干的事情一模一样.
</p>

<p>
另外牛逼的是transducer跟context完全没有关系, 就是完全与数据解耦开来, 比如我们组装好一个transducer xf
</p>

<p>
可以用在任何地方
</p>
<pre class="code"><code>seq(xf data) <span style="color: #8c8c8c; font-style: italic;">//</span><span style="color: #8c8c8c; font-style: italic;">&#29983;&#25104;&#19968;&#20010;lazy&#30340;&#24207;&#21015;, &#21516;&#26102;lazy transform, &#27599;&#27425;&#21462;&#30340;&#26102;&#20505;data&#20250;&#34987;transform</span>
into([], xf data) <span style="color: #8c8c8c; font-style: italic;">//</span><span style="color: #8c8c8c; font-style: italic;">&#25226; data transform&#21518;&#25918;&#21040;&#19968;&#20010;&#25968;&#32452;&#37324;</span>
chan(1, xform) <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">&#24403;&#25968;&#25454;&#32463;&#36807;CSP&#30340;channel&#26102;&#34987;transform</span>
</code></pre>
</div>
</div>


<div id="outline-container-org9b5d2eb" class="outline-3">
<h3 id="org9b5d2eb"><span class="section-number-3">4.3.</span> Is it Curry?</h3>
<div class="outline-text-3" id="text-4-3">
<p>
怎么看着有点像柯里化, 一样么?
</p>

<p>
当然不是, 柯里化或者部分参数只是部分配置参数, 而transducer是一次多n次转换的组合
</p>

<p>
比如一个柯里化的map可以
</p>
<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">mapinc</span> = map(inc)
mapinc([1,2,3])
</code></pre>

<p>
而不能
</p>
<pre class="code"><code>mapinc(sum)
</code></pre>
<p>
因为map就俩参数, 第一个是函数第二个是data, 如果再给data会错误
</p>

<p>
但是tranceducer只是转换, 所以只接受reducing函数
</p>
<pre class="code"><code>reduce(mapinc(sum), 0, [1,2,3])
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; 9</span>
</code></pre>
</div>
</div>

<div id="outline-container-org1fb9d37" class="outline-3">
<h3 id="org1fb9d37"><span class="section-number-3">4.4.</span> 完整例子</h3>
<div class="outline-text-3" id="text-4-4">
<a class="jsbin-embed" href="https://jsbin.com/sulaxe/1/embed?html,js,console">JS Bin</a><script src="https://static.jsbin.com/js/embed.js"></script>
</div>
</div>
</div>

<div id="outline-container-orge261dbb" class="outline-2">
<h2 id="orge261dbb"><span class="section-number-2">5.</span> Functor</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orga5be50c" class="outline-3">
<h3 id="orga5be50c"><span class="section-number-3">5.1.</span> Functor</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Functor 是 可以被 map over 的类型. 什么叫 map over&#x2026;
</p>

<p>
比如 list 就可以说是可以被map over&#x2026; 那么是不是可枚举类型?
</p>

<p>
不是的, 来看看 Haskell 中如何解释(其实所有函数式的概念可能用 haskell
是最能说明问题的了).
</p>

<pre class="code"><code>ghci <span style="color: #6a5acd;">&gt;</span> <span style="color: #36648b;">:</span>t fmap
<span style="color: #6a5acd;">fmap</span> <span style="color: #b8860b;">::</span> (a <span style="color: #b8860b;">-&gt;</span> b) <span style="color: #b8860b;">-&gt;</span> fa <span style="color: #b8860b;">-&gt;</span> f b
</code></pre>

<p>
<code>fmap</code> 又是什么东西, fmap 是 map over Functor 的函数.
这个函数只干一个事情, 可能通过前面解释的一点点
Haskell功夫,你可能能翻译 <code>(a -&gt; b) -&gt; fa -&gt; f b</code> 了把. 给定一个从 <code>a</code> 到 <code>b</code>
的映射函数, 再给定一个 a 的 Functor, 返回一个 b 的 Functor.
</p>

<p>
虽然个个字都认识, 但怎么就不知道啥意思.
</p>

<p>
如果我再说一个新词, 你是不是会疯掉了&#x2013; Lift.
</p>

<p>
好吧, 把他们都串起来, 你就明白了. 
</p>
<ol class="org-ol">
<li>平常我们可以把 <code>a</code> 到 <code>b</code> 的映射可以叫做 map, 映射的方式就是函数了.</li>
<li>那么类似的对于函数或者其他可以做这种 map 操作的类型或一种计算方式, 叫做 Functor.</li>
<li>而这种 map 就叫做 fmap, 给定 a 集合到 b 集合的映射方式(也就是一个函数), 就能找到 对 a 的一种计算(computation, 任何可变换的类型, 这就是 Functor) 的变换 &#x2013; 对 b 的对应计算方式.</li>
<li>如果该计算是一个函数, 那么这个操作叫做 lifting. 非常形象的, 根据 a 到 b 的映射 lift(举) 到另一个层面上.</li>
</ol>


<figure id="orge72cf16">
<img src="https://learnyouahaskell-zh-tw.csie.org/img/lifter.png" alt="lifter.png">

</figure>

<p>
虽然 lifting 很形象, 但是还是越说越抽象了, 来举个栗子. 
</p>
</div>
</div>
<div id="outline-container-org275921a" class="outline-3">
<h3 id="org275921a"><span class="section-number-3">5.2.</span> 举个栗子🌰</h3>
<div class="outline-text-3" id="text-5-2">
<div class="epigraph"><blockquote>
<p>
注意我们还没有实现 Functor, 因此下面的栗子还不能运行在你的
console.
</p>

</blockquote></div>

<p>
前面说了, Functor 可以是数组, 因为数组可以被 map over
</p>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">plus1</span> = n =&gt; n+1;
fmap(plus1, [2, 4, 6, 8])<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; [3,5,7,9]</span>
</code></pre>

<p>
这里,数组 Array 就是 Functor 类型, 而 fmap 把 2 -&gt; 3 的映射方式对 Array
[2,4,6,8] 进行了变换, 得到 [3,5,7,9]. 这跟数组的 map 方法一样,
比较好理解.
</p>

<p>
再试试换一种 Functor 类型, 试试函数
</p>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">times2</span> = m =&gt; m*2;
fmap(plus1, times2) <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; function(){}</span>
fmap(plus1, times2)(3) <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; 7 (3*2+1)</span>
</code></pre>

<p>
看到 fmap 返回的是一个函数, 因为你 map over 的是一个函数 <code>times2</code>. 还记得
<code>(a -&gt; b) -&gt; f a -&gt; f b</code> 的公式么, 因为现在的 Functor 为 Function 类型,
我们可以把=f=替换成函数也就是 x 到 y 的映射, 因此我们可以将该公式替换为
</p>

<pre class="example" id="org64bb78c">
(a -&gt; b) -&gt; (x -&gt; a) -&gt; (x -&gt; b)
</pre>

<p>
再用我们具体的函数 plus1 替换进去
</p>

<pre class="example" id="orgcf6537d">
(n-&gt;n*2) -&gt; plus1(n) -&gt; plus1(n*2)
</pre>

<p>
也就是说, 这个 fmap 会把函数 times2 应用到 plus1 的任何结果上.
</p>

<p>
这不就是函数组合吗 <code>plus1(times2(3))</code>, 确实是的. 但这只是 Functor
的冰山一角, dan在来看看别的Functor
</p>

<p>
Functor 还可以是别的东西&#x2026;比如
</p>

<pre class="example" id="org55ae5a4">
fmap(plus1, Either(10, 20))
</pre>

<p>
Either也是 Functor, 慢着, Either 是什么类型, 好吧,在解释 Either 之前,
我们先忍一忍, 来先看看 JavaScript 中怎么实现以及使用一个 Functor.
</p>
</div>
</div>

<div id="outline-container-org6ab7600" class="outline-3">
<h3 id="org6ab7600"><span class="section-number-3">5.3.</span> Functor in JavaScript</h3>
<div class="outline-text-3" id="text-5-3">
<p>
首先, 我们用定义一个确定 Functor 类型的函数, 如果没有注册的类型抛出异常.
</p>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">types</span> = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">obj</span>) {
  <span style="color: #00008b;">throw</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">TypeError</span>(<span style="color: #8b0000;">"fmap called on unregistered type: "</span> + obj);
};
</code></pre>

<p>
然后实现注册 Functor 的函数.
</p>

<pre class="code"><code> Functor = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">type</span>, <span style="color: #b8860b;">defs</span>) {
        <span style="color: #00008b;">var</span> <span style="color: #b8860b;">oldTypes</span> = types;
        types = (obj) =&gt; {
            <span style="color: #00008b;">if</span> (type.<span style="color: #6b8e23;">prototype</span>.isPrototypeOf(obj)) {
                <span style="color: #00008b;">return</span> defs; <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">&#36825;&#26159;&#36882;&#24402;&#30340;&#20986;&#21475;, &#21028;&#26029;&#31867;&#22411;, &#30830;&#23450; fmap &#30340; Functor &#23454;&#20363;&#23646;&#20110;&#27880;&#20876;&#30340;&#21738;&#19968;&#20010; Functor</span>
            }
            <span style="color: #00008b;">return</span> oldTypes(obj); <span style="color: #8c8c8c; font-style: italic;">//</span><span style="color: #8c8c8c; font-style: italic;">&#19981;&#26029;&#36882;&#24402;&#23547;&#25214; types, &#36825;&#20010;&#25928;&#29575;&#20250;&#24456;&#20302;, &#22240;&#20026;&#35843;&#29992;&#26632;&#19978;&#22909;&#22810;&#38381;&#21253;, &#27599;&#20010;&#38381;&#21253;&#37117;&#20445;&#25345;&#30528; type &#21644; defs</span>
        }
};
</code></pre>

<p>
这样可以用 Functor 函数注册一个新的 Functor 类型并定义它自己的 fmap
方法(还记得前面说的 Functor 只有一个方法吗). 比如我们要把 Array 变成
Functor
</p>

<pre class="code"><code>Functor(Array, {
    fmap: (fn, array) =&gt; {
        arr.map(x =&gt; fn(x))
    }
})
</code></pre>

<p>
好像快要完成的样子. 现在还差 fmap Functor 类型函数了.
这个函数干两件事情, 找到实例属于哪个 Functor 类型, 并调用他的 fmap 方法.
</p>

<pre class="code"><code>fmap = eweda.curry((fn, obj) =&gt; {
    <span style="color: #00008b;">return</span> types(obj).fmap(f, obj)
})
</code></pre>

<p>
同样的, 我们很快可以把 Function 也变成 Functor
</p>

<pre class="code"><code>Functor(Function, {
    fmap: (f, g) =&gt; {
        <span style="color: #00008b;">return</span> eweda.compose(f, g);
}})
</code></pre>

<p>
还记得前面说 fmap 函数像函数组合吗, 呵呵, 我们这里就按函数组合实现.
</p>

<hr>

<p>
来总结一下 fmap 和 Functor 到底是什么, fmap 可以将函数应用到 Functor 上,
Functor 可以看做是容器或者是带 context 的值. 也就是说如果我们想变换 x
的值, 直接给一个函数映射 <code>x=&gt; x*2</code> 即可. 如果我想变换一个数组, 一个函数,
或者 Either 这种带有 context 的或者说容器里面的值,
总不能直接把这些容器直接给函数吧，这时就需要 fmap
将函数的映射关系应用到容器里面的值.
其实就是打开，调一下函数，完了再包好。
</p>

<p>
好吧, 通过如何实现和使用一个简单的 Functor, 概念上已经估计可以理解了,
我们回过头来看看 Either 是神马玩意.
</p>

<p>
<a href="https://jsbin.com/xezun/1/embed?js,console">完整代码</a>
</p>
</div>
</div>
</div>
<div id="outline-container-org4f73a27" class="outline-2">
<h2 id="org4f73a27"><span class="section-number-2">6.</span> Monad</h2>
<div class="outline-text-2" id="text-6">
<p>
这个概念好难解释, 你可以理解为一个 Lazy 或者是状态未知的盒子.
听起来像是<a href="https://zh.wikipedia.org/wiki/%E8%96%9B%E5%AE%9A%E8%B0%94%E7%8C%AB">薛定谔猫</a>(估计点进去你会更晕了).
其实就是的, 在你打开这个盒子之前, 你是不知道里面的猫处在那种状态.
</p>

<p>
Monad 这个黑盒子, 里面到底卖的神马药,我们要打开喝了才知道.
</p>

<p>
等等, 不是说好要解释 Either 的吗, 嗯嗯, 这里就是在解释 Either. 上节说
Either 是一个 Functor, 可以被 fmap over. 怎么这里又说道黑盒子了? 好吧,
Monad 其实也是 Functor. 还记得我说的 Functor 其实是一个带 context
的盒子吗. 而 fmap 使得往盒子里应用函数变换成为了可能.
</p>
</div>

<div id="outline-container-org8dec7d7" class="outline-3">
<h3 id="org8dec7d7"><span class="section-number-3">6.1.</span> Either</h3>
<div class="outline-text-3" id="text-6-1">
<p>
先来看看 Either 这种类型会干什么事情.
<a href="https://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Either.html#t:Either">Either</a>表示要不是左边就是右边的值,
因此我们可以用它来表示薛定谔猫, 要不是活着, 要不死了. Either 还有个方法:
either
</p>

<pre class="example" id="org65b6d28">
(a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c
</pre>

<p>
想必你已经对箭头 <code>-&gt;</code> 非常熟了吧.如果前面几章你都跳过了,我再翻译下好了.
这里表示接收函数 <code>a-&gt;c</code> 和函数 <code>b-&gt;c</code>, 再接收一个 Either, 如果 Either
的值在左边,则使用函数映射 <code>a-&gt;c</code>, 若值在右边,则应用第二个函数映射 <code>b-&gt;c</code>.
</p>

<p>
作为 Monad, 它还必须具备一个方法 '&gt;&gt;='(这个符号好眼熟的说, 看看 haskell
的 logo, 你就知道 Monad 是有多重要), 也就是 bind 方法.
</p>


<figure id="orgde4a6ac">
<img src="https://www.haskell.org/wikistatic/haskellwiki_logo.png" alt="haskellwiki_logo.png">

</figure>

<p>
bind 方法的意思很简单, 就是给这个盒子加一个操作,
比如往盒子在加放射性原子,如果猫活着,就是绿巨猫,
如果猫是死的,那就是绿巨死猫.
</p>

<pre class="code"><code>Left(<span style="color: #8b0000;">"cat"</span>).bind(cat =&gt; Right(<span style="color: #8b0000;">'hulk'</span>+cat))
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; Left "hulkcat"</span>
Right(<span style="color: #8b0000;">"deadcat"</span>).bind(cat =&gt; Left(<span style="color: #8b0000;">'hulk'</span> + cat))
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; Right "hulkdeadcat"</span>
</code></pre>

<p>
这有个毛用啊. 表急&#x2026; 来看个经典例子 
</p>
</div>
</div>

<div id="outline-container-orgffb6c2b" class="outline-3">
<h3 id="orgffb6c2b"><span class="section-number-3">6.2.</span> 走钢索</h3>
<div class="outline-text-3" id="text-6-2">
<p>
皮尔斯决定要辞掉他的工作改行试着走钢索。他对走钢索蛮在行的，不过仍有个小问题。就是鸟会停在他拿的平衡竿上。他们会飞过来停一小会儿，然后再飞走。这样的情况在两边的鸟的数量一样时并不是个太大的问题。但有时候，所有的鸟都会想要停在同一边，皮尔斯就失去了平衡，就会让他从钢索上掉下去。
</p>


<figure id="org0d28e83">
<img src="https://learnyouahaskell-zh-tw.csie.org/img/pierre.png" alt="pierre.png">

</figure>

<p>
我们这边假设两边的鸟差异在三个之内的时候，皮尔斯仍能保持平衡。
</p>
</div>

<div id="outline-container-org1728e35" class="outline-4">
<h4 id="org1728e35"><span class="section-number-4">6.2.1.</span> 一般解法</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
首先看看不用 Monad 怎么解
</p>

<pre class="code"><code>eweda.installTo(<span style="color: #6b8e23;">this</span>);
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">landLeft</span> = eweda.curry(<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">n</span>, <span style="color: #b8860b;">pole</span>){
    <span style="color: #00008b;">return</span> [pole[0]+n, pole[1]];
});
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">landRight</span> = eweda.curry(<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">n</span>, <span style="color: #b8860b;">pole</span>){
    <span style="color: #00008b;">return</span> eweda.reverse(landLeft(n, eweda.reverse(pole)));
});
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">result</span> = eweda.pipe(landLeft(1), landRight(1), landLeft(2))([0,0]);
console.log(result);
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; [3, 1]</span>
</code></pre>

<p>
还差一个判断皮尔斯是否掉下来的操作.
</p>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">landLeft</span> = eweda.curry(<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">n</span>, <span style="color: #b8860b;">pole</span>){
    <span style="color: #00008b;">if</span>(pole===<span style="color: #8b0000;">'dead'</span>) <span style="color: #00008b;">return</span> pole;
    <span style="color: #00008b;">if</span>(Math.abs(pole[0]-pole[1]) &gt; 3)
      <span style="color: #00008b;">return</span> <span style="color: #8b0000;">'dead'</span>;
    <span style="color: #00008b;">return</span> [pole[0]+n, pole[1]];
});
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">landRight</span> = eweda.curry(<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">n</span>, <span style="color: #b8860b;">pole</span>){
    <span style="color: #00008b;">if</span>(pole===<span style="color: #8b0000;">'dead'</span>) <span style="color: #00008b;">return</span> pole;
    <span style="color: #00008b;">return</span> eweda.reverse(landLeft(n, eweda.reverse(pole)));
});
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">result</span> = eweda.pipe(landLeft(10), landRight(1), landRight(8))([0,0]);
console.log(result);
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; dead</span>
</code></pre>

<p>
<a href="https://jsbin.com/pozim/8/watch?js,console,output">完整代码</a>
</p>

<hr>
</div>
</div>

<div id="outline-container-org074fc4b" class="outline-4">
<h4 id="org074fc4b"><span class="section-number-4">6.2.2.</span> 现在来试试用 Either</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
我们先把皮尔斯放进 Either 盒子里, 这样皮尔斯的状态只有打开 Either
才能看见. 假设 Either Right 是活着, Left 的话皮尔斯挂了.
</p>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">land</span> = eweda.curry(<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">lr</span>, <span style="color: #b8860b;">n</span>, <span style="color: #b8860b;">pole</span>){
    pole[lr] = pole[lr] + n;
    <span style="color: #00008b;">if</span>(Math.abs(pole[0]-pole[1]) &gt; 3) {
      <span style="color: #00008b;">return</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">Left</span>(<span style="color: #8b0000;">"dead when land "</span> + n + <span style="color: #8b0000;">" became "</span> + pole);
    }
    <span style="color: #00008b;">return</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">Right</span>(pole);
});

<span style="color: #00008b;">var</span> <span style="color: #b8860b;">landLeft</span> = land(0)
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">landRight</span> = land(1);
</code></pre>

<p>
现在落鸟后会返回一个 Either, 要不活着, 要不挂了.
打开盒子的函数可以是这样的
</p>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">stillAlive</span> = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">x</span>){
    console.log(x)
}
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">dead</span> = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">x</span>){
    console.log(<span style="color: #8b0000;">'&#30382;&#23572;&#26031;'</span> + x);
}
either(dead, stillAlive, landLeft(2, [0,0]))
</code></pre>

<p>
好吧, 好像有一点点像了, 但是这只落了一次鸟, 如果我要落好几次呢.
这就需要实现 Either 的 &gt;&gt;= bind 方法了, 如果你还记得前面实现的 Functor,
这里非常像 :
</p>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">Monad</span> = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">type</span>, <span style="color: #b8860b;">defs</span>) {
  <span style="color: #00008b;">for</span> (name <span style="color: #00008b;">in</span> defs){
    type.<span style="color: #6b8e23;">prototype</span>[name] = defs[name];
  }
  <span style="color: #00008b;">return</span> type;
};
<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">Left</span>(<span style="color: #b8860b;">value</span>){
  <span style="color: #6b8e23;">this</span>.value = value
}
<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">Right</span>(<span style="color: #b8860b;">value</span>){
  <span style="color: #6b8e23;">this</span>.value=value;
}

Monad(Right, {
  <span style="color: #6a5acd;">bind</span>:<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">fn</span>){
    <span style="color: #00008b;">return</span> fn(<span style="color: #6b8e23;">this</span>.value)
  }
})

Monad(Left, {
  <span style="color: #6a5acd;">bind</span>: <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">fn</span>){
    <span style="color: #00008b;">return</span> <span style="color: #6b8e23;">this</span>;
  }
})
</code></pre>

<p>
哦, 对了, either:
</p>

<pre class="code"><code>either = <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">left</span>, <span style="color: #b8860b;">right</span>, <span style="color: #b8860b;">either</span>){
    <span style="color: #00008b;">if</span>(either.constructor.name === <span style="color: #8b0000;">'Right'</span>)
        <span style="color: #00008b;">return</span> right(either.value)
    <span style="color: #00008b;">else</span>
        <span style="color: #00008b;">return</span> left(either.value)
}
</code></pre>

<p>
我们来试试工作不工作.
</p>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">walkInLine</span> = <span style="color: #00008b;">new</span> <span style="color: #36648b;">Right</span>([0,0]);
eitherDeadOrNot = walkInLine.bind(landLeft(2))
    .bind(landRight(5))
either(dead, stillAlive, eitherDeadOrNot)
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; [2,5]</span>
eitherDeadOrNot = walkInLine.bind(landLeft(2))
  .bind(landRight(5))
  .bind(landLeft(3))
  .bind(landLeft(10)
  .bind(landRight(10)))

either(dead, stillAlive, eitherDeadOrNot)
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; "&#30382;&#23572;&#26031;dead when land 10 became 15,5"</span>
</code></pre>

<p>
<a href="https://jsbin.com/giyig/3/watch">完整代码</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org27af63c" class="outline-3">
<h3 id="org27af63c"><span class="section-number-3">6.3.</span> 到底有什么用呢, Monad</h3>
<div class="outline-text-3" id="text-6-3">
<p>
我们来总结下两种做法有什么区别:
</p>

<ol class="org-ol">
<li>一般做法每次都会检查查尔斯挂了没挂, 也就是重复获得之前操作的 context</li>
<li>Monad 不对异常做处理, 只是不停地往盒子里加操作. 你可以看到对错误的处理推到了最后取值的 either.</li>
<li>Monad 互相传递的只是盒子, 而一般写法会把异常往下传如 <code>dead</code>, 这样导致后面的操作都得先判断这个异常.</li>
</ol>

<div class="epigraph"><blockquote>
<p>
由于是用 JavaScript, pole 不限定类型,
所以这里单纯的用字符串代表 pole 的异常状态. 但如果换成强类型的 Java,
可能实现就没这么简单了.
</p>

</blockquote></div>

<p>
看来已经优势已经逐步明显了呢, Monad 里面保留了值的 context,
也就是我们对这个 Monad 可以集中在单独的本次如何操作value, 而不用关心
context.
</p>

<div class="epigraph"><blockquote>
<p>
还有一个 Monad 叫做 Maybe, 实际上皮尔斯的🌰用 Maybe 更为合适, 因为
Maybe 有两种状态, 一种是有值 Just, 一种是没东西 Nothing,
可以自己实现试试.
</p>

</blockquote></div>
</div>
</div>

<div id="outline-container-org276320c" class="outline-3">
<h3 id="org276320c"><span class="section-number-3">6.4.</span> Monad 在 JavaScript 中的应用</h3>
<div class="outline-text-3" id="text-6-4">
<p>
你知道 ES6有个新的 类型
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#Browser_compatibility">Promise</a>
吗, 如果不知道, 想必也听过 jQuery 的 <code>$.ajax</code> 吧, 但如果你没听过 promise,
说明你没有认真看过他的返回值:
</p>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">aPromise</span> = $.ajax({
    url: <span style="color: #8b0000;">"https://api.github.com/users/jcouyang/gists"</span>
    dataType: <span style="color: #8b0000;">'jsonp'</span>
    })
aPromise <span style="color: #8b0000;">/***</span>
<span style="color: #8b0000;">=&gt; Object { state: .Deferred/r.state(),</span>
<span style="color: #8b0000;">    always: .Deferred/r.always(),</span>
<span style="color: #8b0000;">    then: .Deferred/r.then(),</span>
<span style="color: #8b0000;">    promise: .Deferred/r.promise(),</span>
<span style="color: #8b0000;">    pipe: .Deferred/r.then(),</span>
<span style="color: #8b0000;">    done: b.Callbacks/p.add(),</span>
<span style="color: #8b0000;">    fail: b.Callbacks/p.add(),</span>
<span style="color: #8b0000;">    progress: b.Callbacks/p.add() }</span>
<span style="color: #8b0000;">***/</span>
</code></pre>

<p>
我们看到返回了好多 <code>Deferred</code> 类型的玩意, 我们来试试这玩意有什么用
</p>

<pre class="code"><code>anotherPromise = aPromise.then(_ =&gt; _.data.forEach(y=&gt; console.log(y.description)))
<span style="color: #8c8c8c; font-style: italic;">/* </span><span style="color: #8c8c8c; font-style: italic;">=&gt;</span>
<span style="color: #8c8c8c; font-style: italic;">Object { state: .Deferred/r.state(),</span>
<span style="color: #8c8c8c; font-style: italic;">    always: .Deferred/r.always(),</span>
<span style="color: #8c8c8c; font-style: italic;">    then: .Deferred/r.then(),</span>
<span style="color: #8c8c8c; font-style: italic;">    promise: .Deferred/r.promise(),</span>
<span style="color: #8c8c8c; font-style: italic;">    pipe: .Deferred/r.then(),</span>
<span style="color: #8c8c8c; font-style: italic;">    done: b.Callbacks/p.add(),</span>
<span style="color: #8c8c8c; font-style: italic;">    fail: b.Callbacks/p.add(),</span>
<span style="color: #8c8c8c; font-style: italic;">    progress: b.Callbacks/p.add() }</span>

<span style="color: #8c8c8c; font-style: italic;">"connect cisco anyconnect in terminal"</span>
<span style="color: #8c8c8c; font-style: italic;">"&#20026;&#20160;&#20040;&#35201;&#26607;&#37324;&#21270;&#65288;curry&#65289;"</span>
<span style="color: #8c8c8c; font-style: italic;">"&#25209;&#37327;&#33719;&#21462;&#20154;&#20154;&#24433;&#35270;&#19979;&#36733;&#38142;&#25509;"</span>
<span style="color: #8c8c8c; font-style: italic;">......</span>
<span style="color: #8c8c8c; font-style: italic;">*/</span>
</code></pre>

<p>
看见没有, 他又返回了同样一个东西, 而且传给 then
的函数可以操作这个对象里面的值. 这个对象其实就是 Promise 了.
为什么说这是 Monad 呢, 来试试再写一次 <code>走钢丝</code>:
</p>

<div class="epigraph"><blockquote>
<p>
这里我们用的是 ES6 的 Promise, 而不用 jQuery Defered, 记得用 firefox
哦. 另外 eweda 可以这样装
</p>

</blockquote></div>

<pre class="example" id="org1e1f3e2">
var ewd = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            ewd.src = 'https://rawgit.com/CrossEye/eweda/master/eweda.js';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ewd);
eweda.installTo(this);
</pre>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">land</span> = eweda.curry(<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">lr</span>, <span style="color: #b8860b;">n</span>, <span style="color: #b8860b;">pole</span>){
    pole[lr] = pole[lr] + n;
    <span style="color: #00008b;">if</span>(Math.abs(pole[0]-pole[1]) &gt; 3) {
      <span style="color: #00008b;">return</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">Promise</span>((resovle,reject)=&gt;reject(<span style="color: #8b0000;">"dead when land "</span> + n + <span style="color: #8b0000;">" became "</span> + pole));
    }
    <span style="color: #00008b;">return</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">Promise</span>((resolve,reject)=&gt;resolve(pole));
});

<span style="color: #00008b;">var</span> <span style="color: #b8860b;">landLeft</span> = land(0)
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">landRight</span> = land(1);

Promise.all([0,0])
.then(landLeft(2), _=&gt;_)
.then(landRight(3), _=&gt;_) <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; Array [ 2, 3 ]</span>
.then(landLeft(10), _=&gt;_)
.then(landRight(10), _=&gt;_)
.then(_=&gt;console.log(_),_=&gt;console.log(_))
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; "dead when land 10 became 12,3"</span>
</code></pre>

<p>
这下是不承认 Promise 就是 Monad 了. 原来我们早已在使用这个神秘的 Monad,
再想想 Promise,也没有那么抽象和神秘了.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Fogus同时是The Joy of Clojure的作者,我
特别奇怪为什么不把Clojure真正Good part写进Functional JavaScript里
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
第二章会详细解释高阶函数和闭包.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
柯里化会在第二章详细讨论.
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
可以看看es6比较有意思的新特性 <a href="https://blog.oyanglul.us/javascript/essential-ecmascript6.html">https://blog.oyanglul.us/javascript/essential-ecmascript6.html</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
Chrome有一个 feature toggle 可以打开部分 es6 功能 <code>chrome://flags/#enable-javascript-harmony</code>
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6">6</a></sup> <div class="footpara"><p class="footpara">
Clojure的作者
</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7">7</a></sup> <div class="footpara"><p class="footpara">
我是故意吧reduce的参数顺序写"反"的, 原来underscore是先消费collection的. 至于为什么要反过来
可以参考<a href="https://blog.oyanglul.us/javascript/functional-javascript.html#sec-3-2">这个解释</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8">8</a></sup> <div class="footpara"><p class="footpara">
clojurescript作者把clojurescript的一些数据结构和函数编译成javascript, 这样就可以用普通js使用
clojure中的数据结构和函数. document严重过时, 建议看导入的<a href="https://github.com/swannodette/mori/blob/master/src/mori.cljs">源代码</a>, 以及clojure的文档, 接口和clojure基本一致.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<footer>
  <p>Author: Jichao Ouyang
    <a class="github-button" href="https://github.com/sponsors/jcouyang" data-icon="octicon-heart" aria-label="Sponsor @jcouyang on GitHub">Sponsor</a>
    <a aria-label="Follow @jcouyang on GitHub" data-count-aria-label="# followers on GitHub" data-count-api="/users/jcouyang#followers" data-count-href="/jcouyang/followers" href="https://github.com/jcouyang" class="github-button">Follow</a>
    <a href="https://twitter.com/oyanglulu" class="twitter-follow-button" data-show-screen-name="false" data-show-count="false">Follow @oyanglulu</a>
  </p>
  <p>Created: 2015-05-13 Wed 00:00</p>
  <p>Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.2 (<a href="https://orgmode.org">Org</a> mode 9.4.6) &#215; <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.
  <input type="swiftype" class="st-default-search-input" placeholder="Search"/>
  <a class="gumroad-button" href="https://gum.co/grokking-monad?wanted=true" target="_blank" data-gumroad-single-product="true">范畴论装逼指南，请自觉排队装逼</a>
  <div id="danmaku-comments"></div>
  <div id="disqus_thread"></div>
</footer>
</div>
</body>
</html>
