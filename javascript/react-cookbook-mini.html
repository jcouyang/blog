<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2019-07-23 Tue 12:54 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>A Compact React Cookbook</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Jichao Ouyang">
<link rel="icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/toc.css"/>
<link rel="stylesheet" href="/style/tufte.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="https://feeds.oyanglul.us/JichaoOuyangsBlog"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJRFJGX"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<header>
    <a accesskey="h" href="/index.html"> HOME </a> |
    <a href="#" id="edit-in-github">EDIT</a> |
    <a href="https://feeds.oyanglul.us/JichaoOuyangsBlog">RSS</a> |
    <a accesskey="H" href="/jichao.ouyang.html">ABOUT</a> |
    <a href="https://github.com/jcouyang/blog">GITHUB</a>
</header>
</div>
<div id="content">
<header>
<h1 class="title">A Compact React Cookbook</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga627c15">1. Why not 2 way binding/为毛不用双向绑定</a>
<ul>
<li><a href="#orgeef22fe">1.1. 双向绑定</a></li>
<li><a href="#orgeb44e10">1.2. 单向绑定</a></li>
<li><a href="#orgfe8b351">1.3. 双向有什么不好</a></li>
<li><a href="#org545071e">1.4. 单向有什么好</a></li>
</ul>
</li>
<li><a href="#orgdc70e2e">2. What's Virtual DOM, why should we care / 为毛要用 Vitual Dom</a>
<ul>
<li><a href="#orgb39a654">2.1. 以前是如何操作 DOM 的 （Mutable）</a></li>
<li><a href="#org19e89bc">2.2. Virtual DOM （Immutable）</a></li>
</ul>
</li>
<li><a href="#org6923d28">3. Why Immutable	/ 为毛要不可变</a>
<ul>
<li><a href="#org1d47188">3.1. 状态</a></li>
<li><a href="#org6bfb02d">3.2. Class</a></li>
<li><a href="#org9a3a243">3.3. 让你的数据结构 immutable 的工具们</a>
<ul>
<li><a href="#orge3e44fb">Immutablility helper</a></li>
<li><a href="#org2179400">mori</a></li>
<li><a href="#orgf271514">Immutable.js</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org29175c5">4. How to do Unit test React project	/  如何单元测试</a>
<ul>
<li><a href="#org754b7a7">4.1. Jest</a></li>
<li><a href="#orgc59a8df">4.2. jasmine</a></li>
<li><a href="#orge85793d">4.3. mocha</a></li>
</ul>
</li>
<li><a href="#org25bbd1a">5. Modular and Components</a>
<ul>
<li><a href="#org764ca27">5.1. browserify</a></li>
<li><a href="#org865de9d">5.2. webpack</a></li>
</ul>
</li>
<li><a href="#orgabaa0e0">6. How should I thinking in react way / 如何以 React 的方式解决问题</a></li>
<li><a href="#org4a7c3dd">7. What about Data Fetching / 只有 V 的话，数据 M 呢</a>
<ul>
<li><a href="#orgb3d64dc">7.1. just rest</a></li>
<li><a href="#org8197d54">7.2. relay/graphql</a></li>
<li><a href="#org2283639">7.3. falcor</a></li>
</ul>
</li>
<li><a href="#org453e239">8. What about Router / router 怎么办</a>
<ul>
<li><a href="#org6b8af8e">8.1. direactor</a>
<ul>
<li><a href="#org645bb59">client side</a></li>
<li><a href="#org926bac7">server side</a></li>
</ul>
</li>
<li><a href="#org76bc4a5">8.2. react router</a></li>
</ul>
</li>
<li><a href="#org33970f9">9. How to communicate between two components that don't have a parent-child relationship/ 不是父子关系的 component 怎么交互</a>
<ul>
<li><a href="#org6654c53">9.1. event</a></li>
<li><a href="#orgee9f147">9.2. flux</a>
<ul>
<li><a href="#orgc33c908">dispatcher</a></li>
<li><a href="#orgdfbc91a">store</a></li>
</ul>
</li>
<li><a href="#orgc365d0e">9.3. router</a></li>
<li><a href="#org6a42599">9.4. 应用级别 state</a></li>
</ul>
</li>
<li><a href="#org1d7a4cc">10. When should I use "key" / 什么时候该用 key</a></li>
<li><a href="#org6c3264f">11. What's these Warnings / 这些黄黄的是神马</a></li>
<li><a href="#orge132d7f">12. How to Profile Component Perfomance / 如何提升效率</a>
<ul>
<li><a href="#orgb3ae6aa">12.1. react profile</a></li>
<li><a href="#orge1f5f8f">12.2. PureRenderMixin</a></li>
<li><a href="#orgc5abbb5">12.3. shouldComponentUpdate</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<p>
这是一本非常 campact 的 React 煮书，收集了在实践 React 时的一些问题和解决方法。
</p>

<div id="outline-container-orga627c15" class="outline-2">
<h2 id="orga627c15"><span class="section-number-2">1</span> Why not 2 way binding/为毛不用双向绑定</h2>
<div class="outline-text-2" id="text-1">
<p>
解释这个问题我们需要先看什么是双向绑定，什么是单向绑定
</p>


<figure>
<img src="./images/multi-recur.gif" alt="multi-recur.gif">

</figure>
</div>

<div id="outline-container-orgeef22fe" class="outline-3">
<h3 id="orgeef22fe"><span class="section-number-3">1.1</span> 双向绑定</h3>
<div class="outline-text-3" id="text-1-1">
<p>
也就是dom 上的 value 与 controller 或者 view controller 上的绑定，值保持一致。
</p>
</div>
</div>

<div id="outline-container-orgeb44e10" class="outline-3">
<h3 id="orgeb44e10"><span class="section-number-3">1.2</span> 单向绑定</h3>
<div class="outline-text-3" id="text-1-2">
<p>
dom 上的值来源于 controller，但是 dom 上的值改变不会改变 controller 上的值。
</p>
</div>
</div>

<div id="outline-container-orgfe8b351" class="outline-3">
<h3 id="orgfe8b351"><span class="section-number-3">1.3</span> 双向有什么不好<label for="1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="1" class="margin-toggle"/><span class="sidenote">
<a href="https://www.quora.com/Why-is-the-two-way-data-binding-being-dropped-in-Angular-2">https://www.quora.com/Why-is-the-two-way-data-binding-being-dropped-in-Angular-2</a>
</span></h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>perfomance</li>
<li>我们真的需要吗？实际上有多少值是真的需要双向绑的</li>
<li>到底谁动了我的值？too many sources of truth</li>
</ul>
</div>
</div>

<div id="outline-container-org545071e" class="outline-3">
<h3 id="org545071e"><span class="section-number-3">1.4</span> 单向有什么好</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>只有一个 source of truth,  代码好 reason about</li>
<li>更快</li>
<li>需要的时候自己绑一把，也并不是多麻烦的事</li>
</ul>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">TwoWayBindingInput</span> = React.createClass({
  <span style="color: #6a5acd;">getInitialState</span>: <span style="color: #00008b;">function</span>() {
    <span style="color: #00008b;">return</span> {message: <span style="color: #8b0000;">'Hello!'</span>};
  },
  <span style="color: #6a5acd;">handleChange</span>: <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">event</span>) {
<span id="coderef-setstate" class="coderef-off">    <span style="color: #6b8e23;">this</span>.setState({message: event.target.value}); <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">&lt;=</span> (setstate)</span>
  },
  <span style="color: #6a5acd;">render</span>: <span style="color: #00008b;">function</span>() {
    <span style="color: #00008b;">var</span> <span style="color: #b8860b;">message</span> = <span style="color: #6b8e23;">this</span>.state.message;
<span id="coderef-value" class="coderef-off">    <span style="color: #00008b;">return</span> &lt;input type=<span style="color: #8b0000;">"text"</span> value={message} onChange={<span style="color: #6b8e23;">this</span>.handleChange} /&gt;; <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">&lt;=</span> (value)</span>
  }
});
</code></pre>

<p>
注意看这个双向绑定，<a href="#coderef-value" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-value');" onmouseout="CodeHighlightOff(this, 'coderef-value');">第value行</a> 是单向绑定值 <code>message</code> 到 <code>input</code> 元素上，<a href="#coderef-setstate" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-setstate');" onmouseout="CodeHighlightOff(this, 'coderef-setstate');">第setstate行</a> 是把 <code>input</code> 元素的值绑定回来，但是 <b>注意看</b> 这里绑定回来需要通过 <code>setState</code> 来完成，这就保证了 React Component 的 source of truth 还是只有 state。
</p>
</div>
</div>
</div>

<div id="outline-container-orgdc70e2e" class="outline-2">
<h2 id="orgdc70e2e"><span class="section-number-2">2</span> What's Virtual DOM, why should we care / 为毛要用 Vitual Dom</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgb39a654" class="outline-3">
<h3 id="orgb39a654"><span class="section-number-3">2.1</span> 以前是如何操作 DOM 的 （Mutable）</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li>query 到 DOM 上一个元素</li>
<li>改吧改吧</li>
</ol>
</div>
</div>

<div id="outline-container-org19e89bc" class="outline-3">
<h3 id="org19e89bc"><span class="section-number-3">2.2</span> Virtual DOM （Immutable）</h3>
<div class="outline-text-3" id="text-2-2">
<ol class="org-ol">
<li>想好要往 DOM 上放什么东西</li>
<li>把它给 Virtual DOM</li>
<li><p>
Virtual DOM 决定哪些应该修改 DOM 哪些不用
</p>

<p>
为什么说前者是 Mutable 后者是 Immutable，这是相对你的业务逻辑来说的。
</p></li>
</ol>
<p>
DOM 本身是 Mutable 的东西，把它柔和到你的业务上给你的逻辑加上了不少 mutable 的因素，而 Virtual DOM 成功的屏蔽掉了 mutable 的 DOM，每次 render 的 Component 其实都是新的，并不是以前 Component 的修改。
</p>

<p>
所以使用 Virutal DOM
</p>
<ul class="org-ul">
<li>容易 reason about， 因为 immutable</li>
<li>快</li>
<li>把紧耦合编程了高内聚</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org6923d28" class="outline-2">
<h2 id="org6923d28"><span class="section-number-2">3</span> Why Immutable	/ 为毛要不可变</h2>
<div class="outline-text-2" id="text-3">
<p>
Immutable 是函数式的概念之一，一旦创建出来之后，就不能再改变。因此，当你想对其做修改，就得弄一个新的。
</p>


<figure>
<img src="./images/zoidberg-die.gif" alt="zoidberg-die.gif">

</figure>

<p>
好奇的同学要问了，但是 React 看起来是面向对象的啊。 <code>createClass</code> ， <code>state</code> ，函数式有状态和 class 吗？
</p>

<div class="epigraph"><blockquote>
<p>
If a tree falls in a forest and no one is around to hear it, does it make a sound? <label for="2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="2" class="margin-toggle"/><span class="sidenote">
<a href="https://en.wikipedia.org/wiki/If_a_tree_falls_in_a_forest">https://en.wikipedia.org/wiki/If_a_tree_falls_in_a_forest</a>
</span>
</p>

</blockquote></div>

<p>
首先，函数式和面向对象并不冲突，两种编程范式分别有各自的方式解决问题。
</p>

<p>
其次：
</p>
</div>
<div id="outline-container-org1d47188" class="outline-3">
<h3 id="org1d47188"><span class="section-number-3">3.1</span> 状态</h3>
<div class="outline-text-3" id="text-3-1">
<p>
如果状态只存在于 Component 中又并没有影响任何人，它还是状态吗？
</p>

<p>
ClojureScript 的 React 库 om，只有一个 app 级别的 state。因此所有的 component，其实并无状态。
</p>

<p>
<a href="https://youtu.be/5yHFTN-_mOo">https://youtu.be/5yHFTN-_mOo</a>
</p>
</div>
</div>
<div id="outline-container-org6bfb02d" class="outline-3">
<h3 id="org6bfb02d"><span class="section-number-3">3.2</span> Class</h3>
<div class="outline-text-3" id="text-3-2">
<p>
想象一下使用一个 React Component 的时候
</p>
<pre class="code"><code>&lt;AFancyHelloWord message=<span style="color: #8b0000;">"Good News Everyone!"</span>/&gt;
</code></pre>
<p>
来想象一下
</p>
<ol class="org-ol">
<li>尖括号 <code>&lt;</code> 往右移</li>
<li>尖括号变成圆括号</li>
<li>里面再加个大括号</li>
<li>等号变冒号</li>
</ol>
<pre class="code"><code>AFancyHelloWord({message:<span style="color: #8b0000;">"Good News Everyone!"</span>})
</code></pre>

<p>
<a href="./images/futurama_August_26__2015_at_0617AM.gif ">./images/futurama_August_26__2015_at_0617AM.gif </a>
ok, 如果把每个 Component 看成一个函数，为了我们的代码更好 reason about 而且更 loose couple，我们应该尽量要 <b>消除</b> 每一个 Component 的状态。
 这样在 Component 的树中，我们可以随意切换 Component，以 Star Wars 为例，Anakin 有两样东西，Luke 和光剑：
</p>


<figure>
<img src="images/react-tree.png" alt="react-tree.png">

</figure>

<p>
当 Anakin 变成 Darth Vader，光剑的颜色变红时，Darth Vadar 有 Luke 和 红色光剑。
</p>


<figure>
<img src="images/react-tree-swap.png" alt="react-tree-swap.png">

</figure>

<p>
实际上我们需要尽量减少 Component 中的状态，而且对着少数的状态，由于他们是我们的 source  of truth，并不希望他是 mutable 的，这样我很难知道谁动了我的 source of truth。
</p>
</div>
</div>

<div id="outline-container-org9a3a243" class="outline-3">
<h3 id="org9a3a243"><span class="section-number-3">3.3</span> 让你的数据结构 immutable 的工具们</h3>
<div class="outline-text-3" id="text-3-3">
</div>
<div id="outline-container-orge3e44fb" class="outline-4">
<h4 id="orge3e44fb"><a href="http://facebook.github.io/react/docs/update.html">Immutablility helper</a></h4>
<div class="outline-text-4" id="text-orge3e44fb">
<p>
这是 react addon 中自带的工具，如果你并不想完整的 Immutable 数据结构，这个工具可以帮助 copy 一份来做改动
</p>
<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">update</span> = require(<span style="color: #8b0000;">'react-addons-update'</span>);
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">inc</span> = x=&gt;x+1
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">fancyPropsForChild</span>=update(<span style="color: #6b8e23;">this</span>.state, {
    x: {y: {z: {$set: 7}}},
    a: {b: {$push: [9]}},
    h: {$merge: {i: <span style="color: #8b0000;">"j"</span>}},
    e: {$apply: inc}
});
</code></pre>
</div>
</div>

<div id="outline-container-org2179400" class="outline-4">
<h4 id="org2179400"><a href="https://github.com/swannodette/mori">mori</a></h4>
<div class="outline-text-4" id="text-org2179400">
<p>
更为彻底的选择是，使用 ClojureScript 的 Immutable 数据结构。benchmark 要比 facebook 的 Immutable.js 好上许多，但是使用上跟 ClojureScript 一致， 用惯JavaScript的人可能不太能习惯，alternative 是使用我 fork 的 mori 版本<a href="http://github.com/jcouyang/conjs">conjs</a>。
</p>
</div>
</div>
<div id="outline-container-orgf271514" class="outline-4">
<h4 id="orgf271514"><a href="https://facebook.github.io/immutable-js/">Immutable.js</a></h4>
<div class="outline-text-4" id="text-orgf271514">
<p>
facebook 实现的 immutable 数据结构，使用上比较符合 JavaScript 习惯一些， 不过跑分低一些。
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org29175c5" class="outline-2">
<h2 id="org29175c5"><span class="section-number-2">4</span> How to do Unit test React project	/  如何单元测试</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org754b7a7" class="outline-3">
<h3 id="org754b7a7"><span class="section-number-3">4.1</span> <a href="http://facebook.github.io/jest/">Jest</a></h3>
<div class="outline-text-3" id="text-4-1">
<p>
总的来说，jest 的测试理念解决了非常多的前端测试的棘手问题，我做过一个关于 jest 的 session， 文章在 <a href="https://gistdeck.github.com/jcouyang/34686f695cd28309759e">这里</a>。 文章可能写得有点早，非常知道高兴的是终于支持<a href="https://github.com/facebook/jest/blob/master/package.json#L34">最新的 nodejs 了</a>，而且 重要的是 facebook 使用 jest 测试 react，有一些非常方便的 mock component 的方法。
</p>

<p>
recap 一下主要是
</p>
<ul class="org-ul">
<li>automock/ manual mock</li>
<li>jsdom</li>
<li>并行测试</li>
</ul>
</div>
</div>

<div id="outline-container-orgc59a8df" class="outline-3">
<h3 id="orgc59a8df"><span class="section-number-3">4.2</span> jasmine</h3>
<div class="outline-text-3" id="text-4-2">
<p>
jasmine  只是一个引擎，jest 也是用 jasmine 作为引擎。但是如果由于某种原因你不想用 jest 的话，可能你需要花更多的 effort 在：
</p>
<ul class="org-ul">
<li>mock （rewire.js）</li>
<li>runner (karma)</li>
<li>headless browser for ci(phantomjs)</li>
</ul>

<p>
所以并不推荐花这么大 effort 去撘一个 jasmine 的测试环境，关键还会有一系列的问题
</p>
<ul class="org-ul">
<li>phantomjs 怪怪的 issue</li>
<li>karma 复杂的配置</li>
<li>rewire 也有一些坑</li>
</ul>
</div>
</div>

<div id="outline-container-orge85793d" class="outline-3">
<h3 id="orge85793d"><span class="section-number-3">4.3</span> mocha</h3>
<div class="outline-text-3" id="text-4-3">
<p>
没试过用来测 React，不过 mocha 比 jasmine 好的一点是本身就可以跑在 node 上，使用 sinon（mock） 和 should.js（assert） 是个非常强大的一套测试工具。
</p>
</div>
</div>
</div>

<div id="outline-container-org25bbd1a" class="outline-2">
<h2 id="org25bbd1a"><span class="section-number-2">5</span> Modular and Components</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org764ca27" class="outline-3">
<h3 id="org764ca27"><span class="section-number-3">5.1</span> browserify</h3>
<div class="outline-text-3" id="text-5-1">
<p>
简单的 modular  bundler， <b>推荐</b> ， 因为职责单一的工具更不容易遇到奇怪的问题。
</p>

<p>
使用 browserify 使用 <a href="https://babeljs.io/docs/setup/#browserify">babel transformer</a> 就可以把所有的 component 以 node 的方式模块化的组织，最后 bundle 成一个 js 文件。
</p>

<ul class="org-ul">
<li><a href="https://babeljs.io/docs/setup/#browserify">babel 官网</a>就说明了如何使用 browserify <i>babelify</i> 你的模块们</li>
<li>如果使用 <i>gulp</i> ，需要参考 gulp <a href="https://github.com/gulpjs/gulp/blob/master/docs/recipes/browserify-uglify-sourcemap.md">这篇文档</a></li>
<li><i>grunt</i> 用户请使用 grunt-browserify 插件(非官方)</li>
<li><i>broccoli</i> 用户插件在 <a href="https://github.com/babel/broccoli-babel-transpiler">这里</a></li>
</ul>
</div>
</div>

<div id="outline-container-org865de9d" class="outline-3">
<h3 id="org865de9d"><span class="section-number-3">5.2</span> webpack</h3>
<div class="outline-text-3" id="text-5-2">
<p>
以 grunt 的方式 browserify 你的代码，非常强大的 bundler。但是个人并不喜欢 grunt，karma，webpack 这种基于配置的工具，原因很简单，配置不是代码！配置不是代码！配置不是代码！ 配对了当然简单，但是配错了怎么办，没法 debug。
</p>

<p>
虽然不喜欢，我还是要告诉你怎么用，就这么一行配置就好了
</p>
<pre class="code"><code>module: {
  loaders: [
    { test: <span style="color: #8b0000;">/\.jsx?$/</span>, exclude: <span style="color: #8b0000;">/node_modules/</span>, loader: <span style="color: #8b0000;">"babel-loader"</span>}
  ]
}
</code></pre>
</div>
</div>
</div>

<div id="outline-container-orgabaa0e0" class="outline-2">
<h2 id="orgabaa0e0"><span class="section-number-2">6</span> How should I thinking in react way / 如何以 React 的方式解决问题</h2>
<div class="outline-text-2" id="text-6">
<p>
要以 react 的方式思考，其实跟思考 HTML 差不多
 <a href="http://facebook.github.io/react/docs/thinking-in-react.html">http://facebook.github.io/react/docs/thinking-in-react.html</a>
</p>
</div>
</div>

<div id="outline-container-org4a7c3dd" class="outline-2">
<h2 id="org4a7c3dd"><span class="section-number-2">7</span> What about Data Fetching / 只有 V 的话，数据 M 呢</h2>
<div class="outline-text-2" id="text-7">
</div>
<div id="outline-container-orgb3d64dc" class="outline-3">
<h3 id="orgb3d64dc"><span class="section-number-3">7.1</span> just <a href="https://github.com/cujojs/rest">rest</a></h3>
<div class="outline-text-3" id="text-7-1">
<p>
简单，rest 请求回来一个 Promise，你还可以用 <a href="https://github.com/cujojs/when">when</a>  获得更多的 promise 和 monad 用法。
</p>

<p>
无需 model 在 componentDidMount 发出 rest 请求，then 直接扔给 setState。最多 setState 前加些 map filter 把数据改改格式。
</p>
</div>
</div>

<div id="outline-container-org8197d54" class="outline-3">
<h3 id="org8197d54"><span class="section-number-3">7.2</span> <a href="https://facebook.github.io/relay/">relay/graphql</a></h3>
<div class="outline-text-3" id="text-7-2">
<p>
官方 data fetching 解决方案。
</p>

<p>
比起由 component 去发请求，再转换数据格式。relay/graphql 的思想是有 component 定义数据形状，由 relay 去发请求，有 graphql server 跟去根据定义返回相应形状的数据。
</p>

<p>
所以，对，会多一层 server layer。
</p>

<p>
view 层简单了，graphql 要做的事情却不少。
</p>
</div>
</div>

<div id="outline-container-org2283639" class="outline-3">
<h3 id="org2283639"><span class="section-number-3">7.3</span> <a href="https://github.com/netflix/falcor">falcor</a></h3>
<div class="outline-text-3" id="text-7-3">
<p>
netflix 的简单版的 graphql可以参考我的 <a href="https://github.com/jcouyang/react-falcor">todo falcor</a>
思想大致相似，但是更为简单一些，没有什么 QL，schema 之类的
</p>
</div>
</div>
</div>

<div id="outline-container-org453e239" class="outline-2">
<h2 id="org453e239"><span class="section-number-2">8</span> What about Router / router 怎么办</h2>
<div class="outline-text-2" id="text-8">
<p>
建议使用 isomorphic router，就是 browser 与 node 都可以用的 router
</p>
</div>
<div id="outline-container-org6b8af8e" class="outline-3">
<h3 id="org6b8af8e"><span class="section-number-3">8.1</span> <a href="https://github.com/flatiron/director">direactor</a></h3>
<div class="outline-text-3" id="text-8-1">
<p>
非常轻量级的通用 router，并不是专门为 react 准备的，但是 router 而已，为毛要跟 component 耦合。
</p>
</div>
<div id="outline-container-org645bb59" class="outline-4">
<h4 id="org645bb59">client side</h4>
<div class="outline-text-4" id="text-org645bb59">
<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">routes</span> = {
  <span style="color: #8b0000;">'/author'</span>: ()=&gt;React.render(&lt;Author/&gt;, domNode),
  <span style="color: #8b0000;">'/author/:id'</span>: (id)=&gt;React.render(&lt;Auther id={id}/&gt;, domNode)
};
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">router</span> = Router(routes);
router.init();
</code></pre>
</div>
</div>
<div id="outline-container-org926bac7" class="outline-4">
<h4 id="org926bac7">server side</h4>
<div class="outline-text-4" id="text-org926bac7">
<p>
只需要调用 router.dispatch 就好了, 而且 server 端的 react 需要 <code>renderToString</code>
</p>
<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">router</span> = <span style="color: #00008b;">new</span> <span style="color: #36648b;">director.http.Router</span>({
  <span style="color: #8b0000;">'/author'</span>: {
    <span style="color: #6a5acd;">get</span>: <span style="color: #00008b;">function</span>(){
      <span style="color: #6b8e23;">this</span>.res.end(React.renderToString(&lt;Author/&gt;))
    }
  }
});
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">server</span> = http.createServer(<span style="color: #00008b;">function</span> (<span style="color: #b8860b;">req</span>, <span style="color: #b8860b;">res</span>) {
  router.dispatch(req, res, <span style="color: #00008b;">function</span> (<span style="color: #b8860b;">err</span>) {
    res.writeHead(200, { <span style="color: #8b0000;">'Content-Type'</span>: <span style="color: #8b0000;">'text/html'</span> })
    <span style="color: #00008b;">if</span> (err) {
      res.writeHead(404);
      res.end();
    }
  });
});
</code></pre>
</div>
</div>
</div>

<div id="outline-container-org76bc4a5" class="outline-3">
<h3 id="org76bc4a5"><span class="section-number-3">8.2</span> <a href="https://github.com/rackt/react-router">react router</a></h3>
<div class="outline-text-3" id="text-8-2">
<p>
非常 <b>非轻量级</b> 的 router，而且只能给 react component用。
</p>

<p>
概念上就是使用 Route 把你的 Component 包起来，让 router 决定到底哪个 componet 上
</p>
<pre class="code"><code>render((
  &lt;Router&gt;
    &lt;Route path=<span style="color: #8b0000;">"/"</span> component={App}&gt;
      &lt;Route path=<span style="color: #8b0000;">"about"</span> component={About}/&gt;
      &lt;Route path=<span style="color: #8b0000;">"users"</span> component={Users}&gt;
        &lt;Route path=<span style="color: #8b0000;">"/user/:userId"</span> component={User}/&gt;
      &lt;/Route&gt;
      &lt;Route path=<span style="color: #8b0000;">"*"</span> component={NoMatch}/&gt;
    &lt;/Route&gt;
  &lt;/Router&gt;
), document.body)
</code></pre>
</div>
</div>
</div>


<div id="outline-container-org33970f9" class="outline-2">
<h2 id="org33970f9"><span class="section-number-2">9</span> How to communicate between two components that don't have a parent-child relationship<label for="3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="3" class="margin-toggle"/><span class="sidenote">
<a href="http://facebook.github.io/react/tips/communicate-between-components.html">http://facebook.github.io/react/tips/communicate-between-components.html</a>
</span> / 不是父子关系的 component 怎么交互</h2>
<div class="outline-text-2" id="text-9">
<p>
对于这个问题，我的问题是
</p>
<div class="epigraph"><blockquote>
<p>
如果不是父子关系或者兄弟或者伯父侄女，真的需要交互吗？
</p>

</blockquote></div>
<p>
如果是在同一颗树上，那么一定能找到一个共同的 parent，把 parent 的回调传进来就好了
</p>

<p>
如果不在同一颗树上，你可能需要一个全局的一些东西
</p>
</div>
<div id="outline-container-org6654c53" class="outline-3">
<h3 id="org6654c53"><span class="section-number-3">9.1</span> event</h3>
<div class="outline-text-3" id="text-9-1">
<p>
 使用随便一种 event emitter，比如 <a href="https://www.npmjs.com/package/backbone-events-standalone">backbon events</a>。
在一个 componnet 中 trigger，另一个 component subscribe
</p>
</div>
</div>

<div id="outline-container-orgee9f147" class="outline-3">
<h3 id="orgee9f147"><span class="section-number-3">9.2</span> flux</h3>
<div class="outline-text-3" id="text-9-2">
<p>
flux 只是一个架构思想，你可以用任何自己喜欢的方式实现
其实跟 event emitter 差不多，只是针对和管理 state
</p>
</div>

<div id="outline-container-orgc33c908" class="outline-4">
<h4 id="orgc33c908">dispatcher</h4>
<div class="outline-text-4" id="text-orgc33c908">
<p>
作为action 的分发工作，决定哪些 action 引起哪些 store 的变化
</p>
</div>
</div>

<div id="outline-container-orgdfbc91a" class="outline-4">
<h4 id="orgdfbc91a">store</h4>
<div class="outline-text-4" id="text-orgdfbc91a">
<p>
状态与逻辑
</p>
</div>
</div>
</div>

<div id="outline-container-orgc365d0e" class="outline-3">
<h3 id="orgc365d0e"><span class="section-number-3">9.3</span> router</h3>
<div class="outline-text-3" id="text-9-3">
<p>
使用 router 传递信息也是可以的
</p>
</div>
</div>
<div id="outline-container-org6a42599" class="outline-3">
<h3 id="org6a42599"><span class="section-number-3">9.4</span> 应用级别 state</h3>
<div class="outline-text-3" id="text-9-4">
<p>
跟 om 一样，全局应用级别 state
</p>
</div>
</div>
</div>

<div id="outline-container-org1d7a4cc" class="outline-2">
<h2 id="org1d7a4cc"><span class="section-number-2">10</span> When should I use "key" / 什么时候该用 key</h2>
<div class="outline-text-2" id="text-10">
<p>
<b>只有当出现一串一样的元素的时候</b> ，这个时候 Virtual DOM 去 reconciliate（搞） DOM 的时候会傻傻分不清楚。
</p>

<div class="epigraph"><blockquote>
<p>
别的时候不要用 key，key 已经出现在 virtual dom diff/reconciliation 的阶段，效率要更低于 shouldComponentUpdate，所以尽量通过 shouldComponentUpdate 来决定是否要 render component。
</p>

</blockquote></div>


<figure>
<img src="./images/came-out.gif" alt="came-out.gif">

</figure>

<p>
官网文档的这个例子
</p>
<pre class="code"><code>renderA: &lt;div&gt;&lt;span&gt;first&lt;/span&gt;&lt;/div&gt;
renderB: &lt;div&gt;&lt;span&gt;second&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;/div&gt;
=&gt; [replaceAttribute textContent <span style="color: #8b0000;">'second'</span>], [insertNode &lt;span&gt;first&lt;/span&gt;]
</code></pre>
<p>
其实是往第一个位置插入了一个 span，但是会被 diff 成
</p>
<ul class="org-ul">
<li>替换内容 first 到 second</li>
<li><p>
插入内容为 first 的 span
</p>

<p>
不光是这样会更慢的问题，如果你在 first 上绑有事件的话，重新 render 后因为是 replace 了内容，因此这是原来的事件会变成 second 的事件，这样就 <b>完全错乱</b> 了。
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org6c3264f" class="outline-2">
<h2 id="org6c3264f"><span class="section-number-2">11</span> What's these Warnings / 这些黄黄的是神马</h2>
<div class="outline-text-2" id="text-11">
<div class="epigraph"><blockquote>
<p>
黄黄的东西(除了小黄人)请一定要除掉！
</p>

</blockquote></div>
<p>
所有 react 的 warning 描述都非常详细，请一定 <b>务必</b> 要除掉。
</p>
</div>
</div>

<div id="outline-container-orge132d7f" class="outline-2">
<h2 id="orge132d7f"><span class="section-number-2">12</span> How to Profile Component Perfomance / 如何提升效率</h2>
<div class="outline-text-2" id="text-12">
<p>
当然不是咖啡!
</p>


<figure>
<img src="./images/coffee.gif" alt="coffee.gif">

</figure>
</div>

<div id="outline-container-orgb3ae6aa" class="outline-3">
<h3 id="orgb3ae6aa"><span class="section-number-3">12.1</span> <a href="https://facebook.github.io/react/docs/perf.html">react profile</a></h3>
</div>

<div id="outline-container-orge1f5f8f" class="outline-3">
<h3 id="orge1f5f8f"><span class="section-number-3">12.2</span> PureRenderMixin</h3>
<div class="outline-text-3" id="text-12-2">
<p>
当你的 props 和 state 都是 immutable 的时候&#x2026;
</p>
<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">PureRenderMixin</span> = require(<span style="color: #8b0000;">'react-addons-pure-render-mixin'</span>);
React.createClass({
  mixins: [PureRenderMixin],
  <span style="color: #6a5acd;">render</span>: <span style="color: #00008b;">function</span>() {
    <span style="color: #00008b;">return</span> &lt;div className={<span style="color: #6b8e23;">this</span>.props.className}&gt;foo&lt;/div&gt;;
  }
});
</code></pre>
</div>
</div>

<div id="outline-container-orgc5abbb5" class="outline-3">
<h3 id="orgc5abbb5"><span class="section-number-3">12.3</span> <a href="https://facebook.github.io/react/docs/advanced-performance.html#shouldcomponentupdate-in-action">shouldComponentUpdate</a></h3>
<div class="outline-text-3" id="text-12-3">
<p>
可以通过这个方法对于 component 到底什么情况下应该重新 render 调优
</p>


<div class="epigraph"><blockquote>
<p>
所有图片来源于 giphy.com, copyright @<a href="http://www.cc.com/shows/futurama">Futurama</a>
</p>

</blockquote></div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="https://www.quora.com/Why-is-the-two-way-data-binding-being-dropped-in-Angular-2">https://www.quora.com/Why-is-the-two-way-data-binding-being-dropped-in-Angular-2</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
<a href="https://en.wikipedia.org/wiki/If_a_tree_falls_in_a_forest">https://en.wikipedia.org/wiki/If_a_tree_falls_in_a_forest</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
<a href="http://facebook.github.io/react/tips/communicate-between-components.html">http://facebook.github.io/react/tips/communicate-between-components.html</a>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<footer>
  <p>Author: Jichao Ouyang <a aria-label="Follow @jcouyang on GitHub" data-count-aria-label="# followers on GitHub" data-count-api="/users/jcouyang#followers" data-count-href="/jcouyang/followers" href="https://github.com/jcouyang" class="github-button">Follow @jcouyang</a></p>
  <p>Modified: 2019-07-23 Tue 12:54</p>
  <p>Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.1 (<a href="https://orgmode.org">Org</a> mode 9.2.2) &#215; <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.
  <input type="swiftype" class="st-default-search-input" placeholder="Search"/>
  <a class="gumroad-button" href="https://gum.co/grokking-monad?wanted=true" target="_blank" data-gumroad-single-product="true">范畴论装逼指南，请自觉排队装逼</a>
  <div id="danmaku-comments"></div>
  <div id="disqus_thread"></div>
</footer>
</div>
</body>
</html>
