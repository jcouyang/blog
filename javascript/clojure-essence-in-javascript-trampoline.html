<!DOCTYPE html>
<html>
<head>
<!-- 2017-09-12 Tue 12:01 -->
<meta  charset="utf-8">
<meta  name="viewport" content="width=device-width, initial-scale=1">
<title>JavaScript玩转Clojure大法之 - Trampoline</title>
<meta  name="generator" content="Org-mode">
<meta  name="author" content="Jichao Ouyang">
<meta  name="description" content="在函数式编程中, 递归可以说是最关健甚至唯一的循环手段, Clojure的recur可以保证得到 /尾递归/ 优化, 而相互递归则不能用recur来保证得到优化, 因此, 另一个大法出现了 -- /Trampoline/"
>
<meta  name="keywords" content="clojure, javascript,js, trampoline, functional, fp, recursive, recur, mutual">
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
                                                    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
                                                                                              j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
                                                                                                'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-NJRFJGX');</script>
<!-- End Google Tag Manager -->
<link rel="icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/pixyll.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="https://feeds.oyanglul.us/JichaoOuyangsBlog"/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.0/gh-fork-ribbon.min.css" />
<!--[if lt IE 9]>
     <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.0/gh-fork-ribbon.ie.min.css" />
     <![endif]-->
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJRFJGX"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<header>
    <a accesskey="h" href="/index.html"> HOME </a> |
    <a href="#" id="edit-in-github">EDIT</a> |
    <a href="https://feeds.oyanglul.us/JichaoOuyangsBlog">RSS</a> |
    <a href="/archive.html">ARCHIVE</a> |
    <a href="/theindex.html">INDEX</a> |
    <a accesskey="H" href="/jichao.ouyang.html">ABOUT</a>
</header>
</div>
<div id="content">
<header>
<h1 class="title">JavaScript玩转Clojure大法之 - Trampoline</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline2">尾递归(tail recursion)</a></li>
<li><a href="#orgheadline1">相互递归(mutual recursion)</a>
<ul>
<li><a href="#orgheadline3">DFA</a></li>
<li><a href="#orgheadline4">Trampoline</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<ul class="org-ul">
<li><a href="./clojure-core.async-essence-in-native-javascript.html">JavaScript玩转Clojure大法之 - 并发编程</a></li>
<li><a href="./clojure-essence-in-javascript-transducer.html">JavaScript玩转Clojure大法之 - Transducer</a></li>
<li><b><a href="./clojure-essence-in-javascript-trampoline.html">JavaScript玩转Clojure大法之 - Trampoline</a></b></li>
<li><a href="./clojure-essence-in-javascript-macro.html">JavaScript玩转Clojure大法之 - Macro (1)</a></li>
</ul>

<p>
在函数式编程中, 递归可以说是最关健甚至唯一的循环手段
</p>

<p>
Clojure的recur可以保证得到 <i>尾递归</i> 优化, 而相互递归则不能用recur来保证得到优化, 因此
另一个大法出现了 &#x2013; <i>Trampoline</i>
</p>


<figure>
<p><img src="./images/multi-recur.gif" alt="multi-recur.gif">
</p>
</figure>

<p>
Trampoline 翻译成中文是蹦床, <i>蹦~蹦蹦蹦蹦</i> (自己脑补intel BGM)
</p>

<p>
如果你看过老友记这集(Friends: The One with Ross's New Girlfriend), 应该记得这个梗
</p>

<blockquote>
<p>
Ross: you hang up first
</p>

<p>
Julie: No, you hang up first
</p>

<p>
Ross: No, you hang up first
&#x2026;
</p>
</blockquote>

<p>
ok, 这就是相互递归(mutual recursion)
</p>

<p>
在继续解释trampoline是如何优化相互递归之前, 可能有些同学不太清楚什么是尾递归优化, 当然嫌我啰嗦的可以直接坐
<a href="#orgheadline1">电梯</a>直达.
</p>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">尾递归(tail recursion)</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p>
又要拿一个被举烂了的例子 - 求n的阶乘
</p>

<p>
很容易就可以写出来
</p>
<div class="org-src-container">

<pre class="src src-js"><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">fact</span>(<span style="color: #b8860b;">n</span>){
    <span style="color: #00008b;">if</span>(n==0)<span style="color: #00008b;">return</span> 1;
    <span style="color: #00008b;">return</span> n*fact(n-1);
}
</pre>
</div>

<p>
好吧, 这就是典型的非尾递归, 因为最后一个操作并不是调用自己, 而是 <b>乘法</b>
</p>

<p>
想想最后一行, 先算出 <code>fact(n-1)</code>, 然后乘n, 返回
</p>

<p>
那么怎么才是尾递归, 当然是最后一个操作一定是调用自己.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">fact</span>(<span style="color: #b8860b;">n</span>, <span style="color: #b8860b;">acc</span>){
    <span style="color: #00008b;">if</span>(n==0)<span style="color: #00008b;">return</span> acc;
    <span style="color: #00008b;">return</span> fact(n-1, acc*n)
}
</pre>
</div>
<p>
两个地方值得注意
</p>
<ul class="org-ul">
<li>看到 <code>acc</code> 了没有, 这就是典型的尾递归最常见的东西, 用来累计每次递归运算结果</li>
<li>fact函数的最后一个操作是fact本身</li>
</ul>

<p>
由于tail recur非常容易改写成循环, 编译器容易对其进行优化
</p>
<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">fact</span>(<span style="color: #b8860b;">n</span>){
    <span style="color: #00008b;">var</span> <span style="color: #b8860b;">acc</span>=1,<span style="color: #b8860b;">i</span>=n
    <span style="color: #00008b;">while</span>(i!=0){
        acc=acc*i;
        i-=1;
    }
    <span style="color: #00008b;">return</span> acc
}
</pre>
</div>

<p>
有没有觉得尾递归和循环非常像, 唯一的区别是
</p>
<ul class="org-ul">
<li>尾递归用参数重新绑定递减的n</li>
<li>尾递归用参数重新绑定叠加值acc</li>
<li>循环直接改变变量i来进行递减</li>
<li>循环叠加变量acc</li>
</ul>

<p>
但思路是一模一样的
</p>

<blockquote>
<p>
在clojure里, 尾递归是用 <code>recur</code> 来保证(scalar貌似是@tail annotation), 好处是
</p>
<ol class="org-ol">
<li>用recur的一定是尾递归, 直接优化</li>
<li>编译器可以检查recur出现的位置是否为tail</li>
</ol>
</blockquote>
</div>
</div>
<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">相互递归(mutual recursion)</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
相互递归由于是函数之间的互相调用, 则不能像尾递归一样直接优化成循环就完事.
</p>
</div>
<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3">DFA</h3>
<div class="outline-text-3" id="text-orgheadline3">
<p>
举个最简单的例子, 相互递归经常用于状态机的实现, 比如自动贩卖机, 假设这台贩卖机非常简单, 只吃五块,只卖巧克力
</p>

<p>
那么输入集是 <code>[五块, 选巧克力, 找零]</code>, 所以贩卖机正常的process是类似
</p>

<p>
<code>5块 -&gt; 巧克力 -&gt;  找2块</code>
</p>

<p>
好吧, 我们来实现一把
</p>
<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">eat_money</span>(<span style="color: #b8860b;">input_seq</span>){
    <span style="color: #00008b;">var</span> <span style="color: #b8860b;">input</span> = input_seq.shift()
    <span style="color: #00008b;">if</span>(input== <span style="color: #8b0000;">'&#20116;&#22359;'</span>)
        console.log(<span style="color: #8b0000;">'&#25910;&#21040;&#21602;,&#36873;&#20010;&#24039;&#20811;&#21147;&#21543;^_^'</span>)
        choose(input_seq)
    <span style="color: #00008b;">else</span>
        eat_money(input_seq)
}

<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">choose</span>(<span style="color: #b8860b;">input_seq</span>){
    <span style="color: #00008b;">var</span> <span style="color: #b8860b;">input</span> = input_seq.shift()
    <span style="color: #00008b;">if</span>(input== <span style="color: #8b0000;">'&#24039;&#20811;&#21147;'</span>)
        console.log(<span style="color: #8b0000;">'&#36873;&#20102;&#24039;&#20811;&#21147;, &#25353;&#19979;&#25214;&#38646;&#25353;&#38062;, &#25105;&#36824;&#27424;&#20320;&#20004;&#22359;&#38065;&#21734;'</span>)
        changes(input_seq)
    <span style="color: #00008b;">else</span>
        choose(input_seq)
}

<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">changes</span>(<span style="color: #b8860b;">input_seq</span>){
    <span style="color: #00008b;">var</span> <span style="color: #b8860b;">input</span> = input_seq.shift()
    <span style="color: #00008b;">if</span>(input==<span style="color: #8b0000;">'&#25214;&#38646;'</span>)
        console.log(<span style="color: #8b0000;">'&#27426;&#36814;&#20877;&#27425;&#20809;&#20020;'</span>)
        eat_money(input_seq)
    <span style="color: #00008b;">else</span>
        changes(input_seq)
}
</pre>
</div>

<p>
假设我是个怪蜀黍QA,来到这个贩卖机上怒点这样以系列操作, 看我们的贩卖机有没有疯掉
</p>

<p>
<code>['巧克力', '巧克力', '找钱', '五块', '找钱', '五块', '巧克力', '五块', '找钱']</code>
</p>

<a class="jsbin-embed" href="http://jsbin.com/zapana/1/embed?js,console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>

<p>
很好
</p>

<p>
现在问题来了, 如果我的 <code>input_seq</code> 非常长, 比如
</p>
<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #00008b;">for</span>(<span style="color: #00008b;">var</span> <span style="color: #b8860b;">n</span>=15;n&gt;0;n--){
  input_seq=input_seq.concat(input_seq)
}
input_seq.length <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; 294912</span>
</pre>
</div>
<p>
现在 <code>input_seq</code> 非常大, 再试试(请到node上试)
</p>

<pre class="example">
...
收到呢,选个巧克力吧^_^
RangeError: Maximum call stack size exceeded
...
</pre>

<p>
爆栈了吧
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4">Trampoline</h3>
<div class="outline-text-3" id="text-orgheadline4">
<p>
Trampoline就是用来解决相互递归爆栈的问题, 等等, 什么是Trampoline
</p>

<p>
trampoline是一个函数:
</p>
<ol class="org-ol">
<li>接受一个函数, 一个或多个函数的参数</li>
<li>调用该函数</li>
<li>如果返回值是个函数, 继续调用</li>
<li>如果返回值不是函数, 停止</li>
</ol>

<p>
比如可以把贩卖机简单的改造一下, 让他返回函数, 而不是直接调用其他函数, 注意第<a href="#coderef-trampoline"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-trampoline');" onmouseout="CodeHighlightOff(this, 'coderef-trampoline');">6</a>行
</p>

<div class="org-src-container">

<pre class="src src-javascript"><span class="linenr"> 1: </span><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">eat_money</span>(<span style="color: #b8860b;">input_seq</span>){
<span class="linenr"> 2: </span>  <span style="color: #00008b;">if</span>(input_seq.length==0)<span style="color: #00008b;">return</span>
<span class="linenr"> 3: </span>  <span style="color: #00008b;">var</span> <span style="color: #b8860b;">input</span> = input_seq.shift()
<span class="linenr"> 4: </span>  <span style="color: #00008b;">if</span>(input== <span style="color: #8b0000;">'&#20116;&#22359;'</span>){
<span class="linenr"> 5: </span>    console.log(<span style="color: #8b0000;">'&#25910;&#21040;&#21602;,&#36873;&#20010;&#24039;&#20811;&#21147;&#21543;^_^'</span>)
<span id="coderef-trampoline" class="coderef-off"><span class="linenr"> 6: </span>    <span style="color: #00008b;">return</span> <span style="color: #00008b;">function</span>(){</span>
<span class="linenr"> 7: </span>      <span style="color: #00008b;">return</span> choose(input_seq)
<span class="linenr"> 8: </span>    }
<span class="linenr"> 9: </span>  }<span style="color: #00008b;">else</span>{
<span class="linenr">10: </span>    <span style="color: #00008b;">return</span> <span style="color: #00008b;">function</span>(){
<span class="linenr">11: </span>      <span style="color: #00008b;">return</span> eat_money(input_seq)
<span class="linenr">12: </span>    }
<span class="linenr">13: </span>  } 
<span class="linenr">14: </span>}
</pre>
</div>
<p>
这样每次调用eat_money其实返回一个闭包, 需要再调用一下才能真的执行 <code>choose</code> 函数.
</p>

<p>
经过这样的改造以后(当然其他函数也要类似的加闭包), 就可以用 <code>trampoline</code> 来执行他们了
</p>
<div class="org-src-container">

<pre class="src src-javascript">mori.trampoline(eat_money,input_seq)
</pre>
</div>

<p>
由于eat_money返回一个闭包,也就是函数, trampoline会继续执行这个返回的闭包,直到返回的不是函数为止
</p>

<p>
而trampoline优化之前的 <code>eat_money</code>, 其实就是把最后调用的函数压到调用栈里, 然后
压入调用栈的这个函数比如是 <code>choose</code> 又调用另一个函数比如 <code>changes</code>, 然后一直压压压, 压到最后再从栈里弹出来一个一个执行.
</p>


<figure>
<p><img src="./images/stack.gif" alt="stack.gif">
</p>
</figure>
<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">eat_money</span>(<span style="color: #b8860b;">input_seq</span>){
    <span style="color: #00008b;">return</span> choose(input_seq){
        <span style="color: #00008b;">return</span> changes(input_seq){
            <span style="color: #00008b;">return</span> ...
        }
    }
}
</pre>
</div>

<p>
所以如果压入的函数个数超过栈的容量, 栈 <del>菊花</del> 就被爆了
而trampoline则是在函数最后返回一个闭包, 闭包内的递归调用并未被调用, 也就是未被压栈, 所以是这样的
</p>


<figure>
<p><img src="./images/conga.jpg" alt="conga.jpg">
</p>
</figure>

<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #00008b;">var</span> <span style="color: #b8860b;">res</span> = eat_money(input_seq)
<span style="color: #00008b;">while</span>(<span style="color: #6b8e23;">true</span>){
    <span style="color: #00008b;">if</span>(<span style="color: #00008b;">typeof</span> res ==<span style="color: #8b0000;">'function'</span>)res = res()
    <span style="color: #00008b;">else</span>
        <span style="color: #00008b;">break</span>
}
</pre>
</div>

<p>
优化成循环了不是.
</p>

<p>
完整代码, 如果uncomment 注释掉的代码浏览器会timeout, 请在node上跑, 反正不会爆栈
</p>
<a class="jsbin-embed" href="http://jsbin.com/cerase/2/embed?js,console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<footer>
  <p>Author: Jichao Ouyang <a aria-label="Follow @jcouyang on GitHub" data-count-aria-label="# followers on GitHub" data-count-api="/users/jcouyang#followers" data-count-href="/jcouyang/followers" href="https://github.com/jcouyang" class="github-button">Follow @jcouyang</a></p>
  <p>Modified: 2017-05-04 Thu 02:08</p>
  <p>Generated by: <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.3.6) x <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.
  <input type="swiftype" class="st-default-search-input" placeholder="Search"/>
  <a class="gumroad-button" href="https://gum.co/grokking-monad">我的新书 Grokking Monad 现已发售，请自觉排队装逼</a>

  <a class="github-fork-ribbon right-bottom fixed" href="https://github.com/jcouyang/blog" title="Fork me on GitHub">Fork me on GitHub</a>
</footer>

<div id="disqus_thread"></div>
</div>
</body>
</html>
