<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2019-04-06 Sat 13:42 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Essential EcmaScript 6</title>
<meta name="generator" content="Org mode">
<meta name="author" content="root">
<meta name="description" content="新的草案(虽然说是草案,但你可以看到 Firefox 其实已经实现大部分的feature)离我们越来越近了, 而且我们已经可以通过 [[https://babeljs.io/][babel]] 在项目中使用这些新的features. 是时候让我们重新认识一下 JavaScript 了. 下面列出了一部分比较让人兴奋和期待的features."
>
<meta name="keywords" content="es6, EcmaScript 6, babel, javascript, functional">
<link rel="icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/toc.css"/>
<link rel="stylesheet" href="/style/tufte.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="https://feeds.oyanglul.us/JichaoOuyangsBlog"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJRFJGX"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<header>
    <a accesskey="h" href="/index.html"> HOME </a> |
    <a href="#" id="edit-in-github">EDIT</a> |
    <a href="https://feeds.oyanglul.us/JichaoOuyangsBlog">RSS</a> |
    <a accesskey="H" href="/jichao.ouyang.html">ABOUT</a> |
    <a href="https://github.com/jcouyang/blog">GITHUB</a>
</header>
</div>
<div id="content">
<header>
<h1 class="title">Essential EcmaScript 6</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga5e02ee">Arrow Function</a></li>
<li><a href="#orgc8dafc9">Let</a></li>
<li><a href="#org88ffe54"><span class="done DONE">DONE</span> Proxy</a></li>
<li><a href="#org5ed462f">Destructuring</a></li>
<li><a href="#org108f999">Tail Calling</a></li>
<li><a href="#orgb2d707d">Template Strings</a></li>
<li><a href="#org3ce12d2">Class</a></li>
<li><a href="#orgb878056">Promises</a></li>
<li><a href="#org4ca1e33">Generator</a></li>
</ul>
</div>
</nav>
<p>
新的草案<a href="http://kangax.github.io/compat-table/es6/">ECMAScript 6</a>
(虽然说是草案,但你可以看到 Firefox 其实已经实现大部分的
feature)离我们越来越近了, 而且我们已经可以通过 <a href="https://babeljs.io/">babel</a> 在项目中使用这些新的features. 是时候让我们
重新认识一下 JavaScript 了. 下面列出了一部分比较让人兴奋和期待的features. 剧透一下我最激动的还是<a href="#org108f999"> Tail Calling</a>
</p>

<div id="outline-container-orga5e02ee" class="outline-2">
<h2 id="orga5e02ee">Arrow Function</h2>
<div class="outline-text-2" id="text-orga5e02ee">
<div class="epigraph"><blockquote>
<p>
由于 arrow function 只在Firefox 22以上版本实现,
这里所有代码都可以在Firefox的Console中调试, 其他chrome 什么的都没有实现(完全)<label for="1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="1" class="margin-toggle"/><span class="sidenote">
Chrome有一个 feature toggle 可以打开部分 es6 功能 <code>chrome://flags/#enable-javascript-harmony</code>
</span>.
另外每节的最后我都会给出完整代码的可执行的 jsbin 链接.
</p>

</blockquote></div>

<p>
你可以用两种方式定义一个箭头函数
</p>

<pre class="example">
([param] [, param]) =&gt; {
   statements
}
// or
param =&gt; expression
</pre>

<p>
单个表达式可以写成一行, 而多行语句则需要 block <code>{}</code> 括起来.
</p>

<p>
看看旧的匿名函数怎么写一个使数组中数字都乘2的函数.
</p>

<pre class="example">
var a = [1,2,3,4,5];
a.map(function(x){ return x*2 });
</pre>

<p>
用箭头函数会变成
</p>

<pre class="example">
a.map(x =&gt; x*2);
</pre>

<p>
只是少了 <code>function</code> 和 <code>return</code> 以及 block, 不是吗? 如果觉得差不多,
因为你看惯了 JavaScript 的匿名函数,
你的大脑编译器自动的忽略了,因为他们不需要显示的存在.
</p>

<p>
而 <code>map(x =&gt; x*2)</code> 要更 make sense,
因为我们需要的匿名函数只需要做一件事情, 我们需要的是 一个函数 <code>f</code>,
可以将给定 <code>x</code>, 映射到 <code>y</code>.
翻译这句话的最简单的方式不就是 <code>f = (x =&gt; x*2)</code>
</p>
</div>
</div>

<div id="outline-container-orgc8dafc9" class="outline-2">
<h2 id="orgc8dafc9">Let</h2>
<div class="outline-text-2" id="text-orgc8dafc9">
<p>
我喜欢用 <code>let</code> 替换了以前的 <code>var</code>, 为什么, 以前的var有什么不好.
</p>

<p>
<code>var</code> 的意思是变量, 它自己没有任何的scope,所以的作用范围非常难以推断.
但是我们通常只想在一个scope里给定一个值,而不影响scope外界的任何绑定.
</p>

<p>
想想以前 <code>var</code> 的scope是什么, <code>function</code>
</p>
<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">a</span> = <span style="color: #8b0000;">'first assign'</span>
<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">b</span> (){
    <span style="color: #00008b;">var</span> <span style="color: #b8860b;">a</span> = <span style="color: #8b0000;">'second assign'</span>
    console.log(a)
}
console.log(a)
b()
console.log(a)
</code></pre>

<p>
来看看 lisp 给了我们很好的模范如何解决绑定这种问题.
</p>
<pre class="code"><code>(<span style="color: #00008b;">let</span> ((something 2))
  (+ something 1)
  ) <span style="color: #8c8c8c; font-style: italic;">; </span><span style="color: #8c8c8c; font-style: italic;">=&gt; 3</span>
</code></pre>

<p>
es5 的 <code>let</code> 完全等价应该是
</p>
<pre class="code"><code>(<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">something</span>){
    <span style="color: #00008b;">return</span> something +=1
}).call(<span style="color: #6b8e23;">this</span>, 2)
</code></pre>

<p>
<code>let</code> 内的任何操作都不会影响外部绑定. 这样更安全而且容易推断, 这也是很多库用来封装js模块的方式, 比如jquery, 比如coffee会自动
对每个模块添加类似的function wrapper.
</p>

<p>
而es6, <code>let</code> 给我们带来了scope. 注意看,除了括号成了中括号,好像就是 lisp 那个意思了.
</p>
<pre class="code"><code><span style="color: #00008b;">let</span> <span style="color: #b8860b;">a</span> = <span style="color: #8b0000;">'first assign'</span>
{
    <span style="color: #00008b;">let</span> <span style="color: #b8860b;">a</span> = <span style="color: #8b0000;">'second assign'</span>
    console.log(a)
}
console.log(a)
</code></pre>
</div>
</div>

<div id="outline-container-org88ffe54" class="outline-2">
<h2 id="org88ffe54"><span class="done DONE">DONE</span> Proxy</h2>
<div class="outline-text-2" id="text-org88ffe54">
<p>
名字解释了一切, 对, 代理, 就是能帮你做一些事情的东西.
</p>

<p>
JavaScript是动态语言,也就是说最关心的事情是行为.所以行为也能通過meta programming让其带那么一些行为.
</p>

<p>
试试把下列代码考到Firefox的Console中
</p>
<pre class="code"><code>  <span style="color: #00008b;">let</span> <span style="color: #b8860b;">github_api</span> = <span style="color: #00008b;">function</span>(){};
  github_api.path=<span style="color: #8b0000;">'https://api.github.com'</span>;
  <span style="color: #00008b;">let</span> <span style="color: #b8860b;">restful</span> = <span style="color: #00008b;">function</span> restfulize(<span style="color: #b8860b;">api</span>){
      <span style="color: #00008b;">return</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">Proxy</span>(api, {
<span id="coderef-get" class="coderef-off">          <span style="color: #6a5acd;">get</span>: <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">receiver</span>, <span style="color: #b8860b;">name</span>){</span>
              receiver.path+=<span style="color: #8b0000;">'/'</span>+name;
              <span style="color: #00008b;">return</span> restfulize(receiver);
          },
<span id="coderef-apply" class="coderef-off">          <span style="color: #6a5acd;">apply</span>: <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">receiver</span>, <span style="color: #b8860b;">that</span>, <span style="color: #b8860b;">args</span>){</span>
              console.log(<span style="color: #8b0000;">`sending request to ${receiver.path}`</span>)
          }
      })
  }

<span id="coderef-jcouyang" class="coderef-off">  restful(github_api).user.jcouyang()</span>
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; "sending request to https://api.github.com/user/jcouyang"</span>
</code></pre>

<p>
简单的几行代码,我们就自制了一个接口非常流畅的restful api client. 再也不用麻烦的拼接字符串,
转成代理的方法适当接口更已读且易于重用.
</p>

<p>
magic到底在哪呢, <code>proxy</code> 给目标函数代理了两个方法, 一个 <a href="#coderef-get" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-get');" onmouseout="CodeHighlightOff(this, 'coderef-get');">get</a>, 一个 <a href="#coderef-apply" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-apply');" onmouseout="CodeHighlightOff(this, 'coderef-apply');">apply</a>,
</p>
<ul class="org-ul">
<li><code>get</code> 不管从 <code>proxy</code> 中取任何值都会运行 <code>get</code>.</li>
</ul>
<p>
一直返回新的相同但是path变化了的 <code>proxy</code>, 所以不管是 <code>.user</code> 还是 <code>.jcouyang</code> 
都是拼接成 <code>path</code>, 并返回一个新的以新 <code>path</code> 为目标的proxy
</p>
<ul class="org-ul">
<li><code>apply</code> 里面是运行这个proxy时要做的事情. 所以当我调用 <a href="#coderef-jcouyang" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-jcouyang');" onmouseout="CodeHighlightOff(this, 'coderef-jcouyang');">jcouyang()</a> 的时候, log就打出来了.</li>
</ul>
</div>
</div>

<div id="outline-container-org5ed462f" class="outline-2">
<h2 id="org5ed462f">Destructuring</h2>
<div class="outline-text-2" id="text-org5ed462f">

<figure>
<img src="https://i.giphy.com/G9hwRUsSFrPpK.gif" alt="G9hwRUsSFrPpK.gif">

</figure>

<pre class="code"><code>(<span style="color: #00008b;">let</span> [[first &amp; rest] [1 2 3 4 5]]
     rest
     ) <span style="color: #8c8c8c; font-style: italic;">; =&gt; (2 3 4 5)</span>
</code></pre>

<p>
终于也可以在 JavaScript 里面这样干了.
</p>
<pre class="code"><code><span style="color: #00008b;">let</span> [&#23380;&#36830;&#39034;, &#24352;&#20840;&#34507;] = [<span style="color: #8b0000;">'&#22899;&#31070;'</span>, <span style="color: #8b0000;">'&#30007;&#31070;'</span>]
&#23380;&#36830;&#39034; <span style="color: #8c8c8c; font-style: italic;">//</span><span style="color: #8c8c8c; font-style: italic;">=&gt; &#30007;&#31070;1</span>
&#24352;&#20840;&#34507; <span style="color: #8c8c8c; font-style: italic;">//</span><span style="color: #8c8c8c; font-style: italic;">=&gt; &#30007;&#31070;2</span>
</code></pre>

<p>
当然可以对Map这样干
</p>
<pre class="code"><code><span style="color: #00008b;">let</span> {&#22899;&#31070;, &#30007;&#31070;} = {<span style="color: #8b0000;">'&#30007;&#31070;'</span>: [<span style="color: #8b0000;">'&#21776;&#39532;&#20754;'</span>, <span style="color: #8b0000;">'&#24352;&#20840;&#34507;'</span>], <span style="color: #8b0000;">'&#22899;&#31070;'</span>: <span style="color: #8b0000;">'&#23380;&#36830;&#39034;'</span>}
&#22899;&#31070; <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; &#23380;&#36830;&#39034;</span>
&#30007;&#31070; <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; ['&#21776;&#39532;&#20754;', '&#24352;&#20840;&#34507;']</span>
</code></pre>
</div>
</div>


<div id="outline-container-org108f999" class="outline-2">
<h2 id="org108f999">Tail Calling</h2>
<div class="outline-text-2" id="text-org108f999">
<p>
这可以说是最令人高兴的feature了,在js里写递归实在是容易爆栈的一件事情.
</p>


<figure>
<img src="./images/tail-recur.gif" alt="tail-recur.gif">

</figure>

<p>
终于, 终于有了尾递归优化. 虽然大部分浏览器,包括firefox都没有实现, 但其实我们已经可以用中间编译器babel帮我们编译成
优化过的尾递归.
</p>

<pre class="code"><code><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">a</span>(<span style="color: #b8860b;">b</span>){
  <span style="color: #00008b;">if</span>(b&lt;0)<span style="color: #00008b;">return</span> <span style="color: #8b0000;">"hehe"</span>
  <span style="color: #00008b;">return</span> a(b-1)
}
</code></pre>

<p>
duang的一下就变成了循环. 妈的再也不用担心我的 <del>菊花</del> 栈被爆了.
</p>

<pre class="code"><code><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">a</span>(<span style="color: #b8860b;">_x</span>) {
  <span style="color: #00008b;">var</span> <span style="color: #b8860b;">_again</span> = <span style="color: #6b8e23;">true</span>;

  _function: <span style="color: #00008b;">while</span> (_again) {
    _again = <span style="color: #6b8e23;">false</span>;
    <span style="color: #00008b;">var</span> <span style="color: #b8860b;">b</span> = _x;

    <span style="color: #00008b;">if</span> (b &lt; 0) {
      <span style="color: #00008b;">return</span> <span style="color: #8b0000;">"hehe"</span>;
    }_x = b - 1;
    _again = <span style="color: #6b8e23;">true</span>;
    <span style="color: #00008b;">continue</span> _function;
  }
}
</code></pre>
</div>
</div>

<div id="outline-container-orgb2d707d" class="outline-2">
<h2 id="orgb2d707d">Template Strings</h2>
<div class="outline-text-2" id="text-orgb2d707d">
<p>
ruby和coffeescript里面这个很fancy的东西
</p>
<pre class="code"><code>hi=<span style="color: #8b0000;">'&#20182;&#26159;'</span>
<span style="color: #228b22;">puts</span> <span style="color: #8b0000;">"</span><span style="color: #b8860b;">#{hi}</span><span style="color: #8b0000;"> &#20320;&#22969;&#22969;"</span>
</code></pre>
<p>
终于要可以在js里原生使用了
</p>
<pre class="code"><code><span style="color: #00008b;">let</span> <span style="color: #b8860b;">i</span> = <span style="color: #8b0000;">'&#20320;&#20204;'</span>,
    love = <span style="color: #8b0000;">'&#19981;&#33021;&#22312;&#19968;&#36215;'</span>,
    your = <span style="color: #8b0000;">'&#20182;&#26159;'</span>,
    sister = <span style="color: #8b0000;">'&#20320;&#22969;&#22969;'</span>

console.log(<span style="color: #8b0000;">`${i} ${love} ${your} ${sister}`</span>)
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; "&#20320;&#20204; &#19981;&#33021;&#22312;&#19968;&#36215; &#20182;&#26159; &#20320;&#22969;&#22969;"</span>
</code></pre>
</div>
</div>


<div id="outline-container-org3ce12d2" class="outline-2">
<h2 id="org3ce12d2">Class</h2>
<div class="outline-text-2" id="text-org3ce12d2">
<p>
虽然只是 syntax sugar, 但是终于不用怪怪的用函数当对象模板了. 木哈哈哈
</p>

<pre class="code"><code><span style="color: #00008b;">class</span> Duck <span style="color: #00008b;">extends</span> Bird {
    constructor() {
        <span style="color: #00008b;">super</span>();
        <span style="color: #6b8e23;">this</span>.name = <span style="color: #8b0000;">"donald"</span>
        <span style="color: #8c8c8c; font-style: italic;">//</span><span style="color: #8c8c8c; font-style: italic;">...</span>
    }
    say() {
        <span style="color: #00008b;">return</span> <span style="color: #6b8e23;">this</span>.name + <span style="color: #8b0000;">" quack"</span>;
    }
    <span style="color: #00008b;">static</span> say() {
        <span style="color: #00008b;">return</span> <span style="color: #8b0000;">"quack"</span>;
    }
}
</code></pre>
</div>
</div>

<div id="outline-container-orgb878056" class="outline-2">
<h2 id="orgb878056">Promises</h2>
<div class="outline-text-2" id="text-orgb878056">
<p>
虽然已经习惯用更强大的 <a href="https://github.com/cujojs/when">第三方库</a> 干这个事情, 但是原生支持的话也是极好的.
</p>
<pre class="code"><code><span style="color: #00008b;">new</span> <span style="color: #36648b;">Promise</span>((resolve, reject) =&gt; {
    console.log(<span style="color: #8b0000;">'first'</span>)
    setTimeout(resolve, 1000);
}).then(() =&gt; {
    console.log(<span style="color: #8b0000;">'next 1s'</span>)
    <span style="color: #00008b;">throw</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">Error</span>(<span style="color: #8b0000;">"hmm"</span>);
}).<span style="color: #00008b;">catch</span>(err =&gt; {
    console.log(<span style="color: #8b0000;">'finally error'</span>)
})
</code></pre>
</div>
</div>

<div id="outline-container-org4ca1e33" class="outline-2">
<h2 id="org4ca1e33">Generator</h2>
<div class="outline-text-2" id="text-org4ca1e33">
<p>
对于python程序员来说, <code>yield</code> 这个关键字可能再熟悉不过了, 终于, js 也有 <code>yield</code> 了.
</p>


<figure>
<img src="https://i.giphy.com/XFITRJv9IMhi0.gif" alt="XFITRJv9IMhi0.gif">

</figure>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">fibonacci</span> = {
<span id="coderef-iterator" class="coderef-off">  [Symbol.iterator]: <span style="color: #00008b;">function</span>*() {</span>
    <span style="color: #00008b;">var</span> <span style="color: #b8860b;">pre</span> = 0, <span style="color: #b8860b;">cur</span> = 1;
    <span style="color: #00008b;">for</span> (;;) {
      <span style="color: #00008b;">var</span> <span style="color: #b8860b;">temp</span> = pre;
      pre = cur;
      cur += temp;
<span id="coderef-yield" class="coderef-off">      <span style="color: #00008b;">yield</span> cur;</span>
    }
  }
}
</code></pre>

<p>
这短短几行代码里有三个es6的新feature
</p>

<ul class="org-ul">
<li>Symbol: es6的新的primitive类型, <a href="#coderef-iterator" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-iterator');" onmouseout="CodeHighlightOff(this, 'coderef-iterator');"><code>Symbol.iterator</code></a> 是一个全局的symbol</li>
<li>Iterator: 对象的 <a href="#coderef-iterator" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-iterator');" onmouseout="CodeHighlightOff(this, 'coderef-iterator');"><code>iterator</code></a> 上挂的函数会在被遍历的时候x调用, 如 <a href="#coderef-forof" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-forof');" onmouseout="CodeHighlightOff(this, 'coderef-forof');"><code>for..of</code></a></li>
</ul>
<pre class="code"><code><span id="coderef-forof" class="coderef-off"><span style="color: #00008b;">for</span> (<span style="color: #00008b;">var</span> <span style="color: #b8860b;">n</span> of fibonacci) {</span>
  <span style="color: #00008b;">if</span> (n &gt; 100)
    <span style="color: #00008b;">break</span>;
  console.log(n);
}
</code></pre>
<ul class="org-ul">
<li>Generator: <a href="#coderef-iterator" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-iterator');" onmouseout="CodeHighlightOff(this, 'coderef-iterator');"><code>function*</code></a> 声明该函数为生成器函数, 在每次被调用的时候返回 <a href="#coderef-yield" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-yield');" onmouseout="CodeHighlightOff(this, 'coderef-yield');"><code>yield</code></a> 的值.</li>
</ul>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
Chrome有一个 feature toggle 可以打开部分 es6 功能 <code>chrome://flags/#enable-javascript-harmony</code>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<footer>
  <p>Author: root <a aria-label="Follow @jcouyang on GitHub" data-count-aria-label="# followers on GitHub" data-count-api="/users/jcouyang#followers" data-count-href="/jcouyang/followers" href="https://github.com/jcouyang" class="github-button">Follow @jcouyang</a></p>
  <p>Modified: 2019-04-06 Sat 13:41</p>
  <p>Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.1 (<a href="https://orgmode.org">Org</a> mode 9.2.2) &#215; <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.
  <input type="swiftype" class="st-default-search-input" placeholder="Search"/>
  <a class="gumroad-button" href="https://gum.co/grokking-monad?wanted=true" target="_blank" data-gumroad-single-product="true">范畴论装逼指南，请自觉排队装逼</a>
  <div id="danmaku-comments"></div>
  <div id="disqus_thread"></div>
</footer>
</div>
</body>
</html>
