<!DOCTYPE html>
<html>
<head>
<!-- 2016-12-24 Sat 13:35 -->
<meta  charset="utf-8">
<meta  name="viewport" content="width=device-width, initial-scale=1">
<title>Clojure 风格的 JavaScript 并发编程</title>
<meta  name="generator" content="Org-mode">
<meta  name="author" content="Jichao Ouyang">
<meta  name="description" content="用原生 javascript es6 实现类似clojure core.async 风格的异步任务, 拜拜 callback hell"
>
<meta  name="keywords" content="javascript, es6, clojure, clojurescript, core.async, ecmascript6, golang, go, callback hell">
<link rel="icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/pixyll.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="http://blog.oyanglul.us/index.xml"/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.0/gh-fork-ribbon.min.css" />
<!--[if lt IE 9]>
     <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.0/gh-fork-ribbon.ie.min.css" />
     <![endif]--> 
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<header>
    <a accesskey="h" href="/index.html"> HOME </a> |
    <a href="#" id="edit-in-github">EDIT</a> |
    <a href="/index.xml">RSS</a> |
    <a href="/archive.html">ARCHIVE</a> |
    <a accesskey="H" href="/jichao.ouyang.html">ABOUT</a>
</header>
</div>
<div id="content">
<header>
<h1 class="title">Clojure 风格的 JavaScript 并发编程</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">TL;DR SLIDES</a></li>
<li><a href="#orgheadline2">Communicating Sequential Processes</a>
<ul>
<li><a href="#orgheadline3">什么是并发</a></li>
<li><a href="#orgheadline4">异步与多线程</a></li>
<li><a href="#orgheadline5">CSP</a>
<ul>
<li><a href="#orgheadline6">Event loop</a></li>
<li><a href="#orgheadline7">CSP, Channel, Goroutines</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline8">CSP in JavaScript</a>
<ul>
<li><a href="#orgheadline9">Generator</a></li>
<li><a href="#orgheadline10">Goroutines in JavaScript</a></li>
<li><a href="#orgheadline11">timeout</a></li>
<li><a href="#orgheadline12">take &lt;!</a></li>
<li><a href="#orgheadline13">put &gt;!</a></li>
<li><a href="#orgheadline14">JavaScript 版本 的 CSP</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<ul class="org-ul">
<li><b><a href="./clojure-core.async-essence-in-native-javascript.html">JavaScript玩转Clojure大法之 - 并发编程</a></b></li>
<li><a href="./clojure-essence-in-javascript-transducer.html">JavaScript玩转Clojure大法之 - Transducer</a></li>
<li><a href="./clojure-essence-in-javascript-trampoline.html">JavaScript玩转Clojure大法之 - Trampoline</a></li>
<li><a href="./clojure-essence-in-javascript-macro.html">JavaScript玩转Clojure大法之 - Macro (1)</a></li>
</ul>

<p>
在看到第一行JavaScript代码之前，我要啰嗦一下为什么要用 clojure core.async 的异步风格。
</p>
<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">TL;DR SLIDES</h2>
<div class="outline-text-2" id="text-orgheadline1">
<iframe src="http://git.io/js-csp" width="800" height="600" seamless="true"></iframe>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">Communicating Sequential Processes</h2>
<div class="outline-text-2" id="text-orgheadline2">
<p>
通信顺序进程, 是计算机科学中用于一种描述并发系统中交互的形式语言, 简称CSP, 来源于C.A.R Hoare 1978年的论文. 
没错了, Hoare就是发明 <del>让我们算法课纠结得快挂科的</del> 快排算法的那位大牛. 
</p>

<p>
CSP最近由于Go语言的兴起突然复活, <a href="http://talks.golang.org/2012/concurrency.slide#1">Go</a>实现了CSP并发编程, 并且起名叫 <i>goroutines and channels</i>, 由于实在是太好用了, Clojure 也加入了
CSP的阵营, 叫做 Core.async.
</p>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3">什么是并发</h3>
<div class="outline-text-3" id="text-orgheadline3">
<p>
并发可能很容易和并行混淆, 但是结合我们自己想一想,还是很容易分得清的.
</p>


<figure>
<p><img src="./images/typing.gif" alt="typing.gif">
</p>
</figure>

<p>
如果我正在上班写代码,想加个班然后发个短信给老婆说晚点回, 发完以后继续敲代码. 那么发短信和敲代码两个任务就是 <b>并发</b>.
</p>

<p>
但如果我还特别喜欢音乐, 所以我边听音乐边敲代码, 那么交代吗和听音乐两个任务就是并行了.
</p>

<p>
所以说, 并行与并发的最大区别就是后者任务之间是互相阻塞的, 任务不能同时运行,因此在执行一个任务时就得阻塞另外一个任务.
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4">异步与多线程</h3>
<div class="outline-text-3" id="text-orgheadline4">
<p>
说到并发, 大概都会联想到多线程.
</p>

<p>
继续敲代码这个例子, 我现在fork出来一个手发短信, 但是我还是只有一个脑袋, 在发短信的时候我的脑子还是只能集中在
如何编制一个理由向老婆请假, 而另外两只手只能放在键盘上什么也改不了, 直到短信发出去, 再继续写代码.
</p>


<figure>
<p><img src="./images/octo-leela.gif" alt="octo-leela.gif">
</p>
</figure>

<p>
所以多线程开销还是很大(我得再长一个手&#x2026;完了还要缩回去&#x2026;), 而且其他两只手其实是闲置(阻塞)着的.
</p>


<figure>
<p><img src="https://www.evernote.com/shard/s23/sh/a65f9743-792e-4f57-8108-ede856b3f464/725cdaf31754164ac80e82f1cbf6f5d6/deep/0/Csp.png" alt="Csp.png">
</p>
</figure>

<p>
因此, 另外一种更省资源的处理并发的方式就出现了&#x2013;异步. 对了, 就是我们在js里经常发ajax的那个异步.
</p>

<p>
比如我还是两只手, 我发完短信继续就敲代码了, 这时, 老婆给我回了一条短信, 那我放下手中的活, 拿起手机看看居然说
同意, 于是放下手机继续敲代码了.
</p>

<p>
注意这段动作与之前多线程的区别, 多线程的场景是我fork了第三只手, 而那只手在我敲代码是一直握着手机, 等待着老婆的回复.
于是异步是不是比多线程的情况少用了只胳膊而且利用率更高呢.
</p>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-3">
<h3 id="orgheadline5">CSP</h3>
<div class="outline-text-3" id="text-orgheadline5">
<p>
那么你就要问了, 你是怎么知道手机响的, 还不是要开一个线程让耳朵监听着. 对的, 但是异步只需要很少的有限个线程就好了, 比如我有十个手机
要发给十个老婆, 我还是两个线程, 而如果是多线程的话我要fork出来十只手. JS的异步就是这么干的, 一个专门
的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/EventLoop">event loop</a> 用于挂各种需要执行的任务.
</p>
</div>

<div id="outline-container-orgheadline6" class="outline-4">
<h4 id="orgheadline6">Event loop</h4>
<div class="outline-text-4" id="text-orgheadline6">
<p>
Event loop 模式非常简单, 浏览器运行javascript就是从 event loop 里面取任务, 队列中任务的来源为函数调用栈与事件绑定.比如
</p>
<ul class="org-ul">
<li>每写一行 <code>f()</code>, 就会加到event loop的队列中, event loop运行该任务直到调用栈</li>
<li>每写一次执行到 <code>setTimeout(somefunction,0)</code>, 会立马往队列加入 <code>somefunction</code> (如果不是0, 则是n长时间后加入队列)</li>
</ul>


<figure>
<p><img src="https://www.evernote.com/shard/s23/sh/609488c9-b816-425e-9031-f0a2b1ac72f8/a3b5af41e63435d2b3fef4bff653b790/deep/0/Csp.png" alt="Csp.png">
</p>
</figure>

<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">a</span>(){
  console.log(<span style="color: #8b0000;">'a'</span>);
}
<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">b</span>(){
  console.log(<span style="color: #8b0000;">'b'</span>);
}
<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">timeout</span>(){
  console.log(<span style="color: #8b0000;">'timeout'</span>);
}
setTimeout(timeout,0);
a();
b();
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; "a"</span>
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; "b"</span>
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; "timeout"</span>
</pre>
</div>

<p>
所以这样一行代码的消息队列应该是这样的(处理顺序从左至右)
</p>

<!-- This HTML table template is generated by emacs 24.5.1 -->
<table border="1">
  <tr>
    <td align="left" valign="top">
      setTimeout&nbsp;
    </td>
    <td align="left" valign="top">
      a&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      b&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      timeout&nbsp;
    </td>
  </tr>
</table>


<p>
现在我们用JS的异步模型来再实现一下前面的例子
</p>

<a class="jsbin-embed" href="http://jsbin.com/jobope/2/embed?js,console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>

<p>
js把判断老婆同不同意的函数挂到了event loop队列中, 就继续执行下一任务, 如果有短信回复的事件触发,那么就执行这个函数,也就是看看短信老婆同不同意.
</p>

<p>
用event loop这种事件回调的形式看起来还挺高效的, 而且js一直也是这么用的, 但是当事件多了之后就会出现 <i>Callback hell</i>,
为什么说是 callback hell 呢, 仔细看看前面例子中
</p>


<figure>
<p><img src="http://seajones.co.uk/content/images/2014/12/callback-hell.png" alt="callback-hell.png">
</p>
</figure>

<p>
只要有一个函数式callback,那么所有调用他的函数都要变成callback了
</p>

<p>
于是JS世界又出现了 Promises, 而且很快红火了起来, 因为他能平铺开这些callback函数. 其实就是把函数体内的callback放到了 <code>then</code> 里然后 <code>chain</code> 起来.
</p>

<blockquote>
<p>
但是callback hell 变成了串联的 callback hell, 原来是一大坨,现在是串起来的一大坨
</p>
</blockquote>

<p>
于是CSP及时跑出来把大家从callback hell中拯救出来.
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-4">
<h4 id="orgheadline7">CSP, Channel, Goroutines</h4>
<div class="outline-text-4" id="text-orgheadline7">
<p>
CSP 的概念非常简单, 想象一下 event loop
</p>

<ol class="org-ol">
<li>CSP 把这个event loop的消息队列转换成一个数据队列, 把这个队列叫做 <i>channel</i></li>
<li>任务等待队列中的数据</li>
</ol>


<figure>
<p><img src="https://www.evernote.com/shard/s23/sh/8c5eadb4-678b-4aec-b7df-ca03ffc36da5/775db9fd0da008539b45b924d30c1c50/deep/0/Csp.png" alt="Csp.png">
</p>
</figure>

<p>
这样就成功的把任务和异步数据成功从 callback hell 分离开来.
</p>

<p>
等等, 还是刚才发短信的例子, 我们来用CSP实现一遍
</p>

<div class="org-src-container">

<pre class="src src-clojure">(<span style="color: #00008b;">def</span> <span style="color: #b8860b;">working</span> (chan))
(<span style="color: #00008b;">def</span> <span style="color: #b8860b;">texting</span> (chan))

(<span style="color: #00008b;">defn</span> <span style="color: #6a5acd;">boss-yelling</span> []
  (go-loop [no 1]
    (&lt;! (timeout 1000))
    (&gt;! working (str <span style="color: #8b0000;">"bose say: work "</span> no))
    (<span style="color: #00008b;">recur</span> (+ no 1))))

<span id="coderef-wife" class="coderef-off">(<span style="color: #00008b;">defn</span> <span style="color: #6a5acd;">wife-texting</span> []</span>
  (go-loop []
    (&lt;! (timeout 4000))
    (&gt;! texting <span style="color: #8b0000;">"wife say: come home!"</span>)
    (<span style="color: #00008b;">recur</span>)))

<span id="coderef-reading" class="coderef-off">(<span style="color: #00008b;">defn</span> <span style="color: #6a5acd;">reading-text</span> []</span>
  (go-loop []
    (println (&lt;! texting) <span style="color: #8b0000;">"me: ignore"</span>)
    (<span style="color: #00008b;">recur</span>)))

(<span style="color: #00008b;">defn</span> <span style="color: #6a5acd;">work</span> []
  (go-loop []
    (println (&lt;! working) <span style="color: #8b0000;">" me: working"</span>)
    (<span style="color: #00008b;">recur</span>)))

(boss-yelling)
(wife-texting)
(work)
(reading-text)
</pre>
</div>
<a class="jsbin-embed" href="http://jsbin.com/muliva/2/embed?console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>

<p>
不懂clojure没有关系,我可以解释 <del>我不听我不听我不听!</del> 而且我还会在后面用JS实现一遍
</p>
<ul class="org-ul">
<li>可以看出 boss yelling, wife texting, me working 和 reading text 四个任务是 <b>并发</b> 进行的</li>
<li>所有任务都相互没有依赖, 完全没有callback, 没有哪个任务是另一个任务的callback, 他们都只依赖于 <code>working</code> 和 <code>texting</code> 两个channel</li>
<li>其中的 <code>go-loop</code> 神奇的地方是, 它循环获取channel中的数据, 当队列空时,它会 <del>阻塞</del> parking, 因为并没有阻塞线程, 而是保存当前状态, 继续去试另一个 <code>go</code> 语句.</li>
<li>拿 <code>work</code> 来说, <code>(&lt;! texting)</code> 就是从 channel texting 中取数据, 如果texting为空,则parking</li>
<li>而对于任务 <code>wife-texting</code>, <code>(&gt;! texting "wife say: come home!")</code> 是往 channel texting 中加数据, 如果 channel 已满, 则 parking</li>
</ul>
</div>
</div>
</div>
</div>


<div id="outline-container-orgheadline8" class="outline-2">
<h2 id="orgheadline8">CSP in JavaScript<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup></h2>
<div class="outline-text-2" id="text-orgheadline8">
<p>
瞅瞅我们都要实现写什么
</p>
<ul class="org-ul">
<li>goroutines</li>
<li>timeout</li>
<li>take (&lt;!)</li>
<li>put (&gt;!)</li>
</ul>
<p>
当然首先要实现最重要的 goroutines, 但是在这之前, 让我们看看JavaScript一个碉堡的新feature &#x2013; <i>generator</i>
</p>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9">Generator</h3>
<div class="outline-text-3" id="text-orgheadline9">
<p>
<a href="http://blog.dev/javascript/essential-ecmascript6.html#sec-9">ES6 终于支持了Generator</a>, 目前Firefox与Chrome都已经实现.<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> Generator在每次被调用时放回 <code>yield</code> 的值, 并保存状态, 下次调用时继续运行. 
这种功能听起来刚好符合上例中神奇的 parking 的行为, 因此完全可以用 generator 来实现 CSP.
</p>


<figure>
<p><img src="./images/bender-generator.gif" alt="bender-generator.gif">
</p>
</figure>
</div>
</div>


<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10">Goroutines in JavaScript</h3>
<div class="outline-text-3" id="text-orgheadline10">
<p>
goroutines 其实就是一个状态机, generator为输入
</p>
<ul class="org-ul">
<li>一个函数</li>
<li>他可以接受一个 <a href="#coderef-generator"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-generator');" onmouseout="CodeHighlightOff(this, 'coderef-generator');">generator</a></li>
<li>如果generator没有下一步,则结束</li>
<li>如果该步的返回值状态为 park, <a href="#coderef-parking"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-parking');" onmouseout="CodeHighlightOff(this, 'coderef-parking');">那么就是什么也不做, 过一会再来进入状态机尝试</a></li>
<li>如果为 continue, <a href="#coderef-continue"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-continue');" onmouseout="CodeHighlightOff(this, 'coderef-continue');">这接着generator下一步, 继续循环</a></li>
</ul>
<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">go_</span>(<span style="color: #b8860b;">machine</span>, <span style="color: #b8860b;">step</span>) {
  <span style="color: #00008b;">while</span>(!step.done) {
    <span style="color: #00008b;">var</span> <span style="color: #b8860b;">arr</span>   = step.value(),
        state = arr[0],
        value = arr[1];
    <span style="color: #00008b;">switch</span> (state) {
      <span style="color: #00008b;">case</span> <span style="color: #8b0000;">"park"</span>:
<span id="coderef-parking" class="coderef-off">        setTimeout(<span style="color: #00008b;">function</span>() { go_(machine, step); },0);</span>
        <span style="color: #00008b;">return</span>;
      <span style="color: #00008b;">case</span> <span style="color: #8b0000;">"continue"</span>:
<span id="coderef-continue" class="coderef-off">        step = machine.next(value);</span>
        <span style="color: #00008b;">break</span>;
    }
  }
}

<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">go</span>(<span style="color: #b8860b;">machine</span>) {
<span id="coderef-generator" class="coderef-off">  <span style="color: #00008b;">var</span> <span style="color: #b8860b;">gen</span> = machine();</span>
  go_(gen, gen.next());
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11">timeout</h3>
<div class="outline-text-3" id="text-orgheadline11">
<p>
一个类似于 thread sleep 的功能, 想让任务能等待个一段时间再执行,
只需要在 <code>go_</code> 中加入一个 timeout 的 <code>case</code> 就好了
</p>
<div class="org-src-container">

<pre class="src src-javascript">...
  <span style="color: #00008b;">case</span> <span style="color: #8b0000;">'timeout'</span>:
    setTimeout(<span style="color: #00008b;">function</span>(){ go_(machine, machine.next());}, value);
    <span style="color: #00008b;">return</span>;
...
</pre>
</div>
<p>
如果状态是timeout, 那么等待 <code>value</code> 那么长的时间再执行generator下一步.
</p>

<p>
另外还需要一个返回 timeout channel 的函数
</p>
<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">timeout</span>(<span style="color: #b8860b;">interval</span>){
  <span style="color: #00008b;">var</span> <span style="color: #b8860b;">chan</span> = [interval];
  chan.name = <span style="color: #8b0000;">'timeout'</span>;
  <span style="color: #00008b;">return</span> chan;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12">take &lt;!</h3>
<div class="outline-text-3" id="text-orgheadline12">
<p>
当 generator 从 channel 中 take 数据时
</p>
<ul class="org-ul">
<li>如果 channel 空, 状态变为 park</li>
<li>如果 channel 非空, 获得数据, 状态改成 continue</li>
<li>如果是 timeout channel, 状态置成 timeout</li>
</ul>

<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">take</span>(<span style="color: #b8860b;">chan</span>) {
  <span style="color: #00008b;">return</span> <span style="color: #00008b;">function</span>() {
    <span style="color: #00008b;">if</span>(chan.name === <span style="color: #8b0000;">'timeout'</span>){
      <span style="color: #00008b;">return</span> [<span style="color: #8b0000;">'timeout'</span>, chan.pop()];
    }<span style="color: #00008b;">else</span> <span style="color: #00008b;">if</span>(chan.length === 0) {
      <span style="color: #00008b;">return</span> [<span style="color: #8b0000;">"park"</span>, <span style="color: #6b8e23;">null</span>];
    } <span style="color: #00008b;">else</span> {
      <span style="color: #00008b;">var</span> <span style="color: #b8860b;">val</span> = chan.pop();
      <span style="color: #00008b;">return</span> [<span style="color: #8b0000;">"continue"</span>, val];
    }
  };
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13">put &gt;!</h3>
<div class="outline-text-3" id="text-orgheadline13">
<p>
当 generator 往 channel 中 put 数据
</p>
<ul class="org-ul">
<li>如果 channel 空, 状态变为 continue, 放入数据</li>
<li>如果 channel 非空, parking</li>
</ul>

<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">put</span>(<span style="color: #b8860b;">chan</span>, <span style="color: #b8860b;">val</span>) {
  <span style="color: #00008b;">return</span> <span style="color: #00008b;">function</span>() {
    <span style="color: #00008b;">if</span>(chan.length === 0) {
      chan.unshift(val);
      <span style="color: #00008b;">return</span> [<span style="color: #8b0000;">"continue"</span>, <span style="color: #6b8e23;">null</span>];
    } <span style="color: #00008b;">else</span> {
      <span style="color: #00008b;">return</span> [<span style="color: #8b0000;">"park"</span>, <span style="color: #6b8e23;">null</span>];
    }
  };
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14">JavaScript 版本 的 CSP</h3>
<div class="outline-text-3" id="text-orgheadline14">
<p>
现在可以原原本本的将之前的clojure的例子翻译成JavaScript了
</p>
<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">boss_yelling</span>(){
  go(<span style="color: #00008b;">function</span>*(){
    <span style="color: #00008b;">for</span>(<span style="color: #00008b;">var</span> <span style="color: #b8860b;">i</span>=0;;i++){
      <span style="color: #00008b;">yield</span> take(timeout(1000));
      <span style="color: #00008b;">yield</span> put(work, <span style="color: #8b0000;">"boss say: work "</span>+i);
    }
  });
}

<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">wife_texting</span>(){
  go(<span style="color: #00008b;">function</span>*(){
    <span style="color: #00008b;">for</span>(;;){
      <span style="color: #00008b;">yield</span> take(timeout(4000));
      <span style="color: #00008b;">yield</span> put(text, <span style="color: #8b0000;">"wife say: come home"</span>);
    }
  });
}

<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">working</span>(){
  go(<span style="color: #00008b;">function</span>*(){
    <span style="color: #00008b;">for</span>(;;){
      <span style="color: #00008b;">var</span> <span style="color: #b8860b;">task</span> = <span style="color: #00008b;">yield</span> take(work);
      console.log(task, <span style="color: #8b0000;">"me working"</span>);
    }
  });
}

<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">texting</span>(){
  go(<span style="color: #00008b;">function</span>*(){
    <span style="color: #00008b;">for</span>(;;){
      <span style="color: #00008b;">var</span> <span style="color: #b8860b;">read</span> = <span style="color: #00008b;">yield</span> take(text);
      console.log(read, <span style="color: #8b0000;">"me ignoring"</span>);
    }
  });
}
boss_yelling();
wife_texting();
working();
texting();
</pre>
</div>

<p>
完整代码
</p>
<a class="jsbin-embed" href="http://jsbin.com/savepe/5/embed?js,console">JS Bin</a><script src="http://static.jsbin.com/js/embed.js"></script>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
里面的go的实现来自 <a href="http://swannodette.github.io/2013/08/24/es6-generators-and-csp/">http://swannodette.github.io/2013/08/24/es6-generators-and-csp/</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
Chrome有一个 feature toggle 可以打开部分 es6 功能.  打开 <code>chrome://flags/#enable-javascript-harmony</code> 设置为 <code>true</code>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<footer>
<p>Author: Jichao Ouyang <a aria-label="Follow @jcouyang on GitHub" data-count-aria-label="# followers on GitHub" data-count-api="/users/jcouyang#followers" data-count-href="/jcouyang/followers" href="https://github.com/jcouyang" class="github-button">Follow @jcouyang</a></p>
<p>Modified: 2016-12-24 Sat 13:33</p>
<p>Generated by: <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.3.6)</p>
<p>&lt;Publish&gt; with _(:з」∠)_ by <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.
<div class="org-center">
    <input type="swiftype" class="st-default-search-input" placeholder="Search"/>
</div>
<a class="github-fork-ribbon right-bottom fixed" href="https://github.com/jcouyang/blog" title="Fork me on GitHub">Fork me on GitHub</a>
</footer>
<script>
 (function(){
   document.getElementById('edit-in-github').addEventListener("click",function(){
     var pathname = window.location.pathname;
     window.location.href = "https://github.com/jcouyang/blog/edit/master/org"+pathname.replace(".html",".org");
   })
 })()
</script>
<!-- Google Analystics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-32314154-10', 'auto');
  ga('send', 'pageview');

</script>
<script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- blog -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-6604550863422842"
     data-ad-slot="7967742338"
     data-ad-format="auto"></ins>
<script>
 (adsbygoogle = window.adsbygoogle || []).push({});
</script>
<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
 var disqus_shortname = 'orgblog';
 var href = window.location.href;
 href.replace(/^https/, 'http');
 var disqus_url = href;
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<!-- Swiftype Search -->
<script type="text/javascript">
 (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
     (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
     e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
 })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');
 
 _st('install','eGLqWnAM75a66SiXKVW3','2.0.0');
</script>
</div>
</body>
</html>
