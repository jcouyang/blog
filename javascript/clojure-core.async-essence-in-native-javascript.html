<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2020-05-08 Fri 12:21 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Clojure 风格的 JavaScript 并发编程</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Jichao Ouyang">
<meta name="description" content="用原生 javascript es6 实现类似clojure core.async 风格的异步任务, 拜拜 callback hell"
>
<meta name="keywords" content="javascript, es6, clojure, clojurescript, core.async, ecmascript6, golang, go, callback hell">
<link rel="icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/toc.css"/>
<link rel="stylesheet" href="/style/tufte.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="https://feeds.oyanglul.us/JichaoOuyangsBlog"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJRFJGX"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<header>
    <a accesskey="h" href="/index.html"> HOME </a> |
    <a href="#" id="edit-in-github">EDIT</a> |
    <a href="https://feeds.oyanglul.us/JichaoOuyangsBlog">RSS</a> |
    <a href="https://blog.oyanglul.us/theindex">INDEX</a> |
    <a accesskey="H" href="/jichao.ouyang.html">ABOUT</a> |
    <a href="https://github.com/jcouyang/blog">GITHUB</a>
</header>
</div>
<div id="content">
<header>
<h1 class="title">Clojure 风格的 JavaScript 并发编程</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org0354ed6">TL;DR SLIDES</a></li>
<li><a href="#org33ce530">Communicating Sequential Processes</a>
<ul>
<li><a href="#orgb4190ee">什么是并发</a></li>
<li><a href="#orgc6478a0">异步与多线程</a></li>
<li><a href="#orgdfe6285">CSP</a>
<ul>
<li><a href="#orgd6ccfb5">Event loop</a></li>
<li><a href="#org6ee5424">CSP, Channel, Goroutines</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org979763b">CSP in JavaScript</a>
<ul>
<li><a href="#org65a7890">Generator</a></li>
<li><a href="#org6eed5d9">Goroutines in JavaScript</a></li>
<li><a href="#org55e1325">timeout</a></li>
<li><a href="#org982fca9">take &lt;!</a></li>
<li><a href="#org71a70b1">put &gt;!</a></li>
<li><a href="#org1ee7eb7">JavaScript 版本 的 CSP</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<p>
<a href="https://blog.oyanglul.us/shutting-down-gulugulu">📣 不要再找了, 弹幕功能已关闭</a>
</p>
<ul class="org-ul">
<li><b><a href="./clojure-core.async-essence-in-native-javascript.html">JavaScript玩转Clojure大法之 - 并发编程</a></b></li>
<li><a href="./clojure-essence-in-javascript-transducer.html">JavaScript玩转Clojure大法之 - Transducer</a></li>
<li><a href="./clojure-essence-in-javascript-trampoline.html">JavaScript玩转Clojure大法之 - Trampoline</a></li>
<li><a href="./clojure-essence-in-javascript-macro.html">JavaScript玩转Clojure大法之 - Macro (1)</a></li>
</ul>

<p>
在看到第一行JavaScript代码之前，我要啰嗦一下为什么要用 clojure core.async 的异步风格。
</p>
<div id="outline-container-org0354ed6" class="outline-2">
<h2 id="org0354ed6">TL;DR SLIDES</h2>
<div class="outline-text-2" id="text-org0354ed6">
<iframe src="https://git.io/js-csp" width="800" height="600" seamless="true"></iframe>
</div>
</div>

<div id="outline-container-org33ce530" class="outline-2">
<h2 id="org33ce530">Communicating Sequential Processes</h2>
<div class="outline-text-2" id="text-org33ce530">
<p>
通信顺序进程, 是计算机科学中用于一种描述并发系统中交互的形式语言, 简称CSP, 来源于C.A.R Hoare 1978年的论文. 
没错了, Hoare就是发明 <del>让我们算法课纠结得快挂科的</del> 快排算法的那位大牛. 
</p>

<p>
CSP最近由于Go语言的兴起突然复活, <a href="http://talks.golang.org/2012/concurrency.slide#1">Go</a>实现了CSP并发编程, 并且起名叫 <i>goroutines and channels</i>, 由于实在是太好用了, Clojure 也加入了
CSP的阵营, 叫做 Core.async.
</p>
</div>

<div id="outline-container-orgb4190ee" class="outline-3">
<h3 id="orgb4190ee">什么是并发</h3>
<div class="outline-text-3" id="text-orgb4190ee">
<p>
并发可能很容易和并行混淆, 但是结合我们自己想一想,还是很容易分得清的.
</p>


<figure>
<img src="./images/typing.gif" alt="typing.gif">

</figure>

<p>
如果我正在上班写代码,想加个班然后发个短信给老婆说晚点回, 发完以后继续敲代码. 那么发短信和敲代码两个任务就是 <b>并发</b>.
</p>

<p>
但如果我还特别喜欢音乐, 所以我边听音乐边敲代码, 那么交代吗和听音乐两个任务就是并行了.
</p>

<p>
所以说, 并行与并发的最大区别就是后者任务之间是互相阻塞的, 任务不能同时运行,因此在执行一个任务时就得阻塞另外一个任务.
</p>
</div>
</div>

<div id="outline-container-orgc6478a0" class="outline-3">
<h3 id="orgc6478a0">异步与多线程</h3>
<div class="outline-text-3" id="text-orgc6478a0">
<p>
说到并发, 大概都会联想到多线程.
</p>

<p>
继续敲代码这个例子, 我现在fork出来一个手发短信, 但是我还是只有一个脑袋, 在发短信的时候我的脑子还是只能集中在
如何编制一个理由向老婆请假, 而另外两只手只能放在键盘上什么也改不了, 直到短信发出去, 再继续写代码.
</p>


<figure>
<img src="./images/octo-leela.gif" alt="octo-leela.gif">

</figure>

<p>
所以多线程开销还是很大(我得再长一个手&#x2026;完了还要缩回去&#x2026;), 而且其他两只手其实是闲置(阻塞)着的.
</p>


<figure>
<img src="https://www.evernote.com/shard/s23/sh/a65f9743-792e-4f57-8108-ede856b3f464/725cdaf31754164ac80e82f1cbf6f5d6/deep/0/Csp.png" alt="Csp.png">

</figure>

<p>
因此, 另外一种更省资源的处理并发的方式就出现了&#x2013;异步. 对了, 就是我们在js里经常发ajax的那个异步.
</p>

<p>
比如我还是两只手, 我发完短信继续就敲代码了, 这时, 老婆给我回了一条短信, 那我放下手中的活, 拿起手机看看居然说
同意, 于是放下手机继续敲代码了.
</p>

<p>
注意这段动作与之前多线程的区别, 多线程的场景是我fork了第三只手, 而那只手在我敲代码是一直握着手机, 等待着老婆的回复.
于是异步是不是比多线程的情况少用了只胳膊而且利用率更高呢.
</p>
</div>
</div>

<div id="outline-container-orgdfe6285" class="outline-3">
<h3 id="orgdfe6285">CSP</h3>
<div class="outline-text-3" id="text-orgdfe6285">
<p>
那么你就要问了, 你是怎么知道手机响的, 还不是要开一个线程让耳朵监听着. 对的, 但是异步只需要很少的有限个线程就好了, 比如我有十个手机
要发给十个老婆, 我还是两个线程, 而如果是多线程的话我要fork出来十只手. JS的异步就是这么干的, 一个专门
的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/EventLoop">event loop</a> 用于挂各种需要执行的任务.
</p>
</div>

<div id="outline-container-orgd6ccfb5" class="outline-4">
<h4 id="orgd6ccfb5">Event loop</h4>
<div class="outline-text-4" id="text-orgd6ccfb5">
<p>
Event loop 模式非常简单, 浏览器运行javascript就是从 event loop 里面取任务, 队列中任务的来源为函数调用栈与事件绑定.比如
</p>
<ul class="org-ul">
<li>每写一行 <code>f()</code>, 就会加到event loop的队列中, event loop运行该任务直到调用栈</li>
<li>每写一次执行到 <code>setTimeout(somefunction,0)</code>, 会立马往队列加入 <code>somefunction</code> (如果不是0, 则是n长时间后加入队列)</li>
</ul>


<figure>
<img src="https://www.evernote.com/shard/s23/sh/609488c9-b816-425e-9031-f0a2b1ac72f8/a3b5af41e63435d2b3fef4bff653b790/deep/0/Csp.png" alt="Csp.png">

</figure>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">a</span>(){
  console.log(<span style="color: #8b0000;">'a'</span>);
}
<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">b</span>(){
  console.log(<span style="color: #8b0000;">'b'</span>);
}
<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">timeout</span>(){
  console.log(<span style="color: #8b0000;">'timeout'</span>);
}
setTimeout(timeout,0);
a();
b();
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; "a"</span>
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; "b"</span>
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; "timeout"</span>
</pre>
</div>

<p>
所以这样一行代码的消息队列应该是这样的(处理顺序从左至右)
</p>

<p>
<del>-----------</del>-----<del>-----</del>---&#x2013;&#x2014;+
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">setTimeout</td>
<td class="org-left">a</td>
<td class="org-left">b</td>
<td class="org-left">timeout</td>
</tr>
</tbody>
</table>
<p>
<del>-----------</del>-----<del>-----</del>---&#x2013;&#x2014;+
</p>


<p>
现在我们用JS的异步模型来再实现一下前面的例子
</p>

<a class="jsbin-embed" href="https://jsbin.com/jobope/2/embed?js,console">JS Bin</a><script src="https://static.jsbin.com/js/embed.js"></script>

<p>
js把判断老婆同不同意的函数挂到了event loop队列中, 就继续执行下一任务, 如果有短信回复的事件触发,那么就执行这个函数,也就是看看短信老婆同不同意.
</p>

<p>
用event loop这种事件回调的形式看起来还挺高效的, 而且js一直也是这么用的, 但是当事件多了之后就会出现 <i>Callback hell</i>,
为什么说是 callback hell 呢, 仔细看看前面例子中
</p>


<figure>
<img src="https://seajones.co.uk/content/images/2014/12/callback-hell.png" alt="callback-hell.png">

</figure>

<p>
只要有一个函数式callback,那么所有调用他的函数都要变成callback了
</p>

<p>
于是JS世界又出现了 Promises, 而且很快红火了起来, 因为他能平铺开这些callback函数. 其实就是把函数体内的callback放到了 <code>then</code> 里然后 <code>chain</code> 起来.
</p>

<div class="epigraph"><blockquote>
<p>
但是callback hell 变成了串联的 callback hell, 原来是一大坨,现在是串起来的一大坨
</p>

</blockquote></div>

<p>
于是CSP及时跑出来把大家从callback hell中拯救出来.
</p>
</div>
</div>

<div id="outline-container-org6ee5424" class="outline-4">
<h4 id="org6ee5424">CSP, Channel, Goroutines</h4>
<div class="outline-text-4" id="text-org6ee5424">
<p>
CSP 的概念非常简单, 想象一下 event loop
</p>

<ol class="org-ol">
<li>CSP 把这个event loop的消息队列转换成一个数据队列, 把这个队列叫做 <i>channel</i></li>
<li>任务等待队列中的数据</li>
</ol>


<figure>
<img src="https://www.evernote.com/shard/s23/sh/8c5eadb4-678b-4aec-b7df-ca03ffc36da5/775db9fd0da008539b45b924d30c1c50/deep/0/Csp.png" alt="Csp.png">

</figure>

<p>
这样就成功的把任务和异步数据成功从 callback hell 分离开来.
</p>

<p>
等等, 还是刚才发短信的例子, 我们来用CSP实现一遍
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00008b;">def</span> <span style="color: #b8860b;">working</span> (chan))
(<span style="color: #00008b;">def</span> <span style="color: #b8860b;">texting</span> (chan))

(<span style="color: #00008b;">defn</span> <span style="color: #6a5acd;">boss-yelling</span> []
  (go-loop [no 1]
    (&lt;! (timeout 1000))
    (&gt;! working (str <span style="color: #8b0000;">"bose say: work "</span> no))
    (<span style="color: #00008b;">recur</span> (+ no 1))))

<span id="coderef-wife" class="coderef-off">(<span style="color: #00008b;">defn</span> <span style="color: #6a5acd;">wife-texting</span> []</span>
  (go-loop []
    (&lt;! (timeout 4000))
    (&gt;! texting <span style="color: #8b0000;">"wife say: come home!"</span>)
    (<span style="color: #00008b;">recur</span>)))

<span id="coderef-reading" class="coderef-off">(<span style="color: #00008b;">defn</span> <span style="color: #6a5acd;">reading-text</span> []</span>
  (go-loop []
    (println (&lt;! texting) <span style="color: #8b0000;">"me: ignore"</span>)
    (<span style="color: #00008b;">recur</span>)))

(<span style="color: #00008b;">defn</span> <span style="color: #6a5acd;">work</span> []
  (go-loop []
    (println (&lt;! working) <span style="color: #8b0000;">" me: working"</span>)
    (<span style="color: #00008b;">recur</span>)))

(boss-yelling)
(wife-texting)
(work)
(reading-text)

</pre>
</div>
<a class="jsbin-embed" href="https://jsbin.com/muliva/2/embed?console">JS Bin</a><script src="https://static.jsbin.com/js/embed.js"></script>

<p>
不懂clojure没有关系,我可以解释 <del>我不听我不听我不听!</del> 而且我还会在后面用JS实现一遍
</p>
<ul class="org-ul">
<li>可以看出 boss yelling, wife texting, me working 和 reading text 四个任务是 <b>并发</b> 进行的</li>
<li>所有任务都相互没有依赖, 完全没有callback, 没有哪个任务是另一个任务的callback, 他们都只依赖于 <code>working</code> 和 <code>texting</code> 两个channel</li>
<li>其中的 <code>go-loop</code> 神奇的地方是, 它循环获取channel中的数据, 当队列空时,它会 <del>阻塞</del> parking, 因为并没有阻塞线程, 而是保存当前状态, 继续去试另一个 <code>go</code> 语句.</li>
<li>拿 <code>work</code> 来说, <code>(&lt;! texting)</code> 就是从 channel texting 中取数据, 如果texting为空,则parking</li>
<li>而对于任务 <code>wife-texting</code>, <code>(&gt;! texting "wife say: come home!")</code> 是往 channel texting 中加数据, 如果 channel 已满, 则 parking</li>
</ul>
</div>
</div>
</div>
</div>


<div id="outline-container-org979763b" class="outline-2">
<h2 id="org979763b">CSP in JavaScript<label for="1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="1" class="margin-toggle"/><span class="sidenote">
里面的go的实现来自 <a href="https://swannodette.github.io/2013/08/24/es6-generators-and-csp/">https://swannodette.github.io/2013/08/24/es6-generators-and-csp/</a>
</span></h2>
<div class="outline-text-2" id="text-org979763b">
<p>
瞅瞅我们都要实现写什么
</p>
<ul class="org-ul">
<li>goroutines</li>
<li>timeout</li>
<li>take (&lt;!)</li>
<li>put (&gt;!)</li>
</ul>
<p>
当然首先要实现最重要的 goroutines, 但是在这之前, 让我们看看JavaScript一个碉堡的新feature &#x2013; <i>generator</i>
</p>
</div>

<div id="outline-container-org65a7890" class="outline-3">
<h3 id="org65a7890">Generator</h3>
<div class="outline-text-3" id="text-org65a7890">
<p>
<a href="https://blog.dev/javascript/essential-ecmascript6.html#sec-9">ES6 终于支持了Generator</a>, 目前Firefox与Chrome都已经实现.<label for="2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="2" class="margin-toggle"/><span class="sidenote">
Chrome有一个 feature toggle 可以打开部分 es6 功能.  打开 <code>chrome://flags/#enable-javascript-harmony</code> 设置为 <code>true</code>
</span> Generator在每次被调用时放回 <code>yield</code> 的值, 并保存状态, 下次调用时继续运行. 
这种功能听起来刚好符合上例中神奇的 parking 的行为, 因此完全可以用 generator 来实现 CSP.
</p>


<figure>
<img src="./images/bender-generator.gif" alt="bender-generator.gif">

</figure>
</div>
</div>


<div id="outline-container-org6eed5d9" class="outline-3">
<h3 id="org6eed5d9">Goroutines in JavaScript</h3>
<div class="outline-text-3" id="text-org6eed5d9">
<p>
goroutines 其实就是一个状态机, generator为输入
</p>
<ul class="org-ul">
<li>一个函数</li>
<li>他可以接受一个 <a href="#coderef-generator" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-generator');" onmouseout="CodeHighlightOff(this, 'coderef-generator');">generator</a></li>
<li>如果generator没有下一步,则结束</li>
<li>如果该步的返回值状态为 park, <a href="#coderef-parking" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-parking');" onmouseout="CodeHighlightOff(this, 'coderef-parking');">那么就是什么也不做, 过一会再来进入状态机尝试</a></li>
<li>如果为 continue, <a href="#coderef-continue" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-continue');" onmouseout="CodeHighlightOff(this, 'coderef-continue');">这接着generator下一步, 继续循环</a></li>
</ul>
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">go_</span>(<span style="color: #b8860b;">machine</span>, <span style="color: #b8860b;">step</span>) {
  <span style="color: #00008b;">while</span>(!step.done) {
    <span style="color: #00008b;">var</span> <span style="color: #b8860b;">arr</span>   = step.value(),
        state = arr[0],
        value = arr[1];
    <span style="color: #00008b;">switch</span> (state) {
      <span style="color: #00008b;">case</span> <span style="color: #8b0000;">"park"</span>:
<span id="coderef-parking" class="coderef-off">        setTimeout(<span style="color: #00008b;">function</span>() { go_(machine, step); },0);</span>
        <span style="color: #00008b;">return</span>;
      <span style="color: #00008b;">case</span> <span style="color: #8b0000;">"continue"</span>:
<span id="coderef-continue" class="coderef-off">        step = machine.next(value);</span>
        <span style="color: #00008b;">break</span>;
    }
  }
}

<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">go</span>(<span style="color: #b8860b;">machine</span>) {
<span id="coderef-generator" class="coderef-off">  <span style="color: #00008b;">var</span> <span style="color: #b8860b;">gen</span> = machine();</span>
  go_(gen, gen.next());
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org55e1325" class="outline-3">
<h3 id="org55e1325">timeout</h3>
<div class="outline-text-3" id="text-org55e1325">
<p>
一个类似于 thread sleep 的功能, 想让任务能等待个一段时间再执行,
只需要在 <code>go_</code> 中加入一个 timeout 的 <code>case</code> 就好了
</p>
<div class="org-src-container">
<pre class="src src-javascript">...
  <span style="color: #00008b;">case</span> <span style="color: #8b0000;">'timeout'</span>:
    setTimeout(<span style="color: #00008b;">function</span>(){ go_(machine, machine.next());}, value);
    <span style="color: #00008b;">return</span>;
...
</pre>
</div>
<p>
如果状态是timeout, 那么等待 <code>value</code> 那么长的时间再执行generator下一步.
</p>

<p>
另外还需要一个返回 timeout channel 的函数
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">timeout</span>(<span style="color: #b8860b;">interval</span>){
  <span style="color: #00008b;">var</span> <span style="color: #b8860b;">chan</span> = [interval];
  chan.name = <span style="color: #8b0000;">'timeout'</span>;
  <span style="color: #00008b;">return</span> chan;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org982fca9" class="outline-3">
<h3 id="org982fca9">take &lt;!</h3>
<div class="outline-text-3" id="text-org982fca9">
<p>
当 generator 从 channel 中 take 数据时
</p>
<ul class="org-ul">
<li>如果 channel 空, 状态变为 park</li>
<li>如果 channel 非空, 获得数据, 状态改成 continue</li>
<li>如果是 timeout channel, 状态置成 timeout</li>
</ul>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">take</span>(<span style="color: #b8860b;">chan</span>) {
  <span style="color: #00008b;">return</span> <span style="color: #00008b;">function</span>() {
    <span style="color: #00008b;">if</span>(chan.name === <span style="color: #8b0000;">'timeout'</span>){
      <span style="color: #00008b;">return</span> [<span style="color: #8b0000;">'timeout'</span>, chan.pop()];
    }<span style="color: #00008b;">else</span> <span style="color: #00008b;">if</span>(chan.length === 0) {
      <span style="color: #00008b;">return</span> [<span style="color: #8b0000;">"park"</span>, <span style="color: #6b8e23;">null</span>];
    } <span style="color: #00008b;">else</span> {
      <span style="color: #00008b;">var</span> <span style="color: #b8860b;">val</span> = chan.pop();
      <span style="color: #00008b;">return</span> [<span style="color: #8b0000;">"continue"</span>, val];
    }
  };
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org71a70b1" class="outline-3">
<h3 id="org71a70b1">put &gt;!</h3>
<div class="outline-text-3" id="text-org71a70b1">
<p>
当 generator 往 channel 中 put 数据
</p>
<ul class="org-ul">
<li>如果 channel 空, 状态变为 continue, 放入数据</li>
<li>如果 channel 非空, parking</li>
</ul>

<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">put</span>(<span style="color: #b8860b;">chan</span>, <span style="color: #b8860b;">val</span>) {
  <span style="color: #00008b;">return</span> <span style="color: #00008b;">function</span>() {
    <span style="color: #00008b;">if</span>(chan.length === 0) {
      chan.unshift(val);
      <span style="color: #00008b;">return</span> [<span style="color: #8b0000;">"continue"</span>, <span style="color: #6b8e23;">null</span>];
    } <span style="color: #00008b;">else</span> {
      <span style="color: #00008b;">return</span> [<span style="color: #8b0000;">"park"</span>, <span style="color: #6b8e23;">null</span>];
    }
  };
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org1ee7eb7" class="outline-3">
<h3 id="org1ee7eb7">JavaScript 版本 的 CSP</h3>
<div class="outline-text-3" id="text-org1ee7eb7">
<p>
现在可以原原本本的将之前的clojure的例子翻译成JavaScript了
</p>
<div class="org-src-container">
<pre class="src src-javascript"><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">boss_yelling</span>(){
  go(<span style="color: #00008b;">function</span>*(){
    <span style="color: #00008b;">for</span>(<span style="color: #00008b;">var</span> <span style="color: #b8860b;">i</span>=0;;i++){
      <span style="color: #00008b;">yield</span> take(timeout(1000));
      <span style="color: #00008b;">yield</span> put(work, <span style="color: #8b0000;">"boss say: work "</span>+i);
    }
  });
}

<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">wife_texting</span>(){
  go(<span style="color: #00008b;">function</span>*(){
    <span style="color: #00008b;">for</span>(;;){
      <span style="color: #00008b;">yield</span> take(timeout(4000));
      <span style="color: #00008b;">yield</span> put(text, <span style="color: #8b0000;">"wife say: come home"</span>);
    }
  });
}

<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">working</span>(){
  go(<span style="color: #00008b;">function</span>*(){
    <span style="color: #00008b;">for</span>(;;){
      <span style="color: #00008b;">var</span> <span style="color: #b8860b;">task</span> = <span style="color: #00008b;">yield</span> take(work);
      console.log(task, <span style="color: #8b0000;">"me working"</span>);
    }
  });
}

<span style="color: #00008b;">function</span> <span style="color: #6a5acd;">texting</span>(){
  go(<span style="color: #00008b;">function</span>*(){
    <span style="color: #00008b;">for</span>(;;){
      <span style="color: #00008b;">var</span> <span style="color: #b8860b;">read</span> = <span style="color: #00008b;">yield</span> take(text);
      console.log(read, <span style="color: #8b0000;">"me ignoring"</span>);
    }
  });
}
boss_yelling();
wife_texting();
working();
texting();
</pre>
</div>

<p>
完整代码
</p>
<a class="jsbin-embed" href="https://jsbin.com/savepe/5/embed?js,console">JS Bin</a><script src="https://static.jsbin.com/js/embed.js"></script>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
里面的go的实现来自 <a href="https://swannodette.github.io/2013/08/24/es6-generators-and-csp/">https://swannodette.github.io/2013/08/24/es6-generators-and-csp/</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
Chrome有一个 feature toggle 可以打开部分 es6 功能.  打开 <code>chrome://flags/#enable-javascript-harmony</code> 设置为 <code>true</code>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<footer>
  <p>Author: Jichao Ouyang
    <a class="github-button" href="https://github.com/sponsors/jcouyang" data-icon="octicon-heart" aria-label="Sponsor @jcouyang on GitHub">Sponsor</a>
    <a aria-label="Follow @jcouyang on GitHub" data-count-aria-label="# followers on GitHub" data-count-api="/users/jcouyang#followers" data-count-href="/jcouyang/followers" href="https://github.com/jcouyang" class="github-button">Follow</a>
  </p>
  <p>Created: 2015-04-28 Tue 00:00</p>
  <p>Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.3 (<a href="https://orgmode.org">Org</a> mode 9.3.6) &#215; <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.
  <input type="swiftype" class="st-default-search-input" placeholder="Search"/>
  <a class="gumroad-button" href="https://gum.co/grokking-monad?wanted=true" target="_blank" data-gumroad-single-product="true">范畴论装逼指南，请自觉排队装逼</a>
  <div id="danmaku-comments"></div>
  <div id="disqus_thread"></div>
</footer>
</div>
</body>
</html>
