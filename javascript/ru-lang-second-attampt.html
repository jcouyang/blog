<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2020-03-06 Fri 12:45 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>入语言第二试: readtable 与 core.async</title>
<meta name="generator" content="Org mode">
<meta name="author" content="root">
<meta name="description" content="ru-lang version 0.2.1 新特性，引入 core.async 及 readtable"
>
<meta name="keywords" content="macro, core.async, goroutine, coroutine, javascript, clojure, lisp, sweetjs, meta programming">
<link rel="icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/toc.css"/>
<link rel="stylesheet" href="/style/tufte.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="https://feeds.oyanglul.us/JichaoOuyangsBlog"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJRFJGX"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<header>
    <a accesskey="h" href="/index.html"> HOME </a> |
    <a href="#" id="edit-in-github">EDIT</a> |
    <a href="https://feeds.oyanglul.us/JichaoOuyangsBlog">RSS</a> |
    <a href="https://blog.oyanglul.us/theindex">INDEX</a> |
    <a accesskey="H" href="/jichao.ouyang.html">ABOUT</a> |
    <a href="https://github.com/jcouyang/blog">GITHUB</a>
</header>
</div>
<div id="content">
<header>
<h1 class="title">入语言第二试: readtable 与 core.async</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgace2773">Readtable</a></li>
<li><a href="#org7b2030c">core.async</a></li>
</ul>
</div>
</nav>
<a aria-label="Star jcouyang/ru on GitHub" data-count-aria-label="# stargazers on GitHub" data-count-api="/repos/jcouyang/ru#stargazers_count" data-count-href="/jcouyang/ru/stargazers" data-style="mega" data-icon="octicon-star" href="https://github.com/jcouyang/ru" class="github-button">Star</a>

<a href="https://news.ycombinator.com/submit" class="hn-button" data-url="http://ru-lang.org" data-count="horizontal">Vote on Hacker News</a><script type="text/javascript">var HN=[];HN.factory=function(e){return function(){HN.push([e].concat(Array.prototype.slice.call(arguments,0)))};},HN.on=HN.factory("on"),HN.once=HN.factory("once"),HN.off=HN.factory("off"),HN.emit=HN.factory("emit"),HN.load=function(){var e="hn-button.js";if(document.getElementById(e))return;var t=document.createElement("script");t.id=e,t.src="//hn-button.herokuapp.com/hn-button.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n)},HN.load();</script>

<p>
俺的小公举淼淼最近各种 <del>发肚子拉烧</del> 发烧拉肚子，难得抽点时间给入语言ru-lang加入俩个大大的 features，忍不住要 marketing 一下。
</p>


<figure>
<img src="./images/shit-bricks.gif" alt="shit-bricks.gif">

</figure>

<p>
紧接<a href="./clojure-essence-in-javascript-macro-2.html">上篇</a>，在简单的介绍我是如何移植 clojure 的一些 macro 到 JavaScript 之后，我要介绍两个革命性的移植
</p>

<ul class="org-ul">
<li>readtable</li>
<li>core.async</li>
</ul>

<div id="outline-container-orgace2773" class="outline-2">
<h2 id="orgace2773">Readtable</h2>
<div class="outline-text-2" id="text-orgace2773">
<p>
readtable 在 clojure 中的意义是说 macro 可以按照几种 readtable 进行扩展，比如遇到特殊符号‘#’，就可以用另一张 table 中的 macro 来扩展了。
</p>

<pre class="code"><code>(+ 1 2) <span style="color: #8c8c8c; font-style: italic;">; a list</span>
#(+ 1 2) <span style="color: #8c8c8c; font-style: italic;">; =&gt; (fn (+ 1 2))</span>

{<span style="color: #6b8e23;">:a</span> 1 <span style="color: #6b8e23;">:b</span> 2} <span style="color: #8c8c8c; font-style: italic;">; hash map</span>
#{<span style="color: #6b8e23;">:a</span> 1 <span style="color: #6b8e23;">:b</span> 2} <span style="color: #8c8c8c; font-style: italic;">; set</span>
</code></pre>

<p>
由于 sweet.js 也支持 readtable，虽然并不是很完美，我就尝试了一下让 ru-lang  也能在遇到‘#’的时候做一些特俗的扩展。比如这是我想要实现的功能，让这几种 literal 的写法遇到‘#’后扩展成 mori 对应的数据结构：
</p>
<pre class="code"><code>#[bar, he] <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; mori.vector(bar,he)</span>
#{a: 1, b: 2} <span style="color: #8c8c8c; font-style: italic;">//</span><span style="color: #8c8c8c; font-style: italic;">=&gt; mori.hashMap('a', 1, 'b', 2)</span>
##{1, 2, 3} <span style="color: #8c8c8c; font-style: italic;">//</span><span style="color: #8c8c8c; font-style: italic;">=&gt; mori.set([1,2,3])</span>
</code></pre>

<div class="epigraph"><blockquote>
<p>
我还抽空做了一个 ru-lang repl,  所有 ru-lang 都可以在这里试运行 <a href="http://ru-lang.org/try/">http://ru-lang.org/try/</a>
</p>

</blockquote></div>

<p>
实现再简单不过了，先创建一个 readtable，挂上‘#’
</p>
<pre class="code"><code>sweet.currentReadtable().extend({
<span style="color: #8b0000;">'#'</span>: <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">ch</span>, <span style="color: #b8860b;">reader</span>) {
...
}
})
</code></pre>

<p>
以 vector 为例，当遇到‘#’后边为 <code>()</code> 时，将它变成 mori.vector&#x2026;就好了：
</p>
<pre class="code"><code>module.exports = sweet.currentReadtable().extend({
  <span style="color: #8b0000;">'#'</span>: <span style="color: #00008b;">function</span>(<span style="color: #b8860b;">ch</span>, <span style="color: #b8860b;">reader</span>) {
    <span style="color: #00008b;">var</span> <span style="color: #b8860b;">hashtag</span> = reader.readIdentifier();
    <span style="color: #00008b;">var</span> <span style="color: #b8860b;">pun</span> = reader.readToken();
    <span style="color: #00008b;">switch</span>(pun.value){
    <span style="color: #00008b;">case</span> <span style="color: #8b0000;">'[]'</span>:
      <span style="color: #00008b;">return</span> [reader.makeIdentifier(<span style="color: #8b0000;">'mori.vector'</span>)].concat(
        reader.makeDelimiter(<span style="color: #8b0000;">'()'</span>,pun.inner)
      );
...
</code></pre>

<p>
这样一来，我们就可以像原生 literal 创建数据结构一样使用到 mori 的persistent data structure(可持久性数据结构)了。
</p>

<div class="epigraph"><blockquote>
<p>
这里引入的 mori 是我 fork 的版本（swannodette 好像最近忙着实现 <a href="https://github.com/omcljs/om">om next</a> 并没有心思维护 mori 的样子），暂且叫做 conjs，当然完全兼容 mori 重要的是我加入了一些其他 clojurescript 的函数以及 core.async，你可以通过 npm install <a href="http://github.com/jcouyang/conjs">con.js</a> 安装使用。
</p>

</blockquote></div>
</div>
</div>

<div id="outline-container-org7b2030c" class="outline-2">
<h2 id="org7b2030c">core.async</h2>
<div class="outline-text-2" id="text-org7b2030c">
<p>
首先，不知道这是什么的童鞋请回到<a href="./clojure-core.async-essence-in-native-javascript.html">这一篇</a>，然后，感谢 clojurescript 的实现，使得这次移植这么顺利。懂得童鞋就会怀疑，clojurescript 不是还是用得 clojure 的 macro 来生成对应的状态机么？怎么可能轻松移植到 javascript？
</p>

<p>
但是，我真的只加了几行代码就移过来了（此处掌声）
</p>


<figure>
<img src="./images/applause.jpg" alt="applause.jpg">

</figure>

<p>
不信请看 <a href="https://github.com/jcouyang/conjs/commit/aaf843d3a1c8cf97ff8d453242fe5ea4a213a9e2">https://github.com/jcouyang/conjs/commit/aaf843d3a1c8cf97ff8d453242fe5ea4a213a9e2</a>
</p>

<p>
移植了以后看我怎么用（更多测试在<a href="https://github.com/jcouyang/conjs/blob/c8af05791befa230ed73125804fa29cc0f3201fc/spec/mori-spec.js#L196">这里</a>）
</p>
<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">c</span> = <span style="color: #00008b;">async</span>.chan()
<span style="color: #00008b;">async</span>.take$(c ,<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">x</span>){
    expect(x).toBe(<span style="color: #8b0000;">'something in channel'</span>)
    done()
})
<span style="color: #00008b;">async</span>.put$(c, <span style="color: #8b0000;">'something in channel'</span>)
</code></pre>

<p>
等一下，这怎么是回调的 take， <code>go block</code> 在哪里？ <code>&lt;! &gt;!</code> 在哪里？
</p>

<p>
那些都是 macro，当然我还要实现对应的 macro 了，先来看下加了  go block macro 后的效果:
</p>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">channel1</span> = mori.<span style="color: #00008b;">async</span>.chan();
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">channel2</span> = mori.<span style="color: #00008b;">async</span>.chan();
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">data2</span> = [1,2,3];
go {
  <span style="color: #00008b;">var</span> <span style="color: #b8860b;">a</span> &lt;! channel1;
  <span style="color: #00008b;">var</span> <span style="color: #b8860b;">b</span> &lt;! channel2;
  expect(a).toBe(<span style="color: #8b0000;">"data1"</span>);
  expect(b).toEqual([1,2,3]);
  done();
};
go {data2 &gt;! channel2};
go {<span style="color: #8b0000;">'data1'</span> &gt;! channel1};
</code></pre>

<p>
当然还支持 alts
</p>

<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">channela</span> = mori.<span style="color: #00008b;">async</span>.chan();
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">channelb</span> = mori.<span style="color: #00008b;">async</span>.chan();
<span style="color: #00008b;">var</span> <span style="color: #b8860b;">data2</span> = [1,2,3];    
go {
  <span style="color: #00008b;">var</span> <span style="color: #b8860b;">anywho</span> &lt;!alts [channela, channelb];
  <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">vector.a(0) is equals to nth(vector, 0)</span>
  expect(anywho.a(0)).toEqual([1,2,3]);
  expect(anywho.a(1)).toBe(channelb);
  done();
};
go {data2 &gt;! channelb};
go {<span style="color: #8b0000;">'data1'</span> &gt;! channela};
</code></pre>

<p>
go block macro 的实现其实也没有花<a href="https://github.com/jcouyang/ru/blob/master/macro/async.sjs">太多的代码</a>， 以 take 为例，只需要把后面的句子都放入 take 的 callback 中好了，通过我的 <a href="./clojure-essence-in-javascript-macro.html">sweet macro 简介</a> 我想这里应该能看懂的：
</p>
<pre class="code"><code><span style="color: #00008b;">let</span> (&lt;!) = macro {
    rule infix { <span style="color: #00008b;">var</span> <span style="color: #b8860b;">$left</span>:ident |  $right:expr $rest $[...] } =&gt; {
        <span style="color: #00008b;">return</span> mori.<span style="color: #00008b;">async</span>.take$($right, <span style="color: #00008b;">function</span> (<span style="color: #b8860b;">value</span>) {
            $left = value
            $rest $[...]
        })
    }
    ...
}

</code></pre>

<ul class="org-ul">
<li>一个 infix macro，左边是take应该付给的变量，右边是 take 的 channel</li>
<li>剩下的 body 直接全丢到 take 的 callback 中。</li>
</ul>

<p>
所以，上面的 take 测试放到 <a href="http://ru-lang.org/try/#%20%20%20%20var%20channel1%20=%20mori.async.chan%28%29;%0A%20%20%20%20var%20channel2%20=%20mori.async.chan%28%29;%0A%20%20%20%20var%20data2%20=%20%5B1,2,3%5D;%0A%20%20%20%20go%20%7B%0A%20%20%20%20%20%20var%20a%20%3C!%20channel1;%0A%20%20%20%20%20%20var%20b%20%3C!%20channel2;%0A%20%20%20%20%20%20expect%28a%29.toBe%28%22data1%22%29;%0A%20%20%20%20%20%20expect%28b%29.toEqual%28%5B1,2,3%5D%29;%0A%20%20%20%20%20%20done%28%29;%0A%20%20%20%20%7D;%0A%20%20%20%20go%20%7Bdata2%20%3E!%20channel2%7D;%0A%20%20%20%20go%20%7B%27data1%27%20%3E!%20channel1%7D;">ru-lang repl</a> 中会编译成
</p>
<pre class="code"><code>go {
  <span style="color: #00008b;">var</span> <span style="color: #b8860b;">a</span> &lt;! channel1;
  <span style="color: #00008b;">var</span> <span style="color: #b8860b;">b</span> &lt;! channel2;
  expect(a).toBe(<span style="color: #8b0000;">"data1"</span>);
  expect(b).toEqual([1,2,3]);
  done();
};
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; </span>
(<span style="color: #00008b;">function</span> () {
    <span style="color: #00008b;">return</span> mori.<span style="color: #00008b;">async</span>.take$(channel1, <span style="color: #00008b;">function</span> (<span style="color: #b8860b;">value</span>) {
        a = value;
        <span style="color: #00008b;">return</span> mori.<span style="color: #00008b;">async</span>.take$(channel2, <span style="color: #00008b;">function</span> (<span style="color: #b8860b;">value$2</span>) {
            b = value$2;
            expect(a).toBe(<span style="color: #8b0000;">'data1'</span>);
            expect(b).toEqual([
                1,
                2,
                3
            ]);
            done();
        });
    });
}());
</code></pre>


<figure>
<img src="./images/what.gif" alt="what.gif">

</figure>

<p>
没错，把 core.async 移植到 javascript，即不需要 ES6 的 generator， 也不用等 ES7  的 async function，更不需要任何生成状态机的 macro。简简单单的 callback + macro + clojurescript core.async channel，就这么简单， 实现任何浏览器都能用的 core.async go block。
</p>

<p>
这样，通过 ru-lang，可以让 javascript 轻松使用到 clojure 的 persistent data structure，还可以用 clojurescript 的  core.async。
</p>


<p>
最后，小广告
</p>
<div class="epigraph"><blockquote>
<p>
如果对这个项目有兴趣, 不妨接着在hacker news
</p>
<a href="https://news.ycombinator.com/submit" class="hn-button" data-url="http://ru-lang.org" data-count="horizontal">Vote on Hacker News</a><script type="text/javascript">var HN=[];HN.factory=function(e){return function(){HN.push([e].concat(Array.prototype.slice.call(arguments,0)))};},HN.on=HN.factory("on"),HN.once=HN.factory("once"),HN.off=HN.factory("off"),HN.emit=HN.factory("emit"),HN.load=function(){var e="hn-button.js";if(document.getElementById(e))return;var t=document.createElement("script");t.id=e,t.src="//hn-button.herokuapp.com/hn-button.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n)},HN.load();</script>
<p>
上讨论或 vote, 或者帮我在github上再加颗星
</p>
<a aria-label="Star jcouyang/ru on GitHub" data-count-aria-label="# stargazers on GitHub" data-count-api="/repos/jcouyang/ru#stargazers_count" data-count-href="/jcouyang/ru/stargazers" data-style="mega" data-icon="octicon-star" href="https://github.com/jcouyang/ru" class="github-button">Star</a><script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
<p>
也是极好的.
</p>

</blockquote></div>
</div>
</div>
</div>
<div id="postamble" class="status">
<footer>
  <p>Author: root
    <a class="github-button" href="https://github.com/sponsors/jcouyang" data-icon="octicon-heart" aria-label="Sponsor @jcouyang on GitHub">Sponsor</a>
    <a aria-label="Follow @jcouyang on GitHub" data-count-aria-label="# followers on GitHub" data-count-api="/users/jcouyang#followers" data-count-href="/jcouyang/followers" href="https://github.com/jcouyang" class="github-button">Follow</a>
  </p>
  <p>Created: 2015-08-16 Sun 00:00</p>
  <p>Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.2 (<a href="https://orgmode.org">Org</a> mode 9.2.6) &#215; <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.
  <input type="swiftype" class="st-default-search-input" placeholder="Search"/>
  <a class="gumroad-button" href="https://gum.co/grokking-monad?wanted=true" target="_blank" data-gumroad-single-product="true">范畴论装逼指南，请自觉排队装逼</a>
  <div id="danmaku-comments"></div>
  <div id="disqus_thread"></div>
</footer>
</div>
</body>
</html>
