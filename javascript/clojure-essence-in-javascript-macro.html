<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2020-03-06 Fri 12:33 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>JavaScript玩转Clojure大法之 - Macro (1)</title>
<meta name="generator" content="Org mode">
<meta name="author" content="root">
<meta name="keywords" content="macro, javascript, clojure, lisp, sweetjs, meta programming">
<link rel="icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/toc.css"/>
<link rel="stylesheet" href="/style/tufte.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="https://feeds.oyanglul.us/JichaoOuyangsBlog"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJRFJGX"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<header>
    <a accesskey="h" href="/index.html"> HOME </a> |
    <a href="#" id="edit-in-github">EDIT</a> |
    <a href="https://feeds.oyanglul.us/JichaoOuyangsBlog">RSS</a> |
    <a href="https://blog.oyanglul.us/theindex">INDEX</a> |
    <a accesskey="H" href="/jichao.ouyang.html">ABOUT</a> |
    <a href="https://github.com/jcouyang/blog">GITHUB</a>
</header>
</div>
<div id="content">
<header>
<h1 class="title">JavaScript玩转Clojure大法之 - Macro (1)</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org7b6d413">Macro</a></li>
<li><a href="#orgef14f4e">Sweet.js</a>
<ul>
<li><a href="#org6c6c19d">Rule macro</a></li>
<li><a href="#org4007803">case macro</a></li>
</ul>
</li>
<li><a href="#org220533e">Recap</a></li>
</ul>
</div>
</nav>
<ul class="org-ul">
<li><a href="./clojure-core.async-essence-in-native-javascript.html">JavaScript玩转Clojure大法之 - 并发编程</a></li>
<li><a href="./clojure-essence-in-javascript-transducer.html">JavaScript玩转Clojure大法之 - Transducer</a></li>
<li><a href="./clojure-essence-in-javascript-trampoline.html">JavaScript玩转Clojure大法之 - Trampoline</a></li>
<li><b>JavaScript玩转Clojure大法之 - Macro (1)</b></li>
</ul>

<p>
macro可以说是lisp语言的独门绝技, lisp语言数据即代码,以及s-expression的特点使得可以轻松自定义macro.
虽然js原生不能这么玩, 但是依然不能阻止我们通过sweet.js在预编译的过程中使用macro.
</p>

<div id="outline-container-org7b6d413" class="outline-2">
<h2 id="org7b6d413">Macro</h2>
<div class="outline-text-2" id="text-org7b6d413">
<p>
我非常不喜欢中文字面翻译&#x2013;'宏', 中文宏的意思是大, 广大, 实在想不通这跟macro有毛关系. 而macro值的是某条指令可以扩展
成一堆其它指令. 反而用个图我觉得更贴切
</p>


<figure>
<img src="./images/bender-make-bender.gif" alt="bender-make-bender.gif">

</figure>

<pre class="code"><code>(macroexpand '(<span style="color: #00008b;">when-not</span> (= 1 3) (print <span style="color: #8b0000;">"damn"</span>)))
<span style="color: #8c8c8c; font-style: italic;">; </span><span style="color: #8c8c8c; font-style: italic;">=&gt; (if (= 1 3) nil (do (print "damn")))</span>
</code></pre>

<p>
看看Clojure的macro <code>when-not</code> 能扩展成什么? 神奇的变成了if.
</p>

<div class="epigraph"><blockquote>
<p>
靠, 这不是就是语法糖?
</p>

</blockquote></div>

<p>
嗯, 就是语法糖, 但是是强大的可以自定义的语法糖. 这代表着你可以用Clojure编写自己独特版本的Clojure.
</p>

<p>
lisp语言因为本身的原因能轻松这么办到
</p>
<ul class="org-ul">
<li>语法简单,只有s-expression</li>
<li>数据即代码, s-expression本身就是树形数据结构</li>
<li>lexer(词法分析器) &rarr; Reader &rarr; expander</li>
</ul>

<p>
如果英文好, 可以看看<a href="http://www.braveclojure.com/read-and-eval/">这篇解释clojure macro的文章</a>
</p>

<p>
但是就算可以自定义语法糖, 到底有什么好处呢, 真的只是使语法更好看吗?
</p>

<p>
当然不是, macro可以说是元编程的终极形态, 当Clojure推出core.async这么牛逼的库之后, 立即就被port到
ClojureScript, 也就是说, ClojureScript写的 go block 可以编译成能在浏览器上抛的单线程JavaScript.
</p>

<div class="epigraph"><blockquote>
<p>
如果回忆不起来可以翻看下如何用JavaScript实现 core.async 的 go block.
你会发现 generator 是实现的关键, 而ClojureScript却只用macro展成不同的纯状态机实现.
</p>

</blockquote></div>

<p>
怎么做到的呢, 就是macro, 如果你翻看ClojureScript 的 <a href="https://github.com/clojure/core.async/blob/master/src/main/clojure/cljs/core/async/macros.clj">core.async源码</a>, 会看见一堆一堆的macro. 根据go block
中不同的语法扩展成不一样的状态机.
</p>
</div>
</div>

<div id="outline-container-orgef14f4e" class="outline-2">
<h2 id="orgef14f4e">Sweet.js</h2>
<div class="outline-text-2" id="text-orgef14f4e">
<p>
因此对于像其它有更多语法的语言要实现macro可就没那么简单了(虽然一些新的语言还是很努力的实现了macro, 比如rust和julia). 
比较直白的实现方式是定义的macro接收一个
AST, 然后改吧改吧, 做macro该干得事情. 但是操作语法树实在是太复杂了, 跟自己写类似coffeescript编译器有毛区别.
</p>

<p>
而<a href="http://sweetjs.org">sweet.js</a> 给我提供了一个自制js macro的工具, sweet.js来自mozilla<label for="1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="1" class="margin-toggle"/><span class="sidenote">
mozilla还有论文呢: <a href="https://github.com/mozilla/sweet.js/blob/master/doc/paper/sweetjs.pdf">https://github.com/mozilla/sweet.js/blob/master/doc/paper/sweetjs.pdf</a>
</span>, 嗯嗯, 就是rust的那个mozilla, 
就是那个 <i>如果没有chrome, 应该能占浏览器半壁江山的</i> <del>汪峰</del> firefox
 的mozilla <del>公司</del> 基金会.
</p>
</div>

<div id="outline-container-org6c6c19d" class="outline-3">
<h3 id="org6c6c19d">Rule macro</h3>
<div class="outline-text-3" id="text-org6c6c19d">
<p>
因此sweet.js和mozilla自己的语言rust支持的macro语法上非常接近, 也绝逼不是巧合.
</p>

<p>
来看看rust的 rule macro
</p>
<pre class="code"><code>macro_rules! foo {
    (x =&gt; $e:expr) =&gt; (println!("got a ", $e));
}
foo!(x =&gt; 3); // =&gt; println!("got a ", 3)
</code></pre>

<p>
来看看 Sweet.js的 rule macro
</p>
<pre class="code"><code>macro foo {
  {
    (x=&gt;$e:expr)
  } =&gt; {
    console.log(<span style="color: #8b0000;">'got a '</span>, $e)
  }
}
foo(x=&gt;3) <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; console.log("got a ", 3)</span>
</code></pre>

<p>
简直是一模一样, 好吧, 我承认我的标题应该改成 <i>javascript玩转rust大法更为贴切</i>, 但是我们先来关心下这里面到底发生了什么?
</p>

<p>
实际上sweet.js做了之前clojure的Reader 和 Expander的工作
</p>
<ol class="org-ol">
<li>lexer 把源码token化, 得到token序列</li>
<li>Reader把token编程token树, 这是一个类似 sexpr 的token树</li>
<li>变term树</li>
<li>Expander按照定义的macro匹配扩展token树, 再parse成AST</li>
</ol>

<div class="epigraph"><blockquote>
<p>
说人话!
</p>

</blockquote></div>

<p>
拿 macro foo 作为例子
</p>
<ol class="org-ol">
<li>变token:
foo &bull; ( &bull; x &bull; = &bull; &gt; &bull; 3 &bull; )</li>
<li>变token树: 括号里面是一棵树, 第一个是根, 后面的元素有括号的是子树, 没有的就是叶子了.</li>
</ol>
<pre class="example">
(foo ('()' x = &gt; 3))
</pre>
<ol class="org-ol">
<li><p>
变term树: 
</p>
<pre class="example">
(call:foo x = &gt; 3)
</pre></li>
<li>expand:</li>
</ol>
<pre class="example">
(call:foo (call:console.log 'got a' , 3))
</pre>

<p>
这个, 这个这个&#x2026;&#x2026;怎么说好变成树怎么就变成lisp了
</p>

<p>
没错, lisp 简单的 s-expr 界限非常清晰而且本身就是完美的树型结构, 实现macro最方便的方式
</p>
</div>
</div>

<div id="outline-container-org4007803" class="outline-3">
<h3 id="org4007803">case macro</h3>
<div class="outline-text-3" id="text-org4007803">
<p>
Allright, 当然这个例子好简单, 但是像 rule macro 只能做一些非常简单的形式上的一一变化, 那么说好的元编程呢?
说好的可以像clojure那样用clojure编写clojure代码呢. 这时候case macro就是解决这个问题了. clojure由于
数据即代码, 代码只要quote起来就跟list一样好操作, 那么JavaScript麻烦的语法要怎么变数据好让我们用JavaScript操作呢?
</p>

<p>
答案是太复杂不能变数据, 但是只能变AST, 只能操作复杂的语法树了, 真是忧伤, 但是总比没有好吧.
</p>

<p>
让我们先来一 <del>发</del> 个例子
</p>
<pre class="code"><code>  macro m {
    <span style="color: #00008b;">case</span> {ctx (x=&gt;$x)} =&gt; {
      console.log(<span style="color: #8b0000;">'haha iam javascript'</span>)
      <span style="color: #00008b;">return</span> #{
       console.log($x) 
      }
    }
  }
  m(100) 
<span style="color: #8c8c8c; font-style: italic;">//</span><span style="color: #8c8c8c; font-style: italic;">=&gt; haha iam javascript (to console)</span>
<span style="color: #8c8c8c; font-style: italic;">//</span><span style="color: #8c8c8c; font-style: italic;">=&gt; console.log(100)</span>
</code></pre>

<p>
如果你已经忘了, 请 <a href="#org6c6c19d">电梯</a> 返回去对比一下到底有什么区别
</p>
<ol class="org-ol">
<li>多了一个参数 <code>ctx</code>, 匹配用到m时的那个m</li>
<li>接下来都一样, 直到&#x2026; <code>#{}</code> 这个是什么?
这里面的语法变成语法树, 当然语法树结构是数组, 每个元素还是一个token树.比如console.log(3)大概是这种结构</li>
</ol>
<pre class="code"><code>[
    {token: {value: <span style="color: #8b0000;">'console'</span>}}
    {token: {value: <span style="color: #8b0000;">'.'</span>}},
    {token: {value: <span style="color: #8b0000;">'log'</span>}},
    {token: {value: <span style="color: #8b0000;">'()'</span>},
     inner:[
         {token: {value: 3}}
     ]}
]
</code></pre>
<ol class="org-ol">
<li>最重要的, 现在里面可以写正常js了, 意味着你可以用js编程各种语法,然后拼到token树中</li>
</ol>

<p>
我感觉语言以及不能解释了, 请深吸一口气, 来一个骚味复杂一点的栗子
</p>

<p>
比如我要在js里弄一个想clojure的arity function一样骚的函数
</p>

<div class="epigraph"><blockquote>
<p>
arity function指根据不同个数的参数, 有不同的函数body. 比如
</p>
<pre class="code"><code>(<span style="color: #00008b;">defn</span> <span style="color: #6a5acd;">add</span>
  ([x] (+ 0 x))
  ([x y] (+ x y)))
(add 1)<span style="color: #8c8c8c; font-style: italic;">;=&gt;2</span>
(add 1 2)<span style="color: #8c8c8c; font-style: italic;">;=&gt;3</span>
</code></pre>

</blockquote></div>

<p>
所以类似的我期望的能在js里这样定义函数
</p>
<pre class="code"><code>defn add {
  (a){a}
  (a, b) {a+b}
}
add(1) <span style="color: #8c8c8c; font-style: italic;">//</span><span style="color: #8c8c8c; font-style: italic;">=&gt; 1</span>
add(1, 2) <span style="color: #8c8c8c; font-style: italic;">//</span><span style="color: #8c8c8c; font-style: italic;">=&gt; 3</span>
</code></pre>

<p>
先把macro摆出来
</p>

<pre class="code"><code><span style="color: #8c8c8c; font-style: italic;">//</span><span style="color: #8c8c8c; font-style: italic;">var macro from http://jlongster.com/Sweet.js-Tutorial--2--Recursive-Macros-and-Custom-Pattern-Classes</span>
macro caseFunc {
    <span style="color: #00008b;">case</span> {_ ($args...) {$body... $last:expr}} =&gt;
    {
      letstx $len = [makeValue(#{$args...}.length , <span style="color: #6b8e23;">null</span>)];
      <span style="color: #00008b;">return</span> #{
      <span style="color: #00008b;">case</span> $len:
        <span style="color: #00008b;">return</span> (<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">$args</span>...){<span style="color: #b8860b;">$body</span>... <span style="color: #00008b;">return</span> <span style="color: #b8860b;">$last</span>}).<span style="color: #b8860b;">apply</span>(<span style="color: #6b8e23;">this</span>, <span style="color: #6b8e23;">arguments</span>)
      }
    }
}

macro defn{
  rule { $name { $(($args (,) ...){$body ...})...} } =&gt; {
    <span style="color: #00008b;">function</span> <span style="color: #6a5acd;">$name</span> (){
      <span style="color: #00008b;">switch</span>(<span style="color: #6b8e23;">arguments</span>.length){
        $(caseFunc ($args...) {$body...};
         )...
      }
    }
  }
}
defn arity_function{
  (a){a}
  (a, b) {a + b}
}
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt;</span>
<span style="color: #8c8c8c; font-style: italic;">/*</span>
<span style="color: #8c8c8c; font-style: italic;">function arity_function() {</span>
<span style="color: #8c8c8c; font-style: italic;">    switch (arguments.length) {</span>
<span style="color: #8c8c8c; font-style: italic;">    case 1:</span>
<span style="color: #8c8c8c; font-style: italic;">        return function (a) {</span>
<span style="color: #8c8c8c; font-style: italic;">            return a;</span>
<span style="color: #8c8c8c; font-style: italic;">        }.apply(this, arguments);</span>
<span style="color: #8c8c8c; font-style: italic;">    case 2:</span>
<span style="color: #8c8c8c; font-style: italic;">        return function (a, b) {</span>
<span style="color: #8c8c8c; font-style: italic;">            return a + b;</span>
<span style="color: #8c8c8c; font-style: italic;">        }.apply(this, arguments);</span>
<span style="color: #8c8c8c; font-style: italic;">    }</span>
<span style="color: #8c8c8c; font-style: italic;">}</span>
<span style="color: #8c8c8c; font-style: italic;">*/</span>
</code></pre>

<div class="epigraph"><blockquote>
<p>
WTF shen me gui
</p>

</blockquote></div>

<p>
叫我一点一点解释, 重要的是第二个macro(第一个应该都能看懂吧), 这里面有几个新东西
</p>

<ul class="org-ul">
<li>第<a href="#coderef-last" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-last');" onmouseout="CodeHighlightOff(this, 'coderef-last');">2</a>行的 <code>$last:expr</code>: 匹配最后一个表达式</li>
<li>第<a href="#coderef-makevalue" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-makevalue');" onmouseout="CodeHighlightOff(this, 'coderef-makevalue');">4</a>行: 里面的 <code>#{$args}</code> 把match到的javascript语法变成token树的列表.</li>
<li>这个token列表就是javascript的数组, 里面是token对象.
<ul class="org-ul">
<li>用 <code>makeValue</code> 把这个javascript再变成token树</li>
<li>用 <code>letstx $len</code> 来装这个token树, 就可以在后面的 <code>#{}</code></li>
</ul></li>
<li>最后返回token树</li>
</ul>


<pre class="code"><code><span class="linenr"> 1: </span>macro caseFunc {
<span id="coderef-last" class="coderef-off"><span class="linenr"> 2: </span>  <span style="color: #00008b;">case</span> {_ ($args...) {$body... $last:expr}} =&gt;</span>
<span class="linenr"> 3: </span>    {
<span id="coderef-makevalue" class="coderef-off"><span class="linenr"> 4: </span>      letstx $len = [makeValue(#{$args...}.length , <span style="color: #6b8e23;">null</span>)];</span>
<span class="linenr"> 5: </span>      <span style="color: #00008b;">return</span> #{
<span id="coderef-len" class="coderef-off"><span class="linenr"> 6: </span>        <span style="color: #00008b;">case</span> $len:</span>
<span class="linenr"> 7: </span>        <span style="color: #00008b;">return</span> (<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">$args</span>...){<span style="color: #b8860b;">$body</span>... <span style="color: #00008b;">return</span> <span style="color: #b8860b;">$last</span>}).<span style="color: #b8860b;">apply</span>(<span style="color: #6b8e23;">this</span>, <span style="color: #6b8e23;">arguments</span>)
<span class="linenr"> 8: </span>      }
<span class="linenr"> 9: </span>    }
<span class="linenr">10: </span>}
</code></pre>
</div>
</div>
</div>

<div id="outline-container-org220533e" class="outline-2">
<h2 id="org220533e">Recap</h2>
<div class="outline-text-2" id="text-org220533e">
<p>
总之, macro给我们带无线的 <del>wifi</del> 可能, 对于语法复杂的语言确实不能像lisp一样简单实现macro, 但是通过
lexer和reader转换成类似lisp token树, 虽然坎坷了一些, 但是还是能达到相同的效果的. 当然 sweet.js 提供
的macro的功能还不只这些, 下篇将介绍 operator 和 infix macro, 当然如果你等不急自己看sweet.js<a href="http://sweetjs.org/doc/main/sweet.html">文档</a> 也是极好的.
</p>

<p>
另外感兴趣的话可以看看我最近正WIP的项目 <a href="http://ru-lang.org">ru-lang</a> 的一些macro.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
mozilla还有论文呢: <a href="https://github.com/mozilla/sweet.js/blob/master/doc/paper/sweetjs.pdf">https://github.com/mozilla/sweet.js/blob/master/doc/paper/sweetjs.pdf</a>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<footer>
  <p>Author: root
    <a class="github-button" href="https://github.com/sponsors/jcouyang" data-icon="octicon-heart" aria-label="Sponsor @jcouyang on GitHub">Sponsor</a>
    <a aria-label="Follow @jcouyang on GitHub" data-count-aria-label="# followers on GitHub" data-count-api="/users/jcouyang#followers" data-count-href="/jcouyang/followers" href="https://github.com/jcouyang" class="github-button">Follow</a>
  </p>
  <p>Created: 2015-06-14 Sun 00:00</p>
  <p>Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.2 (<a href="https://orgmode.org">Org</a> mode 9.2.6) &#215; <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.
  <input type="swiftype" class="st-default-search-input" placeholder="Search"/>
  <a class="gumroad-button" href="https://gum.co/grokking-monad?wanted=true" target="_blank" data-gumroad-single-product="true">范畴论装逼指南，请自觉排队装逼</a>
  <div id="danmaku-comments"></div>
  <div id="disqus_thread"></div>
</footer>
</div>
</body>
</html>
