<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2019-12-23 Mon 12:11 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>自制语言初试 - 入lang</title>
<meta name="generator" content="Org mode">
<meta name="author" content="root">
<meta name="keywords" content="macro, javascript, clojure, lisp, sweetjs, meta programming">
<link rel="icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/toc.css"/>
<link rel="stylesheet" href="/style/tufte.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="https://feeds.oyanglul.us/JichaoOuyangsBlog"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJRFJGX"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<header>
    <a accesskey="h" href="/index.html"> HOME </a> |
    <a href="#" id="edit-in-github">EDIT</a> |
    <a href="https://feeds.oyanglul.us/JichaoOuyangsBlog">RSS</a> |
    <a accesskey="H" href="/jichao.ouyang.html">ABOUT</a> |
    <a href="https://github.com/jcouyang/blog">GITHUB</a>
</header>
</div>
<div id="content">
<header>
<h1 class="title">自制语言初试 - 入lang</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb7f49f3">Rationale(为毛要整一门语言)</a>
<ul>
<li><a href="#org1737a38">ClojureScript怎么就不好了</a></li>
<li><a href="#org1c0d89e">ClojureScript的数据结构移植</a></li>
<li><a href="#org694d199">那macro呢</a></li>
</ul>
</li>
<li><a href="#orgd5aca4a">Ru-lang, The First Attampt</a>
<ul>
<li><a href="#org82ee776">lambda</a></li>
<li><a href="#org6a24820">Let</a>
<ul>
<li><a href="#org49673ab">block scope binding</a></li>
<li><a href="#org7925741">destruture array</a></li>
<li><a href="#org88ce3b8">looprecur</a></li>
</ul>
</li>
<li><a href="#org74cdc5e">Existential ?</a>
<ul>
<li><a href="#org658d7f5">Infix macro</a></li>
</ul>
</li>
<li><a href="#org20ee69d">在哪里才能买到呢</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<a aria-label="Star jcouyang/ru on GitHub" data-count-aria-label="# stargazers on GitHub" data-count-api="/repos/jcouyang/ru#stargazers_count" data-count-href="/jcouyang/ru/stargazers" data-style="mega" data-icon="octicon-star" href="https://github.com/jcouyang/ru" class="github-button">Star</a>

<a href="https://news.ycombinator.com/submit" class="hn-button" data-url="http://ru-lang.org" data-count="horizontal">Vote on Hacker News</a><script type="text/javascript">var HN=[];HN.factory=function(e){return function(){HN.push([e].concat(Array.prototype.slice.call(arguments,0)))};},HN.on=HN.factory("on"),HN.once=HN.factory("once"),HN.off=HN.factory("off"),HN.emit=HN.factory("emit"),HN.load=function(){var e="hn-button.js";if(document.getElementById(e))return;var t=document.createElement("script");t.id=e,t.src="//hn-button.herokuapp.com/hn-button.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n)},HN.load();</script>

<div id="outline-container-orgb7f49f3" class="outline-2">
<h2 id="orgb7f49f3">Rationale(为毛要整一门语言)</h2>
<div class="outline-text-2" id="text-orgb7f49f3">

<figure>
<img src="./images/tv-giving-me-reason-to-live.gif" alt="tv-giving-me-reason-to-live.gif">

</figure>
</div>

<div id="outline-container-org1737a38" class="outline-3">
<h3 id="org1737a38">ClojureScript怎么就不好了</h3>
<div class="outline-text-3" id="text-org1737a38">
<p>
接上篇简单的介绍sweet.js之后, 萌发了特别crazy的idea. 如果CoffeeScript或者LiveScript也算
语言的话, 其实单单用sweet.js自制一堆macro就能实现类似的语言. 当然, 这两门语言都比较奇特, 一个
像似ruby和python的熊孩子, 另一个是F#和coffee的熊孩子, 总之, 没有一门是符合我自己的编程习惯.
</p>

<p>
而如果用Clojure写前端也就是用ClojureScript的话, 由于是完全另一门语言, 跟JS其他库交互会非常麻烦. 而像Coffee则没有
这个问题, 难道就不能有一种ClojureScript可以完全兼容JavaScript, 又可以用到Clojure的各种
奇特函数呢.
</p>
</div>
</div>

<div id="outline-container-org1c0d89e" class="outline-3">
<h3 id="org1c0d89e">ClojureScript的数据结构移植</h3>
<div class="outline-text-3" id="text-org1c0d89e">
<p>
ClojureScript的作者David做了一个非常有意思的项目,把ClojureScript的数据结构单独导出来做成类似underscore的库 - <a href="https://github.com/swannodette/mori">mori</a>.
官方的解释是
</p>
<div class="epigraph"><blockquote>
<p>
A simple bridge to ClojureScript's persistent data structures and supporting APIs for vanilla JavaScrip
</p>

</blockquote></div>
<p>
恩, 这不正是我想要的吗. 可以直接在JavaScript中使用ClojureScript的数据结构.
</p>

<p>
但是&#x2026;
</p>
</div>
</div>

<div id="outline-container-org694d199" class="outline-3">
<h3 id="org694d199">那macro呢</h3>
<div class="outline-text-3" id="text-org694d199">
<p>
David导出了所有的数据结构以及function, 但是像macro却不可能直接导成JavaScript, 因为是编译时
扩展的.
</p>

<p>
但是macro却是clojure(或者lisp语言)最吸引人的地方之一. 如果能移植过来讲会开启在用原生JS中使用到
所有ClojureScript features的无限可能. 比如就可以把 <a href="./clojure-core.async-essence-in-native-javascript.html">core.async</a> 移植过来.
</p>

<p>
于是为了验证移植macro的可能性, 我用Sweet.js实现了部分macro或者clojure的keyword, 我把这些
macros和mori的集合叫 <a href="http://ru-lang.org">ru-lang</a> , 这样就可以用类似JavaScript的形式, 使用到所有Clojure的好处.
</p>

<div class="epigraph"><blockquote>
<p>
Hacker News 上的讨论 <a href="https://news.ycombinator.com/item?id=9749286">https://news.ycombinator.com/item?id=9749286</a>
</p>

</blockquote></div>
</div>
</div>
</div>

<div id="outline-container-orgd5aca4a" class="outline-2">
<h2 id="orgd5aca4a">Ru-lang, The First Attampt</h2>
<div class="outline-text-2" id="text-orgd5aca4a">
<p>
叫做  <a href="http://ru-lang.org">ru-lang</a> 有两层意思
</p>
<ul class="org-ul">
<li>"入"长得像 &lambda; 的汉字, 所以 "入-lang" 也长得像 Clojure 的 JavaScript</li>
<li>"入" 表示一些东西新加入JavaScript</li>
</ul>
</div>

<div id="outline-container-org82ee776" class="outline-3">
<h3 id="org82ee776">lambda</h3>
<div class="outline-text-3" id="text-org82ee776">
<p>
Clojure有一个很cool的macro, <code>#{}</code>, 匿名函数的macro, cool的地方是它可以用 <code>%1</code>, <code>%2</code>
代表第几个参数. 特别方便比如是在用map的时候
</p>
<pre class="code"><code>(map #(<span style="color: #b8860b;">%</span>+3) [1,2,3,4])
</code></pre>

<p>
移植这个macro还是比较简单的, 虽然真正的 <code>#</code> 在clojure中是一个切换reader table的标志, 可能
要更复杂一下, 但是这里我们只是想要一个简单的带place holder的匿名函数.
</p>

<p>
由于#算是sweetjs的保留字符, 我把 <code>#</code> 换成 <code>fn</code> 来代替, <code>%</code> 在js里又是运算符, 改用 <code>$</code> 代替, 
那么ru-lang版的匿名函数就变成了
</p>
<pre class="code"><code>map(fn($+3), [1,2,3,4])
</code></pre>

<p>
很像clojure对不对, 但是又还是保留了js的语法, 是不是有点感觉怪怪的东西悄悄乱入了
</p>

<p>
实现的思路则非常简单, 使用 <a href="./clojure-essence-in-javascript-macro.html">上篇</a> 提到的 Case macro
</p>
<ol class="org-ol">
<li>把 <code>fn</code> 的参数里面所有的 <code>$n</code> token 找到</li>
<li>把所有token的 <code>$n</code> 变成 <code>arguments[n]</code></li>
<li>用js的匿名函数包上, 返回</li>
</ol>

<pre class="code"><code>macro fn {
<span style="color: #00008b;">case</span> {
  $ctx
  ($body:expr)
}=&gt;{
  <span style="color: #00008b;">function</span> <span style="color: #6a5acd;">replace_args</span>(<span style="color: #b8860b;">stxs</span>){
    <span style="color: #00008b;">return</span> stxs.map(<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">x</span>){
      <span style="color: #00008b;">if</span>(x.token.inner) {x.token.inner = replace_args(x.token.inner); <span style="color: #00008b;">return</span> x}
      <span style="color: #00008b;">if</span>(x.token.type==parser.Token.Identifier &amp;&amp; x.token.value.match(<span style="color: #8b0000;">/^\$(\d?)$/</span>)){
        <span style="color: #00008b;">var</span> <span style="color: #b8860b;">num</span> = x.token.value.match(<span style="color: #8b0000;">/^\$(\d?)$/</span>).pop()
        <span style="color: #00008b;">if</span>(!num) num=1;
        <span style="color: #00008b;">return</span> makeIdent(<span style="color: #8b0000;">'arguments['</span>+(num-1)+<span style="color: #8b0000;">']'</span>,#{$body});
      }
      <span style="color: #00008b;">return</span> x;
    })
  }
  <span style="color: #00008b;">var</span> <span style="color: #b8860b;">body</span> = replace_args(#{$body})
  letstx $new_body = body
  <span style="color: #00008b;">return</span> #{
    (<span style="color: #00008b;">function</span>(){<span style="color: #00008b;">return</span> $new_body})}
}
}

<span style="color: #00008b;">export</span> fn;
</code></pre>

<p>
注意 <code>replace_args</code> 是递归的去替换所有token以及token的inner token
</p>

<p>
这个太简单了,来个难点的macro吧
</p>
</div>
</div>

<div id="outline-container-org6a24820" class="outline-3">
<h3 id="org6a24820">Let</h3>
<div class="outline-text-3" id="text-org6a24820">
<p>
let 怎么就难了&#x2026;
</p>

<p>
当然, clojure的let功能很多的
</p>
<ul class="org-ul">
<li>block scope binding</li>
<li>如果是array或者map, 还能destructure</li>
<li>如果是递归的let, 就变成了looprecur</li>
</ul>

<p>
因此我们要实现let需要实现4个东西
</p>
<ul class="org-ul">
<li>block scope binding</li>
<li>destruture array</li>
<li>destructure map</li>
<li>looprecur</li>
</ul>

<p>
我们一样一样来
</p>
</div>

<div id="outline-container-org49673ab" class="outline-4">
<h4 id="org49673ab">block scope binding</h4>
<div class="outline-text-4" id="text-org49673ab">
<p>
我们都知道js var是function scope, 也就是说可以
</p>
<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">a</span> =1;
<span style="color: #00008b;">for</span>(<span style="color: #00008b;">var</span> <span style="color: #b8860b;">a</span>=0;a&lt;3;a++){
  <span style="color: #00008b;">var</span> <span style="color: #b8860b;">b</span> = a+1
}
console.log(a, b)<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; 3,3</span>
</code></pre>

<p>
所有的var会被hoist到函数的顶部, 相当于
</p>
<pre class="code"><code><span style="color: #00008b;">var</span> <span style="color: #b8860b;">a</span>,<span style="color: #b8860b;">b</span>;
a=1
  <span style="color: #00008b;">for</span>(a=0;a&lt;3;a++){
    b = a+1
  }
</code></pre>

<p>
虽然 <a href="./essential-ecmascript6.html">es6 支持了 let block scope</a> 局部变量的定义, 但还是没有类似clojure的 let 表达式
</p>

<p>
我喜欢能有这样一个东西
</p>

<pre class="code"><code><span style="color: #00008b;">let</span>(a=1,b=2){a+b} === 3
</code></pre>

<p>
由于js只有function scope, 所以应该要扩展成
</p>
<pre class="code"><code><span style="color: #00008b;">function</span>(<span style="color: #b8860b;">a</span>,<span style="color: #b8860b;">b</span>){
  <span style="color: #00008b;">return</span> a+b
}(1,2)
</code></pre>


<p>
用macro实现这个再简单不过了
</p>
<pre class="code"><code>macro <span style="color: #00008b;">let</span> {
  rule { ($($key:ident=$val:expr) (,)...){$body:expr...$last:expr} } =&gt;{
    (<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">$key</span>(,)...){
      $body...
        <span style="color: #00008b;">return</span> $last
    })($val(,)...)
  }
}
</code></pre>

<p>
so easy, <del>block scope binding</del>
</p>
</div>
</div>

<div id="outline-container-org7925741" class="outline-4">
<h4 id="org7925741">destruture array</h4>
<div class="outline-text-4" id="text-org7925741">
<p>
这个就稍微有那么点难度, 我们先把它分解成小问题
</p>
<ol class="org-ol">
<li>一个空的binding返回空</li>
</ol>
<pre class="code"><code>[]=[1,2,3] -&gt; nothing
</code></pre>
<ol class="org-ol">
<li>一个正常的binding还是它自己</li>
</ol>
<pre class="code"><code>a=[1,2,3] -&gt; a=[1,2,3]
</code></pre>
<ol class="org-ol">
<li>单个元素的destruct, 等于第一个元素</li>
</ol>
<pre class="code"><code>[a] = [1,2,3] -&gt; a=[1,2,3][0]
</code></pre>
<ol class="org-ol">
<li>多个元素的destruct, 等于用第4部destruct头元素, 用5递归destruct尾部元素</li>
</ol>
<pre class="code"><code>[a,b,c] = [1,2,3] -&gt; destruct2(a=1), destruct5([,b,c]=[,2,3])
</code></pre>
<ol class="org-ol">
<li>尾部的destruct, 同样取第一个元素destruct, 然后自递归</li>
</ol>
<pre class="code"><code>[,b,c] = [,2,3] -&gt; destruct2(b=2), destruct5([,c]=[,3])
</code></pre>
<ol class="org-ol">
<li>最后一个元素的destruct</li>
</ol>
<pre class="code"><code>[,c] =[,3] -&gt; c=3
</code></pre>

<p>
phewww&#x2026;&#x2026;分解完好像覆盖了所有情况了, 现在用macro实现就太简单了
</p>
<pre class="code"><code>macro destruct {
  <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">1</span>
  rule {[]=$val:expr} =&gt; {}
  <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">2</span>
  rule {$id:ident=$val:expr} =&gt; {$id=($val)}
  <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">3</span>
  rule {[$id:ident]=$val:expr} =&gt; { $id=($val[0]) }
  <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">6</span>
  rule { [,$last:ident]=$val:expr}=&gt;{$last=($val[0])}
  <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">5</span>
  rule {[, $id:ident $tail...]=$val:expr}=&gt; {destruct $id=($val.shift()), destruct [$tail...]=$val.slice(1)}
  <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">4</span>
  rule {[$id:ident $tail...]=$val:expr} =&gt; {destruct $id=($val.shift()), destruct [$tail...]=$val.slice(1)}
}
</code></pre>

<p>
完了吗? 好像还没有, 万一有嵌套呢, 比如这样
</p>
<pre class="code"><code>[a, [b,c]] =[1,[2,3],4]
</code></pre>

<p>
好吧, 不就是再多一层递归么, 拨开便好了
</p>
<pre class="code"><code><span style="color: #8c8c8c; font-style: italic;">//</span><span style="color: #8c8c8c; font-style: italic;">&#22836;&#37096;&#23884;&#22871;, &#25320;&#24320;</span>
rule {[[$id:ident]]=$val:expr} =&gt; { destruct [$id]=($val[0]) }
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">&#23614;&#37096;&#23884;&#22871;, &#25320;&#24320;&#25320;&#24320;</span>
rule { [,[$last:ident]]=$val:expr}=&gt;{destruct [$last]=($val[0])}
</code></pre>

<p>
destructure object 的过程也非常类似, 我就懒得实现了
</p>
</div>
</div>
<div id="outline-container-org88ce3b8" class="outline-4">
<h4 id="org88ce3b8">looprecur</h4>
<div class="outline-text-4" id="text-org88ce3b8">
<p>
looprecur其实就是let的尾递归, 很容易变成循环
</p>
<pre class="code"><code>loop(a=1,b=18){
  <span style="color: #00008b;">if</span> (a &gt; b)
    <span style="color: #00008b;">return</span> a
  recur (a++,b--)
}
</code></pre>
<p>
其实就是特殊的let, 只是在尾部从新绑定了 a 和 b 的值, 然后在let一下, 虽然是 clojure的东东, 但是这里
是不是看起来非常的像JS原生呢:)
</p>

<p>
好了, 我们期待的当然是直接优化成循环了
</p>
<pre class="code"><code>(fucntion (a,b) {
  <span style="color: #00008b;">while</span>(<span style="color: #6b8e23;">true</span>){
    <span style="color: #00008b;">if</span>(a&gt;b)
      <span style="color: #00008b;">return</span> a
    a++;
    b--;
  }
})(1,18)
</code></pre>

<p>
let都实现了, 实现这也太容易了
</p>
<pre class="code"><code>macro loop {
  rule {($params...){$body... recur($binding:expr(,)...)}} =&gt; {
    <span style="color: #00008b;">let</span>($params...){
      <span style="color: #00008b;">while</span> (<span style="color: #6b8e23;">true</span>) {
        $body...;
          $binding(;)...
      }
    }
  }
}
</code></pre>
<p>
直接调用let就好了, 只要把body循环那么一下, binding放到循环最后.
</p>
</div>
</div>
</div>
<div id="outline-container-org74cdc5e" class="outline-3">
<h3 id="org74cdc5e">Existential ?</h3>
<div class="outline-text-3" id="text-org74cdc5e">
<p>
只移植 clojure 是不是开始有点无聊了, 让我们换换口味. CoffeeScript的判空我一直是非常喜欢, 不如试试也移过来,就可以这样了.
</p>
<pre class="code"><code>a?.b?().c?=1
</code></pre>

<p>
比起嵌套一大堆if else或者是 Haskell fancy的 maybe monad, 这样的判空操作非常简单而且可读.
</p>


<figure>
<img src="./images/maybe.gif" alt="maybe.gif">

</figure>
</div>

<div id="outline-container-org658d7f5" class="outline-4">
<h4 id="org658d7f5">Infix macro</h4>
<div class="outline-text-4" id="text-org658d7f5">
<p>
还记得 <a href="./clojure-essence-in-javascript-macro.html">上篇</a> 提到这次要讲 Infix macro吗, 恩, 要实现 <code>?</code> 我们必不可少需要使用Infix macro.
</p>

<p>
等等, 什么是 Infix macro.
</p>

<p>
注意前面一堆 macro 的keyword都是在开始的, 比如 let, loop, 都必须以这个关键字开始, macro才知道怎么去扩展.
</p>

<p>
那么问题来了, <code>?</code> 其实是中间的关键字, 我们需要拿到 <code>?</code> 前和 <code>?</code> 后的 token. 这正是 infix macro 能干的事情.
</p>

<p>
来思考一下如果拿到 <code>?</code> 前后的 token 我们应该要怎么办? 当然是写成 if 判断咯, <code>?</code> 前面的是判断对象, 如果为true
则与后面的token连上(把 <code>?</code> 去掉)
</p>

<pre class="code"><code>macro (?) {
  rule infix {$left:expr | $right... } =&gt; {
    (<span style="color: #00008b;">function</span>(){
      <span style="color: #00008b;">if</span>(<span style="color: #00008b;">typeof</span> $left!==<span style="color: #8b0000;">'undefined'</span> &amp;&amp; $left!==<span style="color: #6b8e23;">null</span>){
        <span style="color: #00008b;">return</span> $left $right...
      }
    })()
  }
}
</code></pre>

<p>
注意 infix macro 需要在 rule 后加上 <code>infix</code> 的keyword. 当然 infix 不仅可以用于 rule macro, 同样也可以用到
case macro
</p>
<pre class="code"><code>macro (?) {
  <span style="color: #00008b;">case</span> infix {$left:expr |$name $right... } =&gt; {
    <span style="color: #00008b;">return</span> #{
      (<span style="color: #00008b;">function</span>(){
        <span style="color: #00008b;">if</span>(<span style="color: #00008b;">typeof</span> $left!==<span style="color: #8b0000;">'undefined'</span> &amp;&amp; $left!==<span style="color: #6b8e23;">null</span>){
          <span style="color: #00008b;">return</span> $left $right...
        }
      })()  
    }
  }
}
</code></pre>

<p>
稍微不一样的是原来case macro的第一个参数要放到 <code>|</code> 后面了
</p>
</div>
</div>
</div>

<div id="outline-container-org20ee69d" class="outline-3">
<h3 id="org20ee69d">在哪里才能买到呢</h3>
<div class="outline-text-3" id="text-org20ee69d">

<figure>
<img src="./images/shut-up-and-take-my-money.gif" alt="shut-up-and-take-my-money.gif">

</figure>

<p>
总之第一次尝试用 sweet.js移植一些macro 或者其他语言的语法糖看似还不错, ru-lang 还在 heavy development 阶段, 虽然
还不完整, 但是总算可以证实这个想法的可行性, 接下来一块很难啃的骨头应该是移植 core.async.
</p>

<p>
另外 <a href="./clojure-essence-in-javascript-macro.html">上篇</a> 提到的还说要解释operator, 这里就懒得说了, 如果把 infix macro 的前后都改成 expr, 其实是差不多的,
只是operator 还会多两个东西, 优先级, 左结合还是有结合. 当然用法跟 infix macro是非常像的, 我就不多说了.
</p>

<p>
如果对这个项目有兴趣, 不妨接着在hacker news
</p>
<a href="https://news.ycombinator.com/submit" class="hn-button" data-url="http://ru-lang.org" data-count="horizontal">Vote on Hacker News</a><script type="text/javascript">var HN=[];HN.factory=function(e){return function(){HN.push([e].concat(Array.prototype.slice.call(arguments,0)))};},HN.on=HN.factory("on"),HN.once=HN.factory("once"),HN.off=HN.factory("off"),HN.emit=HN.factory("emit"),HN.load=function(){var e="hn-button.js";if(document.getElementById(e))return;var t=document.createElement("script");t.id=e,t.src="//hn-button.herokuapp.com/hn-button.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n)},HN.load();</script>
<p>
上讨论, 或者帮我在github上再加颗星
</p>
<a aria-label="Star jcouyang/ru on GitHub" data-count-aria-label="# stargazers on GitHub" data-count-api="/repos/jcouyang/ru#stargazers_count" data-count-href="/jcouyang/ru/stargazers" data-style="mega" data-icon="octicon-star" href="https://github.com/jcouyang/ru" class="github-button">Star</a><script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
<p>
也是极好的.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<footer>
  <p>Author: root <a aria-label="Follow @jcouyang on GitHub" data-count-aria-label="# followers on GitHub" data-count-api="/users/jcouyang#followers" data-count-href="/jcouyang/followers" href="https://github.com/jcouyang" class="github-button">Follow @jcouyang</a></p>
  <p>Modified: 2019-12-23 Mon 12:11</p>
  <p>Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.2 (<a href="https://orgmode.org">Org</a> mode 9.2.6) &#215; <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.
  <input type="swiftype" class="st-default-search-input" placeholder="Search"/>
  <a class="gumroad-button" href="https://gum.co/grokking-monad?wanted=true" target="_blank" data-gumroad-single-product="true">范畴论装逼指南，请自觉排队装逼</a>
  <div id="danmaku-comments"></div>
  <div id="disqus_thread"></div>
</footer>
</div>
</body>
</html>
