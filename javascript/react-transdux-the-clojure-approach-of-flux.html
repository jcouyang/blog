<!DOCTYPE html>
<html lang="zh-CN">
<head>
<!-- 2021-08-15 Sun 01:49 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>看我们3天 hackday 都干了些什么</title>
<meta name="generator" content="Org mode">
<meta name="author" content="欧阳继超">
<meta name="keywords" content="hackday, clojure,clojurescript,javascript,react,flux,redux,transdux">
<link rel="icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/toc.css"/>
<link rel="stylesheet" href="/style/tufte.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="https://feeds.oyanglul.us/JichaoOuyangsBlog"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJRFJGX"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<header>
    <a accesskey="h" href="/index.html"> HOME </a> |
    <a href="#" id="edit-in-github">EDIT</a> |
    <a href="https://feeds.oyanglul.us/JichaoOuyangsBlog">RSS</a> |
    <a href="https://blog.oyanglul.us/theindex">INDEX</a> |
    <a accesskey="H" href="/jichao.ouyang.html">ABOUT</a> |
    <a href="https://github.com/jcouyang/blog">GITHUB</a>
</header>
</div>
<div id="content">
<header>
<h1 class="title">看我们3天 hackday 都干了些什么</h1>
</header><nav id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8ce3d9e">Rationale</a>
<ul>
<li><a href="#orgad687d2">flux</a></li>
<li><a href="#org4653f5a">redux</a></li>
</ul>
</li>
<li><a href="#org1c783ff">Clojure Avengers 来相助</a>
<ul>
<li><a href="#orgcad52f6">Channels</a></li>
<li><a href="#orge254e02">PubSub</a></li>
<li><a href="#org4719e2c">Transducers</a></li>
<li><a href="#org8db57d4">Atom</a></li>
</ul>
</li>
<li><a href="#orgc07f4bd">Day 0 - Inception</a></li>
<li><a href="#org3f1f200">Day 1 - Hack Hack Hack&#x2026;</a>
<ul>
<li><a href="#org8eb096b">初版，只实现一个功能</a></li>
<li><a href="#orge136126">提取框架</a>
<ul>
<li><a href="#org005a4bc">传递 inputChan 和 action 的 publication</a></li>
<li><a href="#orge982b4e">分辨不同的 ReactClass</a></li>
<li><a href="#org64beae9">bindActions</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org91ea635">Day 2 - Show Case</a></li>
<li><a href="#orgc13dec7">Recap</a>
<ul>
<li><a href="#org3322f68">1. 把你的 component 包到 Transdux 里</a></li>
<li><a href="#orgb64b2bf">2. 定义你的 component 能干什么？你的状态能怎么变？</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<p>
好不容易有3天属于 hacker 的日子， 从 idea 到产品，我们到底能做些什么？从 <b>痛点</b> 出发，最近的项目被 React 和 React Router 虐的不算轻，很大程度上因为我们是半路接手的。真的算是前人 <del>瓦🖖肯</del> 后人 <del>植树</del> 擦屁股。
</p>

<div class="epigraph"><blockquote>
<p>
到底干了些什么呢？ 专业剧透 🐶 30年提示您请看 url 👆️ 并点这里 👉 <a href="https://github.com/jcouyang/transdux">https://github.com/jcouyang/transdux</a>
</p>

</blockquote></div>
<div id="outline-container-org8ce3d9e" class="outline-2">
<h2 id="org8ce3d9e">Rationale</h2>
<div class="outline-text-2" id="text-org8ce3d9e">
<p>
鉴于大部分 React 初学者都困惑的问题，我在<a href="http://blog.oyanglul.us/javascript/react-cookbook-mini.html#orgheadline39">浓缩 React 煮书</a>中也讲过
</p>

<div class="epigraph"><blockquote>
<p>
如果两个 Component 不是父子关系或者兄弟或者伯父侄女，该如何交互
</p>

</blockquote></div>

<p>
我当时的回答是
</p>
<div class="epigraph"><blockquote>
<p>
如果两个 Component 不是父子关系或者兄弟或者伯父侄女，他们真的需要交互吗？
</p>

</blockquote></div>

<p>
所以毫无框架的解决方案就是找到两个 component 的共同父元素，一层一层回调上去，在一层一层 props 传导 另一个 component。
</p>


<figure>
<img src="images/share-parent-components.png" alt="share-parent-components.png">

</figure>


<p>
好吧，如果 component 树的层次太多，那么写 callback 就会跟这个图上忍亲戚一样晕，而且一旦中间谁在往了传这个 callback 就会挂掉。
</p>
</div>

<div id="outline-container-orgad687d2" class="outline-3">
<h3 id="orgad687d2">flux</h3>
<div class="outline-text-3" id="text-orgad687d2">
<p>
于是，对于复杂 component 交互的情景，facebook 提供了 flux 架构设计（当然也实现了<a href="https://github.com/facebook/flux">https://github.com/facebook/flux</a>）
</p>


<figure>
<img src="https://raw.githubusercontent.com/facebook/flux/master/docs/img/flux-diagram-white-background.png" alt="flux-diagram-white-background.png">

<figcaption><span class="figure-number">&#22270;2&nbsp; </span>flux 架构</figcaption>
</figure>

<p>
这个图估计大家被各种 facebook 的 jsconf 洗过脑了，单向的数据流，中间加了一大堆东西
</p>


<figure>
<img src="./images/brainwashing-frog.gif" alt="brainwashing-frog.gif">

</figure>

<ul class="org-ul">
<li>action：要干什么</li>
<li>dispatcher：到哪里去</li>
<li>store：变什么/如何变</li>
</ul>


<p>
基本思想就是把一个 component 想干的事情弄成 action，dispatcher 会为不同的 action 调用不用的 store 中的 reducer，store 真正管理着 component 的状态。 把引起状态变化的每一部都分解出来。恩，大型项目一定要这么分解才算大型，没有什么问题。
</p>

<p>
原文思想如下，facebook 的表达能力我也是给跪了:
</p>
<div class="epigraph"><blockquote>
<p>
All data flows through the dispatcher as a central hub. Actions most often originate from user interactions with the views, and action creators are nothing more than a call into the dispatcher. The dispatcher then invokes the callbacks that the stores have registered with it, effectively dispatching the data payload contained in the actions to all stores. Within their registered callbacks, stores determine which actions they are interested in, and respond accordingly. The stores then emit a "change" event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own render() method via setState() or forceUpdate(), updating themselves and all of their children.
</p>

</blockquote></div>

<p>
思想是不错，但是看看例子，这个dispacher 是怎么个回事
</p>
<div class="org-src-container">
<pre class="src src-js">AppDispatcher.register(<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">action</span>) {
  <span style="color: #00008b;">var</span> <span style="color: #b8860b;">text</span>;

  <span style="color: #00008b;">switch</span>(action.actionType) {
    <span style="color: #00008b;">case</span> TodoConstants.TODO_CREATE:
      text = action.text.trim();
      <span style="color: #00008b;">if</span> (text !== <span style="color: #8b0000;">''</span>) {
        create(text);
        TodoStore.emitChange();
      }
      <span style="color: #00008b;">break</span>;

    <span style="color: #00008b;">case</span> TodoConstants.TODO_TOGGLE_COMPLETE_ALL:
      <span style="color: #00008b;">if</span> (TodoStore.areAllComplete()) {
        updateAll({complete: <span style="color: #6b8e23;">false</span>});
      } <span style="color: #00008b;">else</span> {
        updateAll({complete: <span style="color: #6b8e23;">true</span>});
      }
      TodoStore.emitChange();
      <span style="color: #00008b;">break</span>;
...
</pre>
</div>
<p>
我一直以为 dispatcher 应该自动给我 dispatcher 才对，我自己都 dispatcher 完了还要 dispatcher 干什么？
</p>
</div>
</div>

<div id="outline-container-org4653f5a" class="outline-3">
<h3 id="org4653f5a">redux</h3>
<div class="outline-text-3" id="text-org4653f5a">
<p>
于是 redux 出来把 dispatcher 这一步去掉了，然后放到了 reducer 里：
</p>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #00008b;">function</span> <span style="color: #6a5acd;">counter</span>(<span style="color: #b8860b;">state</span> = 0, <span style="color: #b8860b;">action</span>) {
  <span style="color: #00008b;">switch</span> (action.type) {
  <span style="color: #00008b;">case</span> <span style="color: #8b0000;">'INCREMENT'</span>:
    <span style="color: #00008b;">return</span> state + 1
  <span style="color: #00008b;">case</span> <span style="color: #8b0000;">'DECREMENT'</span>:
    <span style="color: #00008b;">return</span> state - 1
  <span style="color: #00008b;">default</span>:
    <span style="color: #00008b;">return</span> state
  }
}
</pre>
</div>


<p>
然后就获得了一片好评
</p>
<div class="epigraph"><blockquote>
<p>
“Love what you’re doing with Redux”
Jing Chen, creator of Flux
</p>

<p>
“I asked for comments on Redux in FB's internal JS discussion group, and it was universally praised. Really awesome work.”
Bill Fisher, author of Flux documentation
</p>

<p>
   “It's cool that you are inventing a better Flux by not doing Flux at all.”
André Staltz, creator of Cycle
</p>

</blockquote></div>

<p>
我竟无言以对&#x2026;
</p>


<figure>
<img src="./images/wait-your-serious.gif" alt="wait-your-serious.gif">

</figure>
</div>
</div>
</div>

<div id="outline-container-org1c783ff" class="outline-2">
<h2 id="org1c783ff">Clojure Avengers 来相助</h2>
<div class="outline-text-2" id="text-org1c783ff">
<p>
好了，现在的问题很明确，用一堆 <b>switch case</b> 来 <b>dispatch</b> 不管放到 dispatcher 里还是 store 里都一样的 <b>难看！难看！难看！</b> 而且 用户为什么需要做一些跟业务无关的事情，如果你看一下 redux todomvc 的例子：
</p>

<ul class="org-ul">
<li>用户需要自己创建一个全局的 store？</li>
</ul>

<figure>
<img src="https://www.evernote.com/l/ABf1E2CyquRCkZOYQjiSKL5ycV3_OiR1inMB/image.png" alt="image.png">

</figure>

<ul class="org-ul">
<li>用户需要“连接”带有 action 的 props 和 App Component？</li>
</ul>

<figure>
<img src="https://www.evernote.com/l/ABeCF0zsoQhPPJnRP4wQK0hxMbkT8zuBsS0B/image.png" alt="image.png">

</figure>

<ul class="org-ul">
<li>用户需要把 action 当 props 传下去？跟传 callback 一样？</li>
</ul>

<figure>
<img src="https://www.evernote.com/l/ABccOUGGTZVMxoqeT3GOAsoQNX1-S0b4r4MB/image.png" alt="image.png">

</figure>

<p>
来看看 Clojure 提供了哪些优雅的东西能帮助我们消除这些看起来不顺眼的设计&#x2026;
</p>
</div>

<div id="outline-container-orgcad52f6" class="outline-3">
<h3 id="orgcad52f6">Channels</h3>
<div class="outline-text-3" id="text-orgcad52f6">
<p>
Channel 是 CSP<label for="1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="1" class="margin-toggle"/><span class="sidenote">
具体可以参考我的另一篇文章 <a href="http://blog.oyanglul.us/javascript/clojure-core.async-essence-in-native-javascript.html">http://blog.oyanglul.us/javascript/clojure-core.async-essence-in-native-javascript.html</a>
</span> 的概念，类似一个队列，一边进，一边出。 不过进和出都是异步的
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #00008b;">const</span> {chan, take, put} = require(<span style="color: #8b0000;">'con.js/async'</span>).<span style="color: #00008b;">async</span>
<span style="color: #00008b;">let</span> <span style="color: #b8860b;">c</span> = chan()
take(c).then(_=&gt;console.log(_))
put(c, <span style="color: #8b0000;">'hehe'</span>)
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">"hehe"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge254e02" class="outline-3">
<h3 id="orge254e02">PubSub</h3>
<div class="outline-text-3" id="text-orge254e02">
<p>
Pub(blication) 可以指定把 Channel 的某一部分发布出去，让 Sub(scribe) 来 订阅。
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #00008b;">const</span> {chan, take, put, pub, sub} = require(<span style="color: #8b0000;">'con.js/async'</span>).<span style="color: #00008b;">async</span>
<span style="color: #00008b;">let</span> <span style="color: #b8860b;">inputChan</span> = chan()
<span style="color: #00008b;">let</span> <span style="color: #b8860b;">actionPub</span> = pub(inputChan, _=&gt;_.action)
<span style="color: #00008b;">let</span> <span style="color: #b8860b;">outputChan</span> = chan()
<span style="color: #00008b;">let</span> <span style="color: #b8860b;">actionSub</span> = sub(actionPub, <span style="color: #8b0000;">'greeting'</span>, outputChan)
put(inputChan, {action: <span style="color: #8b0000;">'greeting'</span>, value: <span style="color: #8b0000;">'Hello Clojure pubsub'</span>})
put(inputChan, {action: <span style="color: #8b0000;">'party'</span>, value: <span style="color: #8b0000;">'wheeeee'</span>})
take(outputChan).then(_=&gt;console.log(_))
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">{action: 'greeting', value: 'Hello Clojure pubsub'}</span>
</pre>
</div>

<p>
绑定到 outputChan 的 sub 只会接收 action 为 greeting 的消息
</p>
</div>
</div>

<div id="outline-container-org4719e2c" class="outline-3">
<h3 id="org4719e2c">Transducers</h3>
<div class="outline-text-3" id="text-org4719e2c">
<p>
首先声明：Transducer 不是柯里化，不是柯里化，不是柯里化！
</p>

<p>
在 Clojure 1.7 之后，当 map，filter之类的函数只接收一个函数时返回 transducer。transducers 是可以重用，组合，应用到各种集合与 Channel 上的特殊函数。<label for="2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="2" class="margin-toggle"/><span class="sidenote">
专门写过一篇文章介绍过 <a href="http://blog.oyanglul.us/javascript/clojure-essence-in-javascript-transducer.html">http://blog.oyanglul.us/javascript/clojure-essence-in-javascript-transducer.html</a>
</span>
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #00008b;">const</span> {chan, map, take, put} = require(<span style="color: #8b0000;">'con.js/async'</span>).<span style="color: #00008b;">async</span>
<span style="color: #00008b;">let</span> <span style="color: #b8860b;">xf</span> = map(_=&gt;_*2)
<span style="color: #00008b;">let</span> <span style="color: #b8860b;">c</span> = chan(32, xf)
put(c, 3)
take(c, _=&gt;console.log(_))
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">6</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org8db57d4" class="outline-3">
<h3 id="org8db57d4">Atom</h3>
<div class="outline-text-3" id="text-org8db57d4">
<p>
原子这个名字起得好，函数式编程的数据结构都是 immutable 的，如果多线程需要共享资源，那么函数式如何解决？
</p>

<p>
解决多线程通常我们会加锁，有锁的操作就相当于原子操作，在操作共享资源的时候，不用操心值会突然被别的线程改掉。
</p>

<p>
但是 atom 使用另外一种方式实现原子操作， atom 类似容器，ref 会指到当前的值到底是哪一个。然后，操作 atom 必须使用原子操作 swap!，swap! 能保障 原子性的原理非常简单，就是尝试将新值放到 atom 中，如果当前 ref 和 换出来的值不一样了，说明另一个线程也在 swap!  这个 atom。swap! 会从头再来一遍。
</p>

<p>
当我们有很多的 channel 是会并发的操作 state，所以这里我们需要使用 atom 来保证我们的 setState 是原子操作。
</p>

<p>
<i>由于是使用 transducer 来替代 redux 的 reducer，我给新框架 <del>山寨</del> 响亮的叫做 Transdux ！</i>
</p>
</div>
</div>
</div>

<div id="outline-container-orgc07f4bd" class="outline-2">
<h2 id="orgc07f4bd">Day 0 - Inception</h2>
<div class="outline-text-2" id="text-orgc07f4bd">
<p>
在解释了一通我们需要用到的 Clojure 数据结构，我们开始试试将他们融合到一起，来管理我们的 Component 的 state。
</p>

<p>
经过我们一下午（早上是 kickoff和解释上面这一堆数据结构) 激 <del>情</del> 烈的讨论，终于初步有了 transdux 的雏形
</p>


<figure>
<img src="https://www.evernote.com/l/ABd31BSoVoxMGJ66lygc0t2mK0cAmW3VQ60B/image.png" alt="image.png">

<figcaption><span class="figure-number">&#22270;8&nbsp; </span>transdux 原型草稿</figcaption>
</figure>

<ol class="org-ol">
<li>从 ClojureScript 把 transducer，channel，pub，sub 之类的 export 出来，compile 成 JavaScript。借用 mori，<a href="https://medium.com/@oyanglulu/i-just-fork-mori-and-add-core-async-to-it-3cea689e9259#.fzwrn6ofm">fork 一下改改完成了</a>，我把它叫 <a href="http://github.com/jcouyang/conjs">conjs</a></li>
<li>使用 pubsub 来替代 dispatcher，当 sub 了 action 的不同类型之后，自然也自动只接收 subscribe 的消息。所以这里框架会为每一个 action 生成一个 sub</li>
<li>框架还需要为每一个 sub 准备一个输出 channel，然后使用 transducer 将用户的业务逻辑绑到输出 channel 上。这样每次经过这个输出的 channel 的消息，都会被用户的业务逻辑处理，得出新的 state。</li>
</ol>

<p>
好了，大致就这样了，那么该如何开始做呢？回到我们做这个框架的初心，是为了用户写出更简洁的代码，同时还能获得 [fl|re]dux 的好处。
</p>

<p>
那么我们就 EDD（Example Driven Development，骚年，别查了，我随便编的词） 一把好了。EDD 的过程是这样的
</p>
<ol class="org-ol">
<li>去 redux 的 repo 把那个丑丑的 todomvc 例子考过来</li>
<li>把所有 redux 框架 <del>污染</del> 覆盖的地方都删掉，都删掉，删掉，掉&#x2026;</li>
<li>好了，例子在没有 redux 之后肯定会挂掉了，那么现在，用前面解释的拉一大堆 Clojure 的数据结构把 todomvc 在给实现了。</li>
</ol>
</div>
</div>

<div id="outline-container-org3f1f200" class="outline-2">
<h2 id="org3f1f200">Day 1 - Hack Hack Hack&#x2026;</h2>
<div class="outline-text-2" id="text-org3f1f200">
<div class="epigraph"><blockquote>
<p>
注意，我已经把要用到的这一堆 Clojure 数据机构都 export 并 compile 成了 javascript。想具体了解的可以看<a href="https://medium.com/@oyanglulu/i-just-fork-mori-and-add-core-async-to-it-3cea689e9259#.fzwrn6ofm">这篇文章</a>和 <a href="http://github.com/jcouyang/conjs">conjs 源码</a>
</p>

</blockquote></div>
</div>

<div id="outline-container-org8eb096b" class="outline-3">
<h3 id="org8eb096b">初版，只实现一个功能</h3>
<div class="outline-text-3" id="text-org8eb096b">
<p>
来看看我们 EDD 的<a href="https://github.com/jcouyang/transdux/blob/5da5107cb2de11414c5b3c2659cf19e790264ff9/src/components/MainSection.jsx#L33">第一版实现</a>，是多么的简单
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="linenr"> 1: </span>componentDidMount(){
<span class="linenr"> 2: </span>  <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">-------vv code user should write vv------------------</span>
<span id="coderef-complete" class="coderef-off"><span class="linenr"> 3: </span>  <span style="color: #00008b;">function</span> <span style="color: #6a5acd;">complete</span>(<span style="color: #b8860b;">msg</span>){</span>
<span class="linenr"> 4: </span>    <span style="color: #00008b;">return</span> state=&gt;map(todo=&gt;{
<span class="linenr"> 5: </span>      <span style="color: #00008b;">if</span>(todo.get(<span style="color: #8b0000;">'id'</span>)==msg.id)
<span class="linenr"> 6: </span>        <span style="color: #00008b;">return</span> updateIn(todo, [<span style="color: #8b0000;">'completed'</span>], _=&gt;!_ )
<span class="linenr"> 7: </span>        <span style="color: #00008b;">return</span> todo
<span class="linenr"> 8: </span>    }, state)
<span class="linenr"> 9: </span>  }
<span class="linenr">10: </span>  <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">---------------------------------</span>
<span class="linenr">11: </span>
<span class="linenr">12: </span>  <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">---------- code should extract to transdux -------------------</span>
<span class="linenr">13: </span>  <span style="color: #00008b;">let</span> <span style="color: #b8860b;">tx</span> = map((msg)=&gt;{
<span class="linenr">14: </span>    <span style="color: #00008b;">return</span> toJs(complete(msg)(extra.toClj(<span style="color: #6b8e23;">this</span>.state.todos)))
<span class="linenr">15: </span>  });
<span class="linenr">16: </span>
<span class="linenr">17: </span>  <span style="color: #00008b;">let</span> <span style="color: #b8860b;">completeChan</span> = chan(1, tx);
<span class="linenr">18: </span>
<span class="linenr">19: </span>  sub(<span style="color: #6b8e23;">this</span>.props.pub, <span style="color: #8b0000;">"Todo.complete"</span>, completeChan);
<span class="linenr">20: </span>
<span class="linenr">21: </span>  <span style="color: #00008b;">function</span> <span style="color: #6a5acd;">takeloop</span>(<span style="color: #b8860b;">chan</span>, <span style="color: #b8860b;">action</span>){
<span class="linenr">22: </span>    take(chan).then(action).then(takeloop.bind(<span style="color: #6b8e23;">null</span>, chan,action))
<span class="linenr">23: </span>  }
<span class="linenr">24: </span>  takeloop(completeChan, (newtodos)=&gt;{
<span class="linenr">25: </span>    <span style="color: #6b8e23;">this</span>.setState({todos: newtodos})
<span class="linenr">26: </span>  })
<span class="linenr">27: </span>  <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">----------</span>
<span class="linenr">28: </span>}
</pre>
</div>

<p>
 没有错，跟 TDD 一样，先实现，在重构
目的非常明确，用户只需要定义，我这个 component 能干什么，所以这里第<a href="#coderef-complete" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-complete');" onmouseout="CodeHighlightOff(this, 'coderef-complete');">3</a>行，就说我 是 todo 我能 complete
</p>

<p>
然后华丽的分割线下面是我们框架要做的事情
</p>
<ol class="org-ol">
<li>一个用用户提供的 action 组成的 transducer</li>
<li>一个 action channel，用来绑定 transducer</li>
<li>一个 sub， 只订阅 “todo.complete” 的消息</li>
<li>一个 loop，不停的去 action channel 那新的 state</li>
</ol>

<p>
那么在使用的地方，只需要发一个 action 为“todo.complete” 的消息即可
</p>
</div>
</div>

<div id="outline-container-orge136126" class="outline-3">
<h3 id="orge136126">提取框架</h3>
<div class="outline-text-3" id="text-orge136126">
<p>
当然我们需要封装这些裸裸的实现，当然提取这一票代码块特别简单，写一个 mixin 让需要用到的 component 自己 mixin 进来就好。
</p>

<p>
问题是，我们需要知道这个 Component 用到的 input channnel 和 publication 是谁。
</p>
</div>
<div id="outline-container-org005a4bc" class="outline-4">
<h4 id="org005a4bc">传递 inputChan 和 action 的 publication</h4>
<div class="outline-text-4" id="text-org005a4bc">
<p>
我不会使用 redux 那样笨笨的让用户一层层传下去的方式，有这功夫我可以传 callback，那框架到底为我做了什么？
</p>

<p>
所以，transdux 提供一个 wrapper component <i>Transdux</i>
</p>
<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #6a5acd;">Transdux</span>&gt;
    &lt;<span style="color: #6a5acd;">App</span>/&gt;
&lt;/<span style="color: #6a5acd;">Transdux</span>&gt;
</pre>
</div>

<p>
只需要用 Transdux component 包住你的 component 即可，如果你有两个 App，那么分别 wrap 可以保证他们用的是两套 transdux 的 channel，pubsub而互相不受干扰。
</p>
<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #6a5acd;">div</span>&gt;
  &lt;<span style="color: #6a5acd;">Transdux</span>&gt;
    &lt;<span style="color: #6a5acd;">App</span>/&gt;
  &lt;/<span style="color: #6a5acd;">Transdux</span>&gt;
  &lt;<span style="color: #6a5acd;">Transdux</span>&gt;
    &lt;<span style="color: #6a5acd;">App2</span>/&gt;
  &lt;/<span style="color: #6a5acd;">Transdux</span>&gt;
&lt;/<span style="color: #6a5acd;">div</span>&gt; 
</pre>
</div>

<p>
具体实现也不难，利用 React 的 child context
</p>

<div class="org-src-container">
<pre class="src src-js">childContextTypes: {
    transduxChannel: React.PropTypes.object,
    transduxPublication: React.PropTypes.object,
  },
  getChildContext(){
    <span style="color: #00008b;">let</span> <span style="color: #b8860b;">inputchan</span> = chan();
    <span style="color: #00008b;">return</span> {
      transduxChannel: inputchan,
      transduxPublication: pub(inputchan, _=&gt;_[<span style="color: #8b0000;">'action'</span>]),
    }
  },
</pre>
</div>

<p>
<a href="https://facebook.github.io/react/docs/context.html">child context</a> 是 React 一个 给子 component 传递 context 是一种方式， 通过这样就无需父 component 一层一层传下去，而在所有的子 component 都随时可以从 <code>this.context</code> 中找到父 component <code>getChildContext</code>  返回的值。
</p>

<p>
于是无需任何传递， 所有子 component都能获得 transdux 的 channel 以及 publication。
</p>
</div>
</div>

<div id="outline-container-orge982b4e" class="outline-4">
<h4 id="orge982b4e">分辨不同的 ReactClass</h4>
<div class="outline-text-4" id="text-orge982b4e">
<p>
另一个问题是，我们在 dispatch 的时候，如何知道给那个 component 发消息呢？最直接的方式是，把需要接受消息的 component require 进来
</p>
<div class="epigraph"><blockquote>
<p>
你过来，我保证不打你
</p>

</blockquote></div>
<div class="org-src-container">
<pre class="src src-js"><span style="color: #00008b;">import</span> MainSection from <span style="color: #8b0000;">'./MainSection'</span>
<span style="color: #00008b;">let</span> <span style="color: #b8860b;">TodoItem</span> = React.createClass({
    mixins: [TxMixin],
 ...
           <span style="color: #6b8e23;">this</span>.dispatch(MainSection, <span style="color: #8b0000;">'complete'</span>,{id:todo.id})
...
    }
})
</pre>
</div>

<p>
这样的消息非常清晰，而且永远不可能发错消息，除非 require 错了 component。
</p>

<p>
那么问题来了，dispatch 必须能根据这个 React Class 分辨？
</p>

<p>
<b>transdux</b> 为每一绑定 actions 的 component 生成一个 uuid
</p>
</div>
</div>
<div id="outline-container-org64beae9" class="outline-4">
<h4 id="org64beae9">bindActions</h4>
<div class="outline-text-4" id="text-org64beae9">
<p>
在有了 channel 和 publication 之后，我们可以开始绑定用户的 action 到 action channel 上，并生成相对应的 sub
</p>

<p>
把第一版实现的代码包到 mixin 中，会是这样的：
</p>
<div class="org-src-container">
<pre class="src src-js"><span class="linenr"> 1: </span>bindActions(actions, imm=id, unimm=id) {
<span class="linenr"> 2: </span>  <span style="color: #00008b;">let</span> <span style="color: #b8860b;">atomState</span> = atom(imm(<span style="color: #6b8e23;">this</span>.getInitialState()))
<span class="linenr"> 3: </span>  <span style="color: #00008b;">for</span>(<span style="color: #00008b;">let</span> <span style="color: #b8860b;">name</span> <span style="color: #00008b;">in</span> actions){
<span class="linenr"> 4: </span>    <span style="color: #00008b;">let</span> <span style="color: #b8860b;">tx</span> = map((msg)=&gt;{
<span id="coderef-swap" class="coderef-off"><span class="linenr"> 5: </span>      <span style="color: #00008b;">let</span> <span style="color: #b8860b;">result</span> = swap(atomState, (state,v)=&gt;actions[name](v,state), msg.value)</span>
<span class="linenr"> 6: </span>      <span style="color: #6b8e23;">this</span>.setState(unimm(result))
<span class="linenr"> 7: </span>      <span style="color: #00008b;">return</span> result
<span class="linenr"> 8: </span>    });
<span id="coderef-actionChan" class="coderef-off"><span class="linenr"> 9: </span>    <span style="color: #00008b;">let</span> <span style="color: #b8860b;">actionChan</span> = chan(32,tx);</span>
<span id="coderef-sub" class="coderef-off"><span class="linenr">10: </span>    sub(<span style="color: #6b8e23;">this</span>.context.transduxPublication, genUuid(<span style="color: #6b8e23;">this</span>.constructor)+name, actionChan);</span>
<span id="coderef-observe" class="coderef-off"><span class="linenr">11: </span>    observe(actionChan, (newstate)=&gt;{});</span>
<span class="linenr">12: </span>  }
<span class="linenr">13: </span>},
</pre>
</div>

<ul class="org-ul">
<li>还记得之前说的 atom 吗？<a href="#coderef-swap" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-swap');" onmouseout="CodeHighlightOff(this, 'coderef-swap');">这里</a> swap 尝试将 <code>msg.value</code> 和 <code>state</code> 传入 <code>actions[name]</code> ，将其返回值换入 atom 内。</li>
<li>第<a href="#coderef-actionChan" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-actionChan');" onmouseout="CodeHighlightOff(this, 'coderef-actionChan');">9</a>行将之前 map 返回的 transducer 放到 actionChan 上，其中的32代表 channel 的长度为32。 <b>注意什么时候这个 transducer 是 lazy 的，所以只有 take 的时候会应用 action 到 channel 的元素上</b> 。所以 transducer 真不是柯里化，不是柯里化，柯里化，里化，化&#x2026;</li>
<li>在第<a href="#coderef-sub" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-sub');" onmouseout="CodeHighlightOff(this, 'coderef-sub');">10</a>行把该 class 生成的 uuid 和 action 的名字作为 action 的唯一标识。由于是 mixin，所以直接能获得该 component 上的 publication</li>
<li>最后 observe 一下就好了，其实 observer 什么都没干，其实可以看看我的 <a href="https://github.com/jcouyang/conjs/blob/master/src/mori/core.async.cljs#L17">observe 实现</a>，只是一个简单的 go-loop，不停的 take channel 的消息。不然没人 take 消息会堆积满，就再也 put 不进来了。</li>
</ul>
<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #00008b;">defn</span> ^<span style="color: #6b8e23;">:export</span> <span style="color: #6a5acd;">observe</span> [chan cb]
  (go-loop []
    (<span style="color: #00008b;">let</span> [v (<span style="color: #36648b;">async</span>/&lt;! chan)]
      (cb v)
      (<span style="color: #00008b;">recur</span>))))
</pre>
</div>
</div>
</div>
</div>
</div>


<div id="outline-container-org91ea635" class="outline-2">
<h2 id="org91ea635">Day 2 - Show Case</h2>
<div class="outline-text-2" id="text-org91ea635">
<p>
托了 clojure 的福，我们并没有写多少代码，就轻松实现了一个对用户更友好的 flux like 框架。在核心功能实现后，我们开始进行 opensource project 的 routine
</p>
<ul class="org-ul">
<li>写 <a href="https://github.com/jcouyang/transdux/blob/master/README.org">readme</a></li>
<li>写例子 <a href="https://github.com/jcouyang/transdux/tree/master/examples/todomvc">todomvc</a></li>
<li>选个 <a href="http://choosealicense.com/">license</a></li>
<li><a href="https://www.npmjs.com/package/transdux">npm publish</a></li>
<li>准备能把大家将懂的 slide</li>
</ul>


<figure>
<img src="./images/applause.jpg" alt="applause.jpg">

<figcaption><span class="figure-number">&#22270;9&nbsp; </span>此处应有掌声</figcaption>
</figure>
</div>
</div>

<div id="outline-container-orgc13dec7" class="outline-2">
<h2 id="orgc13dec7">Recap</h2>
<div class="outline-text-2" id="text-orgc13dec7">

<figure>
<img src="https://www.evernote.com/l/ABe_8eE6o2dGlZMCmNnBap_fXy83GvJe6gcB/image.jpg" alt="image.jpg">

<figcaption><span class="figure-number">&#22270;10&nbsp; </span>The Big Picture of Transdux</figcaption>
</figure>

<p>
所以，使用 transdux  给 react component 交互，我们只需要为框架提供两件事情
</p>
</div>
<div id="outline-container-org3322f68" class="outline-3">
<h3 id="org3322f68">1. 把你的 component 包到 Transdux 里</h3>
<div class="outline-text-3" id="text-org3322f68">
<div class="org-src-container">
<pre class="src src-html">&lt;<span style="color: #6a5acd;">Transdux</span>&gt;
    &lt;<span style="color: #6a5acd;">App</span>/&gt;
&lt;/<span style="color: #6a5acd;">Transdux</span>&gt;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb64b2bf" class="outline-3">
<h3 id="orgb64b2bf">2. 定义你的 component 能干什么？你的状态能怎么变？</h3>
<div class="outline-text-3" id="text-orgb64b2bf">
<div class="org-src-container">
<pre class="src src-js"><span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">MainSection.jsx</span>
<span style="color: #00008b;">import</span> {TxMixin} from <span style="color: #8b0000;">'transdux'</span>
<span style="color: #00008b;">let</span> <span style="color: #b8860b;">actions</span> = {
  complete(msg, state){
    <span style="color: #00008b;">return</span> {
      todos:state.todos.map(todo=&gt;{
        <span style="color: #00008b;">if</span>(todo.id==msg.id)
          todo.completed = !todo.completed
        <span style="color: #00008b;">return</span> todo
      })
    }
  },
  clear(msg,state){
    <span style="color: #00008b;">return</span> {
      todos: state.todos.filter(todo=&gt;todo.completed==<span style="color: #6b8e23;">false</span>)
    }
  }
}
<span style="color: #00008b;">let</span> <span style="color: #b8860b;">MainSection</span> = React.createClass({
  mixins: [TxMixin],
  componentDidMount(){
    <span style="color: #6b8e23;">this</span>.bindActions(actions)
  },
  ...
})
</pre>
</div>

<p>
然后，就可以开始 <b>发消息</b> 了
</p>
<div class="org-src-container">
<pre class="src src-jsx">//TodoItem.jsx
import MainSection from './MainSection'
let TodoItem = React.createClass({
    mixins: [TxMixin],
    ...
      this.dispatch(MainSection, 'complete',{id:todo.id})
    ...
    }
})
</pre>
</div>

<p>
最后，要感谢我们棒棒的 Team member <a href="https://github.com/SanCoder-Q">@SanCoder-Q</a> <a href="https://github.com/zhangyaxuan">@zhangyaxuan</a> <a href="https://github.com/nihaokid">@nihaokid</a> <a href="https://github.com/xiaoyanzhuzzh">@xiaoyanzhuzzh</a> 
</p>

最后，欢迎 <a aria-label="Star jcouyang/transdux on GitHub" data-count-aria-label="# stargazers on GitHub" data-count-api="/repos/jcouyang/transdux#stargazers_count" data-count-href="/jcouyang/transdux/stargazers" data-style="mega" href="https://github.com/jcouyang/transdux" class="github-button">Fork me on Github</a>

<p>
<i>所有图片来源于 giphy.com, copyright</i> @<a href="http://www.cc.com/shows/futurama">Futurama</a>
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">&#33050;&#27880;: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
具体可以参考我的另一篇文章 <a href="http://blog.oyanglul.us/javascript/clojure-core.async-essence-in-native-javascript.html">http://blog.oyanglul.us/javascript/clojure-core.async-essence-in-native-javascript.html</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
专门写过一篇文章介绍过 <a href="http://blog.oyanglul.us/javascript/clojure-essence-in-javascript-transducer.html">http://blog.oyanglul.us/javascript/clojure-essence-in-javascript-transducer.html</a>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<footer>
  <p>Author: 欧阳继超
    <a class="github-button" href="https://github.com/sponsors/jcouyang" data-icon="octicon-heart" aria-label="Sponsor @jcouyang on GitHub">Sponsor</a>
    <a aria-label="Follow @jcouyang on GitHub" data-count-aria-label="# followers on GitHub" data-count-api="/users/jcouyang#followers" data-count-href="/jcouyang/followers" href="https://github.com/jcouyang" class="github-button">Follow</a>
    <a href="https://twitter.com/oyanglulu" class="twitter-follow-button" data-show-screen-name="false" data-show-count="false">Follow @oyanglulu</a>
  </p>
  <p>Created: 2015-11-22 Sun 00:00</p>
  <p>Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.3 (<a href="https://orgmode.org">Org</a> mode 9.3.6) &#215; <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.
  <input type="swiftype" class="st-default-search-input" placeholder="Search"/>
  <a class="gumroad-button" href="https://gum.co/grokking-monad?wanted=true" target="_blank" data-gumroad-single-product="true">范畴论装逼指南，请自觉排队装逼</a>
  <div id="danmaku-comments"></div>
  <div id="disqus_thread"></div>
</footer>
</div>
</body>
</html>
