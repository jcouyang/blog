<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2020-01-05 Sun 13:03 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>范畴论完全装逼手册 / Grokking Monad</title>
<meta name="generator" content="Org mode">
<meta name="author" content="欧阳继超">
<meta name="description" content="卷二 食用猫呢"
>
<link rel="icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/toc.css"/>
<link rel="stylesheet" href="/style/tufte.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="https://feeds.oyanglul.us/JichaoOuyangsBlog"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJRFJGX"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<header>
    <a accesskey="h" href="/index.html"> HOME </a> |
    <a href="#" id="edit-in-github">EDIT</a> |
    <a href="https://feeds.oyanglul.us/JichaoOuyangsBlog">RSS</a> |
    <a href="https://blog.oyanglul.us/theindex">INDEX</a> |
    <a accesskey="H" href="/jichao.ouyang.html">ABOUT</a> |
    <a href="https://github.com/jcouyang/blog">GITHUB</a>
</header>
</div>
<div id="content">
<header>
<h1 class="title">范畴论完全装逼手册 / Grokking Monad</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org2b83b31">第二部分：<ruby>食用猫呢<rt> Practical Monads</rt></ruby></a>
<ul>
<li><a href="#orgba82471">Identity 本身就有</a></li>
<li><a href="#orgf8c951a">Maybe 可能会有</a></li>
<li><a href="#org1c69b13">Either 要么有要么有</a>
<ul>
<li><a href="#org17bfad6">Product &amp; Coproduct</a></li>
<li><a href="#orge19ba66">Either Monad</a></li>
</ul>
</li>
<li><a href="#orgec20723">Reader 差一点就有</a>
<ul>
<li><a href="#org59b28eb">do notation</a></li>
</ul>
</li>
<li><a href="#org7505ce4">Writer 光出进没有</a></li>
<li><a href="#org30a3b76">State 变化会有</a></li>
<li><a href="#org105da09">Validation 检查检查</a>
<ul>
<li><a href="#org9f94784"><ruby>含幺半群<rt>Monoid</rt></ruby></a></li>
<li><a href="#orgd0bcad5">回到 Validation</a></li>
</ul>
</li>
<li><a href="#orgbfc4526">Cont 接下来有</a></li>
<li><a href="#org05e7f17">Summary</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<ul class="org-ul">
<li><a href="./part1.html">第一部分：范畴论</a></li>
<li><b><a href="./part2.html">第二部分：食用猫呢</a></b> 👈</li>
<li><a href="./part3.html">第三部分：搞基猫呢</a></li>
</ul>

<div id="outline-container-org2b83b31" class="outline-2">
<h2 id="org2b83b31">第二部分：<ruby>食用猫呢<rt> Practical Monads</rt></ruby></h2>
<div class="outline-text-2" id="text-org2b83b31">

<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Alice_through_the_looking_glass.jpg/761px-Alice_through_the_looking_glass.jpg" alt="761px-Alice_through_the_looking_glass.jpg">

</figure>

<div class="epigraph"><blockquote>
<p>
“If I had a world of my own, everything would be nonsense. 
Nothing would be what it is, because everything would be what it isn't.
And contrary wise, what is, it wouldn't be. And what it wouldn't be, it would. You see?”
― Lewis Carroll, Alice's Adventures in Wonderland &amp; Through the Looking-Glass 
</p>

</blockquote></div>

<p>
如果有一个单子的世界, 那一切都说不通了.
没有什么是应该的, 因为所有东西都是它不是的东西.
反过来说, 是又不会是, 而不会是的又会是. 懂没?
</p>

<p>
到底什么是, 什么不是, 我们看编程世界里到底什么是单子？
</p>

<p>
这一部分将介绍由一些实用的<ruby>单子实例<rt>monad instances</rt></ruby>，通过这些单子实例，解决了分离计算与副作用, 已经组合性的问题。
</p>
</div>

<div id="outline-container-orgba82471" class="outline-3">
<h3 id="orgba82471">Identity 本身就有<label for="1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="1" class="margin-toggle"/><span class="sidenote">
从来没见过有人给这些数据类型按过中文名字, 不然我来, 这样也更好的体会这些数据类型的意图.
</span></h3>
<div class="outline-text-3" id="text-orgba82471">
<p>
<ruby>本身就有单子<rt> Identity Monad</rt></ruby> 可能是最简单的单子了。本身不包含任何计算, 且只有一个构造器:
</p>
<pre class="code"><code><span style="color: #00008b;">newtype</span> <span style="color: #36648b;">Identity</span> a <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Identity</span> { runIdentity <span style="color: #b8860b;">::</span> a }
</code></pre>

<pre class="code"><code><span style="color: #00008b;">case</span> <span style="color: #00008b;">class</span> <span style="color: #36648b;">Identity</span>[<span style="color: #6b8e23;">A</span>](run<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span>)
</code></pre>

<p>
这里使用 <code>newtype</code> 而不是 <code>data</code> 是因为 <code>Identity</code> 与 <code>runIdentity</code> 是同构的<label for="2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="2" class="margin-toggle"/><span class="sidenote">
见 <a href="part1.html#orgf0aed70">第一部分 伴随函子</a>
</span>.
</p>

<pre class="code"><code><span style="color: #36648b;">Identity</span> <span style="color: #b8860b;">::</span> a <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">Identity</span> a
<span style="color: #6a5acd;">runIdentity</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">Identity</span> a <span style="color: #b8860b;">-&gt;</span> a
</code></pre>

<p>
你看 <code>runIdentity . Identity = id</code> ，所以他们是同构的。
</p>

<p>
左边的 <code>Identity</code> 是类型构造器<label for="3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="3" class="margin-toggle"/><span class="sidenote">
也就是 Kind * -&gt; *, 因为它非常的 nice, 一定要等到 a 才出类型
</span>, 接收类型 <code>a</code> 返回 <code>Identity a</code> 类型
</p>

<p>
如果 a 是 Int，那么就得到一个 <code>Identity Int</code> 类型。
</p>

<p>
右边的 <code>Identity</code> 是数据构造器，也就是构造值，比如 <code>Identity 1</code> 会构造出一个值，其类型为 <code>Identity Int</code>
</p>

<p>
大括号比较诡异，可以想象成给 <code>a</code> 一个 key，同过这个 key 可以把 a 取出来，比如
</p>
<pre class="code"><code><span style="color: #6a5acd;">runIdentity</span> (<span style="color: #36648b;">Identity</span> 1)
</code></pre>

<pre class="code"><code><span style="color: #6b8e23;">Identity</span>(<span style="color: #6b8e23;">1</span>).run
</code></pre>

<p>
会返回 1
</p>

<p>
Identity 可以实现 Functor 和 Monad，就得到 Identity functor 和 Identity monad:
</p>

<pre class="code"><code><span style="color: #00008b;">instance</span> <span style="color: #36648b;">Functor</span> <span style="color: #36648b;">Identity</span> <span style="color: #00008b;">where</span>
  fmap f (<span style="color: #36648b;">Identity</span> a) <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Identity</span> (f a)

<span style="color: #00008b;">instance</span> <span style="color: #36648b;">Monad</span> <span style="color: #36648b;">Identity</span> <span style="color: #00008b;">where</span>
  return a <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Identity</span> a
  <span style="color: #36648b;">Identity</span> a <span style="color: #b8860b;">&gt;&gt;=</span> f <span style="color: #b8860b;">=</span> f a
</code></pre>

<p>
而 Scala 则需要用 <code>implicit</code> 来实现 typeclass:
</p>

<pre class="code"><code><span style="color: #228b22;">implicit</span> <span style="color: #00008b;">val</span> <span style="color: #b8860b;">identityFunctor</span><span style="color: #00008b;">:</span> <span style="color: #36648b;">Functor</span>[<span style="color: #6b8e23;">Identity</span>] <span style="color: #00008b;">=</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">Functor</span>[<span style="color: #6b8e23;">Identity</span>] {
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">fmap</span>[<span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>](f<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">B</span>)<span style="color: #00008b;">:</span> <span style="color: #36648b;">Identity</span>[<span style="color: #6b8e23;">A</span>] <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">Identity</span>[<span style="color: #6b8e23;">B</span>] <span style="color: #00008b;">=</span> {
    <span style="color: #00008b;">case</span> <span style="color: #36648b;">Identity</span>(<span style="color: #b8860b;">a</span>) <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">Identity</span>(f(a))
  }
}

<span style="color: #228b22;">implicit</span> <span style="color: #00008b;">val</span> <span style="color: #b8860b;">identityMonad</span><span style="color: #00008b;">:</span> <span style="color: #36648b;">Monad</span>[<span style="color: #6b8e23;">Identity</span>] <span style="color: #00008b;">=</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">Monad</span>[<span style="color: #6b8e23;">Identity</span>] {
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">pure</span>[<span style="color: #6b8e23;">A</span>](a<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span>)<span style="color: #00008b;">:</span> <span style="color: #36648b;">Id</span>[<span style="color: #6b8e23;">A</span>] <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">Identity</span>(a)
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">flatMap</span>[<span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>](f<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">Identity</span>[<span style="color: #6b8e23;">B</span>])<span style="color: #00008b;">:</span> <span style="color: #36648b;">Identity</span>[<span style="color: #6b8e23;">A</span>] <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">Identity</span>[<span style="color: #6b8e23;">B</span>] <span style="color: #00008b;">=</span> {
    <span style="color: #00008b;">case</span> <span style="color: #36648b;">Identity</span>(<span style="color: #b8860b;">a</span>) <span style="color: #00008b;">=&gt;</span> f(a)
  }
}
</code></pre>

<p>
可以看到 Identity 即是<ruby>构造器<rt>constructor</rt></ruby>，也是<ruby>解构器<rt>destructure</rt></ruby>，利用模式匹配是可以解构出值的。
</p>

<p>
例如上面 Functor 实现中的 <code>fmap f (Identity a)</code>, 假如 <code>fmap</code> 的是 <code>Identity 1</code>,
那么这个模式匹配到 <code>(Identity a)</code> 时会通过解构器把 <code>1</code> 放到 <code>a</code> 的位置。
</p>

<p>
Identity 看起来什么也没有干，就跟 identity 函数一样，但是实际上, 它也跟 identity 相对于函数一样
相对于类型非常有用.
</p>
</div>
</div>

<div id="outline-container-orgf8c951a" class="outline-3">
<h3 id="orgf8c951a">Maybe 可能会有</h3>
<div class="outline-text-3" id="text-orgf8c951a">
<p>
<ruby>可能会有单子<rt>Maybe Monad</rt></ruby>是一个超级简单的但比本身就有稍稍复杂的单子.
</p>

<p>
因为它拥有比本身就有多一个的类型构造器，类似这样的叫做 <ruby>代数数据类型<rt> Algebra Data Type(ADT)</rt></ruby>
</p>

<pre class="code"><code><span style="color: #00008b;">data</span> <span style="color: #36648b;">Maybe</span> a <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Just</span> a <span style="color: #b8860b;">|</span> <span style="color: #36648b;">Nothing</span>
</code></pre>

<p>
你看, 不管是 <code>Just</code> 还是 <code>Nothing</code> 都可以构造出一个 <code>Maybe</code> 类型的数据来.
</p>

<p>
ADT 在 Scala 可以用 trait 表示, 而且, Scala 中的 <code>Maybe</code> 叫做 <code>Option</code>:
</p>

<pre class="code"><code><span style="color: #00008b;">trait</span> <span style="color: #36648b;">Option</span>[+<span style="color: #6b8e23;">A</span>]
<span style="color: #00008b;">case</span> <span style="color: #00008b;">class</span> <span style="color: #36648b;">Some</span>[<span style="color: #6b8e23;">A</span>](a<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span>) <span style="color: #00008b;">extends</span> <span style="color: #36648b;">Option</span>[<span style="color: #6b8e23;">A</span>]
<span style="color: #00008b;">case</span> <span style="color: #00008b;">object</span> <span style="color: #6b8e23;">None</span> <span style="color: #00008b;">extends</span> <span style="color: #36648b;">Option</span>[<span style="color: #6b8e23;">Nothing</span>]
</code></pre>

<p>
Haskell 中定义一个 ADT 十分简单，不像 Scala 那么啰嗦。左边是类型构造器，右边有数据构造器，你会发现有一根竖线 <code>|</code> ， 它分隔着两个构造器
</p>
<ul class="org-ul">
<li><code>Just</code></li>
<li><code>Nothing</code></li>
</ul>

<p>
其中 <code>a</code> <label for="4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="4" class="margin-toggle"/><span class="sidenote">
一定要记得小写哦
</span>表示是任意类型.
</p>

<p>
所以 <code>Just 1</code> 会得到一个 <code>Num a =&gt; Mabye a</code> 类型<label for="5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="5" class="margin-toggle"/><span class="sidenote">
意思就是 <code>Maybe a</code> 但是 <code>a</code> 的类型约束为 <code>Num</code>
</span>，
<code>Nothing</code> 也会得到一个 <code>Maybe a</code> 只不过 <code>a</code> 没有类型约束。
</p>

<p>
总之我们有了构造器可以构造出 <code>Maybe</code> 类型，而这个类型能做的事情，就要取决它实现了哪些 typeclass 的 instance 了。比如它可以是一个函子.
</p>
<pre class="code"><code><span style="color: #00008b;">instance</span> <span style="color: #36648b;">Functor</span> <span style="color: #36648b;">Maybe</span> <span style="color: #00008b;">where</span>
  fmap f (<span style="color: #36648b;">Just</span> a) <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Just</span> (f a)
  fmap f <span style="color: #36648b;">Nothing</span> <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Nothing</span>
</code></pre>

<pre class="code"><code><span style="color: #228b22;">implicit</span> <span style="color: #00008b;">val</span> <span style="color: #b8860b;">optionFunctor</span><span style="color: #00008b;">:</span> <span style="color: #36648b;">Functor</span>[<span style="color: #6b8e23;">Option</span>] <span style="color: #00008b;">=</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">Functor</span>[<span style="color: #6b8e23;">Option</span>] {
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">fmap</span>[<span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>](f<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">B</span>)<span style="color: #00008b;">:</span> <span style="color: #36648b;">Option</span>[<span style="color: #6b8e23;">A</span>] <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">Option</span>[<span style="color: #6b8e23;">B</span>] <span style="color: #00008b;">=</span> {
    <span style="color: #00008b;">case</span> <span style="color: #36648b;">Some</span>(<span style="color: #b8860b;">a</span>) <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">Some</span>(f(a))
    <span style="color: #00008b;">case</span> <span style="color: #6b8e23;">None</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">None</span>
  }
}
</code></pre>


<figure>
<img src="images/p2-maybe-functor.png" alt="p2-maybe-functor.png">

<figcaption><span class="figure-number">Figure 2: </span>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</figcaption>
</figure>

<p>
看清楚了, 虚线箭头即 <code>fmap</code>, 图上表示的 <code>fmap</code> 是 <code>(a -&gt; b) - - -&gt; (Maybe a -&gt; Maybe b)</code> 由于这里的箭头都是在 <code>-&gt;</code> 范畴, 所以 <code>- - -&gt;</code> 就是 <code>-&gt;</code> 了.
</p>

<p>
即: <code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>
</p>

<p>
不仅如此，还可以实现单子:
</p>
<pre class="code"><code><span style="color: #00008b;">instance</span> <span style="color: #36648b;">Monad</span> <span style="color: #36648b;">Maybe</span> <span style="color: #00008b;">where</span>
  return a <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Just</span> a
  (<span style="color: #36648b;">Just</span> a) <span style="color: #b8860b;">&gt;&gt;=</span> f <span style="color: #b8860b;">=</span> f a
  <span style="color: #36648b;">Nothing</span> <span style="color: #b8860b;">&gt;&gt;=</span> f <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Nothing</span>
</code></pre>

<pre class="code"><code><span style="color: #228b22;">implicit</span> <span style="color: #00008b;">val</span> <span style="color: #b8860b;">optionMonad</span><span style="color: #00008b;">:</span> <span style="color: #36648b;">Monad</span>[<span style="color: #6b8e23;">Option</span>] <span style="color: #00008b;">=</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">Monad</span>[<span style="color: #6b8e23;">Option</span>] {
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">flatMap</span>[<span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>](f<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">Option</span>[<span style="color: #6b8e23;">B</span>])<span style="color: #00008b;">:</span> <span style="color: #36648b;">Option</span>[<span style="color: #6b8e23;">A</span>] <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">Option</span>[<span style="color: #6b8e23;">B</span>] <span style="color: #00008b;">=</span> {
    <span style="color: #00008b;">case</span> <span style="color: #36648b;">Some</span>(<span style="color: #b8860b;">a</span>) <span style="color: #00008b;">=&gt;</span> f(a)
    <span style="color: #00008b;">case</span> <span style="color: #6b8e23;">None</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">None</span>
  }
}
</code></pre>


<figure>
<img src="images/p2-maybe-kleisli.png" alt="p2-maybe-kleisli.png">

<figcaption><span class="figure-number">Figure 3: </span>还记得第一部分提到的 Kleisli 范畴吗？</figcaption>
</figure>

<p>
Maybe 有用在于能合适的处理 <i><ruby>偏函数<rt> Partial Function</rt></ruby></i> 的返回值。
偏函数相对于 <i><ruby>全函数<rt> Total Function</rt></ruby></i> 是指只能对部分输入返回输出的函数。
</p>

<p>
比如一个取数组某一位上的值的函数，就是偏函数，因为假设你想取第4位的值，但不是所有数组长度都大于4，就会有获取不了的尴尬情况。
</p>
<pre class="code"><code>[1,2,3] <span style="color: #b8860b;">!!</span> 4
</code></pre>

<pre class="code"><code><span style="color: #6b8e23;">List</span>(<span style="color: #6b8e23;">1</span>,<span style="color: #6b8e23;">2</span>,<span style="color: #6b8e23;">3</span>).get(<span style="color: #6b8e23;">4</span>)
</code></pre>

<p>
如果使用 Maybe 把偏函数处理不了的输入都返回成 Nothing，这样结果依然保持 Maybe 类型，不影响后面的计算。
</p>
</div>
</div>

<div id="outline-container-org1c69b13" class="outline-3">
<h3 id="org1c69b13">Either 要么有要么有</h3>
<div class="outline-text-3" id="text-org1c69b13">
<p>
Either 的定义也很简单
</p>
<pre class="code"><code><span style="color: #00008b;">data</span> <span style="color: #36648b;">Either</span> a b <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Left</span> a <span style="color: #b8860b;">|</span> <span style="color: #36648b;">Right</span> b
</code></pre>

<pre class="code"><code><span style="color: #00008b;">trait</span> <span style="color: #36648b;">Either</span>[+<span style="color: #6b8e23;">A</span>, +<span style="color: #6b8e23;">B</span>]
<span style="color: #00008b;">case</span> <span style="color: #00008b;">class</span> <span style="color: #36648b;">Left</span>[+<span style="color: #6b8e23;">A</span>, +<span style="color: #6b8e23;">B</span>](a<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span>) <span style="color: #00008b;">extends</span> <span style="color: #36648b;">Either</span>[<span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>]
<span style="color: #00008b;">case</span> <span style="color: #00008b;">class</span> <span style="color: #36648b;">Right</span>[+<span style="color: #6b8e23;">A</span>, +<span style="color: #6b8e23;">B</span>](b<span style="color: #00008b;">:</span> <span style="color: #36648b;">B</span>) <span style="color: #00008b;">extends</span> <span style="color: #36648b;">Either</span>[<span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>]
</code></pre>
</div>


<div id="outline-container-org17bfad6" class="outline-4">
<h4 id="org17bfad6">Product &amp; Coproduct</h4>
<div class="outline-text-4" id="text-org17bfad6">
<p>
看过第一部分应该还能记得有一个东西叫 Duel，所以见到如果范畴上有 Coproduct 那么肯定在duel范畴上会有同样的东西叫 Product。
</p>

<p>
那么我们先来看看什么是 Coproduct
</p>


<figure>
<img src="images/p2-coproduct.png" alt="p2-coproduct.png">

<figcaption><span class="figure-number">Figure 4: </span>Coproduct</figcaption>
</figure>

<p>
像这样，能通过两个箭头到达同一个东西，就是 Coproduct。这里箭头 <code>Left</code> 能让 <code>a</code> 到 <code>Either a b</code> ， 箭头 <code>Right</code> 也能让 <code>b</code> 到达 <code>Either a b</code>
</p>

<p>
有意思的是还肯定存在一个 Coproduct 和 箭头，使得下图成立
<img src="images/p2-coproduct-law.png" alt="p2-coproduct-law.png">
</p>

<p>
箭头反过来，就是 Product, 比如 Tuple
</p>


<figure>
<img src="images/p2-product.png" alt="p2-product.png">

<figcaption><span class="figure-number">Figure 5: </span>Product</figcaption>
</figure>

<p>
Tuple 的 <code>fst</code> 箭头能让 <code>(a, b)</code> 到达 <code>a</code> 对象，而箭头 <code>snd</code> 能让其到达 <code>b</code> 对象。
</p>
</div>
</div>

<div id="outline-container-orge19ba66" class="outline-4">
<h4 id="orge19ba66">Either Monad</h4>
<div class="outline-text-4" id="text-orge19ba66">
<p>
确切的说，Either 不是 monad， <code>Either a</code> 才是。还记得 monad 的 class 定义吗？
</p>
<pre class="code"><code><span style="color: #00008b;">class</span> <span style="color: #36648b;">Endofunctor</span> m <span style="color: #b8860b;">=&gt;</span> <span style="color: #36648b;">Monad</span> m <span style="color: #00008b;">where</span>
  eta <span style="color: #b8860b;">::</span> a <span style="color: #b8860b;">-&gt;</span> (m a)
  mu <span style="color: #b8860b;">::</span> m m a <span style="color: #b8860b;">-&gt;</span> m a
</code></pre>
<p>
所以 m 必须是个 Endofunctor，也就是要满足 Functor
</p>
<pre class="code"><code><span style="color: #00008b;">class</span> <span style="color: #36648b;">Functor</span> t <span style="color: #00008b;">where</span>
  fmap <span style="color: #b8860b;">::</span> (a <span style="color: #b8860b;">-&gt;</span> b) <span style="color: #b8860b;">-&gt;</span> (t a <span style="color: #b8860b;">-&gt;</span> t b)
</code></pre>
<p>
t a 的 kind 是 *，所以 t 必须是 kind * -&gt; *
也就是说，m 必须是接收一个类型参数的类型构造器
</p>

<p>
而 Either 的 kind 是 * -&gt; * -&gt; *, Either a 才是 * -&gt; *
</p>

<p>
所以只能定义 Either a 的 Monad
</p>
<pre class="code"><code><span style="color: #00008b;">instance</span> <span style="color: #36648b;">Monad</span> (<span style="color: #36648b;">Either</span> a) <span style="color: #00008b;">where</span>
  <span style="color: #36648b;">Left</span>  l <span style="color: #b8860b;">&gt;&gt;=</span> <span style="color: #00008b;">_</span> <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Left</span> l
  <span style="color: #36648b;">Right</span> r <span style="color: #b8860b;">&gt;&gt;=</span> k <span style="color: #b8860b;">=</span> k r
</code></pre>

<p>
很明显的，&gt;&gt;= 任何函数到<ruby>左边<rt> Left</rt></ruby> 都不会改变，只有 &gt;&gt;= 右边才能产生新的计算。
</p>
</div>
</div>
</div>


<div id="outline-container-orgec20723" class="outline-3">
<h3 id="orgec20723">Reader 差一点就有</h3>
<div class="outline-text-3" id="text-orgec20723">
<p>
Reader 的作用是给一个计算喂数据。
</p>

<p>
在描述计算的时候，并不需要关心输入时什么，只需要 asks 就可以拿到输入值
</p>

<p>
而真正的输入，会在运行计算时给予。
</p>

<p>
跟 Identity 一样，我们用 newtype 来定义一个同构的 Reader 类型
</p>
<pre class="code"><code><span style="color: #00008b;">newtype</span> <span style="color: #36648b;">Reader</span> e a <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Reader</span> { runReader <span style="color: #b8860b;">::</span> (e <span style="color: #b8860b;">-&gt;</span> a) }
</code></pre>

<p>
其中
</p>
<ul class="org-ul">
<li>e 是输入</li>
<li>a 是结果</li>
<li>构造 Reader 类型需要确定 输入的类型 e 与输出的类型 a</li>
<li><code>runReader</code> 的类型是 <code>runReader:: (Reader e a) -&gt; (e -&gt; a)</code></li>
</ul>

<p>
也就是说在描述完一个 Reader 的计算后，使用 runReader 可以得到一个 e -&gt; a 的函数，使用这个函数，就可以接收输入，通过构造好的计算，算出结果 a 返回。
</p>

<p>
那么，让我们来实现 Reader 的 monad instance，就可以描述一个可以 ask 的计算了。
</p>

<pre class="code"><code><span style="color: #00008b;">instance</span> <span style="color: #36648b;">Monad</span> (<span style="color: #36648b;">Reader</span> e) <span style="color: #00008b;">where</span>
    return a         <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Reader</span> <span style="color: #b8860b;">$</span> <span style="color: #b8860b;">\</span><span style="color: #00008b;">_</span> <span style="color: #b8860b;">-&gt;</span> a
    (<span style="color: #36648b;">Reader</span> g) <span style="color: #b8860b;">&gt;&gt;=</span> f <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Reader</span> <span style="color: #b8860b;">$</span> <span style="color: #b8860b;">\</span>e <span style="color: #b8860b;">-&gt;</span> runReader (f (g e)) e
</code></pre>

<p>
跟Either一样，我们只能定义 Reader e 的 monad instance。
</p>

<p>
注意这里的
</p>
<ul class="org-ul">
<li>f 类型是 <code>(a -&gt; Reader e a)</code></li>
<li>g 其实就是是 destructure 出来的 runReader，也就是 e -&gt; a</li>
<li>所以 (g e) 返回 a</li>
<li>f (g e) 就是 <code>Reader e a</code></li>
<li>再 run 一把最后得到 a</li>
</ul>


<figure>
<img src="images/p2-reader-monad.png" alt="p2-reader-monad.png">

<figcaption><span class="figure-number">Figure 6: </span>f 函数，接收 a 返回一个 从 e 到 a 的 Reader</figcaption>
</figure>

<p>
让我们来看看如何使用 Reader
</p>
<pre class="code"><code><span style="color: #00008b;">import</span> <span style="color: #36648b;">Control.Monad.Reader</span>

<span style="color: #00008b;">data</span> <span style="color: #36648b;">Environment</span> <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Env</span>
  { fistName <span style="color: #b8860b;">::</span> <span style="color: #36648b;">String</span>
  , lastName <span style="color: #b8860b;">::</span> <span style="color: #36648b;">String</span>
  } <span style="color: #00008b;">deriving</span> (<span style="color: #36648b;">Show</span>)

<span style="color: #6a5acd;">helloworld</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">Reader</span> <span style="color: #36648b;">Environment</span> <span style="color: #36648b;">String</span>
<span style="color: #6a5acd;">helloworld</span> <span style="color: #b8860b;">=</span> <span style="color: #00008b;">do</span>
  f <span style="color: #b8860b;">&lt;-</span> asks firstName
  l <span style="color: #b8860b;">&lt;-</span> asks lastName
  return <span style="color: #8b0000;">"Hello "</span> <span style="color: #b8860b;">++</span> f <span style="color: #b8860b;">++</span> l

<span style="color: #6a5acd;">runHelloworld</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">String</span>
<span style="color: #6a5acd;">runHelloworld</span> <span style="color: #b8860b;">=</span> runReader helloworld <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Env</span> <span style="color: #8b0000;">"Jichao"</span> <span style="color: #8b0000;">"Ouyang"</span>
</code></pre>

<p>
这段代码很简单，helloworld 负责打招呼，也就是在名字前面加个 "Hello"，而跟谁打招呼，这个函数并不关心，而单纯的是向 Environment <ruby>问<rt>asks</rt></ruby> 就好。
</p>


<figure>
<img src="images/p2-reader-monad-ask.png" alt="p2-reader-monad-ask.png">

<figcaption><span class="figure-number">Figure 7: </span>asks 可以将 e -&gt; a 的函数变换成 Reader e a</figcaption>
</figure>

<p>
在运行时，可以提供给 Reader 的输入 Env fistname lastname。
<img src="images/p2-reader-monad-run.png" alt="p2-reader-monad-run.png">
</p>
</div>

<div id="outline-container-org59b28eb" class="outline-4">
<h4 id="org59b28eb">do notation</h4>
<div class="outline-text-4" id="text-org59b28eb">
<p>
这可能是你第一次见到 <code>do</code> 和 <code>&lt;-</code>. 如果不是，随意跳过这节。
</p>

<ul class="org-ul">
<li>do 中所有 &lt;- 的右边都是 <code>Reader Environment String</code> 类型</li>
<li>do 中的 return 返回类型也必须为  <code>Reader Environment String</code></li>
<li><code>asks firstName</code> 返回的是 <code>Reader Environment String</code> 类型， <code>&lt;-</code> 可以理解成吧 monad <code>Reader Environment</code> 的内容放到左边的 f, 所以 f 的类型是 String。</li>
</ul>

<p>
看起来像命令式的语句，其实只是 <code>&gt;&gt;=</code> 的语法糖，但是明显用do可读性要高很多。
</p>
<pre class="code"><code><span style="color: #6a5acd;">helloworld</span> <span style="color: #b8860b;">=</span> (asks firstName) <span style="color: #b8860b;">&gt;&gt;=</span>
  <span style="color: #b8860b;">\</span>f <span style="color: #b8860b;">-&gt;</span> (asks lastName) <span style="color: #b8860b;">&gt;&gt;=</span>
       <span style="color: #b8860b;">\</span>l <span style="color: #b8860b;">-&gt;</span> return <span style="color: #8b0000;">"Hello "</span> <span style="color: #b8860b;">++</span> f <span style="color: #b8860b;">++</span> l
</code></pre>
</div>
</div>
</div>


<div id="outline-container-org7505ce4" class="outline-3">
<h3 id="org7505ce4">Writer 光出进没有</h3>
<div class="outline-text-3" id="text-org7505ce4">
<p>
除了返回值，计算会需要产生一些额外的数据，比如 log
</p>

<p>
此时就需要一个 Writter，其返回值会是一个这样 <code>(result, log)</code> 的 tuple
</p>

<p>
限制是 log 的类型必须是个 <ruby>含幺半群<rt>monoid</rt></ruby>
</p>

<pre class="code"><code><span style="color: #6a5acd;">example</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">Writer</span> <span style="color: #36648b;">String</span> <span style="color: #36648b;">String</span>
<span style="color: #6a5acd;">example</span>  <span style="color: #b8860b;">=</span> <span style="color: #00008b;">do</span>
  tell <span style="color: #8b0000;">"How are you?"</span>
  tell <span style="color: #8b0000;">"I'm fine thank you, and you?"</span>
  return <span style="color: #8b0000;">"Hehe Da~"</span>

<span style="color: #6a5acd;">output</span> <span style="color: #b8860b;">::</span> (<span style="color: #36648b;">String</span>, <span style="color: #36648b;">String</span>)
<span style="color: #6a5acd;">output</span> <span style="color: #b8860b;">=</span> runWriter example
<span style="color: #8c8c8c; font-style: italic;">-- </span><span style="color: #8c8c8c; font-style: italic;">("Hehe Da~", "How are you?I'm fine thank you, and you?")</span>
</code></pre>

<p>
Writer 的定义更简单
</p>
<pre class="code"><code><span style="color: #00008b;">newtype</span> <span style="color: #36648b;">Writer</span> l a <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Writer</span> { runWriter <span style="color: #b8860b;">::</span> (a,l) }
</code></pre>
<p>
里面只是一个 tuple 而已
</p>
<ul class="org-ul">
<li>w 是 log</li>
<li>a 是 返回值</li>
</ul>

<p>
看看如何实现 Writer monad
</p>
<pre class="code"><code><span style="color: #00008b;">instance</span> (<span style="color: #36648b;">Monoid</span> w) <span style="color: #b8860b;">=&gt;</span> <span style="color: #36648b;">Monad</span> (<span style="color: #36648b;">Writer</span> w) <span style="color: #00008b;">where</span>
    return a             <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Writer</span> (a,mempty)
    (<span style="color: #36648b;">Writer</span> (a,l)) <span style="color: #b8860b;">&gt;&gt;=</span> f <span style="color: #b8860b;">=</span> <span style="color: #00008b;">let</span> (a',l') <span style="color: #b8860b;">=</span> runWriter <span style="color: #b8860b;">$</span> f a <span style="color: #00008b;">in</span>
                           <span style="color: #36648b;">Writer</span> (a',l <span style="color: #b8860b;">`mappend`</span> l')
</code></pre>

<ul class="org-ul">
<li>return 不会有任何 log，l 是 monoid 的 mempty</li>
<li>f 的类型为 <code>a -&gt; Writer l a</code></li>
<li><code>runWriter $ f a</code> 返回 <code>(a, l)</code></li>
</ul>


<figure>
<img src="images/p2-writer-monad.png" alt="p2-writer-monad.png">

</figure>

<p>
所以在 &gt;&gt;= 时，我们先把 f a 返回的 Writer run了，然后把两次 log <code>mappend</code> 起来。
<img src="images/p2-writer-monad-bind.png" alt="p2-writer-monad-bind.png">
</p>
</div>
</div>

<div id="outline-container-org30a3b76" class="outline-3">
<h3 id="org30a3b76">State 变化会有</h3>
<div class="outline-text-3" id="text-org30a3b76">
<p>
跟名字就看得出来 State monad 是为了处理状态。虽然函数式编程不应该有状态，不然会引用透明性。但是，state monad并不是在计算过程中修改状态，而是通过描述这种变化，然后需要时在运行返回最终结果。这一点跟 Reader 和 Writer 这两个看起来是副作用的 IO 是一样的。
</p>

<p>
先看下 State 类型的定义
</p>
<pre class="code"><code><span style="color: #00008b;">newtype</span> <span style="color: #36648b;">State</span> s a <span style="color: #b8860b;">=</span> <span style="color: #36648b;">State</span> { runState <span style="color: #b8860b;">::</span> s <span style="color: #b8860b;">-&gt;</span> (a, s) }
</code></pre>

<p>
可以看到 State 只包含一个 从旧状态 s 到新状态 s 和返回值 a 的 Tuple 的函数。
</p>

<p>
通过实现 Monad，State 就可以实现命令式编程中的变量的功能。
</p>
<pre class="code"><code><span style="color: #00008b;">instance</span> <span style="color: #36648b;">Monad</span> (<span style="color: #36648b;">State</span> s) <span style="color: #00008b;">where</span>
  return a        <span style="color: #b8860b;">=</span> <span style="color: #36648b;">State</span> <span style="color: #b8860b;">$</span> <span style="color: #b8860b;">\</span>s <span style="color: #b8860b;">-&gt;</span> (a,s)
  (<span style="color: #36648b;">State</span> x) <span style="color: #b8860b;">&gt;&gt;=</span> f <span style="color: #b8860b;">=</span> <span style="color: #36648b;">State</span> <span style="color: #b8860b;">$</span> <span style="color: #b8860b;">\</span>s <span style="color: #b8860b;">-&gt;</span> <span style="color: #00008b;">let</span> (v,s') <span style="color: #b8860b;">=</span> x s <span style="color: #00008b;">in</span>
                                 runState (f v) s'
</code></pre>
<p>
return 很简单，就不用解释了。
</p>


<figure>
<img src="images/p2-state-monad.png" alt="p2-state-monad.png">

</figure>

<p>
x 类型是 <code>s -&gt; (a, s)</code> ,所以 x s 之后会返回 结果和状态。也就是运行当前 State，把结果 v 传给函数 f，返回的 State 再接着上次状态运行。
</p>


<figure>
<img src="images/p2-state-monad-bind.png" alt="p2-state-monad-bind.png">

<figcaption><span class="figure-number">Figure 10: </span>State x &gt;&gt;= f 后runState的数据流（啊啊啊，画歪了，感觉需要脉动一下）</figcaption>
</figure>

<p>
使用起来也很方便，State 提供 <code>get</code> <code>put</code> <code>moidfy</code> 三个方便的函数可以生成修改状态的State monad
</p>

<pre class="code"><code><span style="color: #00008b;">import</span> <span style="color: #36648b;">Control.Monad.Trans.State.Strict</span>
<span style="color: #6a5acd;">test</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">State</span> <span style="color: #36648b;">Int</span> <span style="color: #36648b;">Int</span>
<span style="color: #6a5acd;">test</span> <span style="color: #b8860b;">=</span> <span style="color: #00008b;">do</span>
  a <span style="color: #b8860b;">&lt;-</span> get
  modify (<span style="color: #b8860b;">+</span>1)
  b <span style="color: #b8860b;">&lt;-</span> get
  return (a <span style="color: #b8860b;">+</span> b)

<span style="color: #6a5acd;">main</span> <span style="color: #b8860b;">=</span> print <span style="color: #b8860b;">$</span> show <span style="color: #b8860b;">$</span> runState test 3
<span style="color: #8c8c8c; font-style: italic;">-- </span><span style="color: #8c8c8c; font-style: italic;">(7, 4)</span>
</code></pre>
</div>
</div>


<div id="outline-container-org105da09" class="outline-3">
<h3 id="org105da09">Validation 检查检查</h3>
<div class="outline-text-3" id="text-org105da09">
<p>
如果你有注意到，前面的 Either 可以用在处理错误和正确的路径分支，但是问题是错误只发生一次。
</p>

<div class="epigraph"><blockquote>
<p>
Validation 没有在标准库中，但是我觉得好有用啊，你可以在 ekmett 的 <a href="https://github.com/ekmett/either">github</a> 中找到源码
</p>

</blockquote></div>

<p>
想象一下这种场景，用户提交一个表单，我们需要对每一个field进行验证，如果有错误，需要把错误的哪几个field的错误消息返回。显然如果使用 Either 来做，只能返回第一个field的错误信息，后面的计算都会被跳过。
</p>

<p>
针对这种情况， Validation 更适合
</p>
<pre class="code"><code><span style="color: #00008b;">data</span> <span style="color: #36648b;">Validation</span> e a <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Failure</span> e <span style="color: #b8860b;">|</span> <span style="color: #36648b;">Success</span> a
</code></pre>

<p>
ADT定义看起来跟 Either 是一样的，不同的是 <ruby>左边<rt>Left</rt></ruby> Failure 是 <ruby>含幺半群<rt>Monoid</rt></ruby>
</p>
</div>

<div id="outline-container-org9f94784" class="outline-4">
<h4 id="org9f94784"><ruby>含幺半群<rt>Monoid</rt></ruby></h4>
<div class="outline-text-4" id="text-org9f94784">
<p>
monoid 首先得是 <ruby>半群<rt>Semigroup</rt></ruby> ，然后再 含幺。
</p>
<pre class="code"><code><span style="color: #00008b;">class</span> <span style="color: #36648b;">Semigroup</span> a <span style="color: #00008b;">where</span>
  (<span style="color: #b8860b;">&lt;&gt;</span>) <span style="color: #b8860b;">::</span> a <span style="color: #b8860b;">-&gt;</span> a <span style="color: #b8860b;">-&gt;</span> a
  (<span style="color: #b8860b;">&lt;&gt;</span>) <span style="color: #b8860b;">=</span> mappend
</code></pre>

<p>
半群非常简单，只要是可以 <code>&lt;&gt;</code> (mappend) 的类型就是了。
</p>

<p>
含幺只需要有一个 <code>mempty</code> 的 幺元就行
</p>
<pre class="code"><code><span style="color: #00008b;">class</span> <span style="color: #36648b;">Monoid</span> a <span style="color: #00008b;">where</span>
  mempty  <span style="color: #b8860b;">::</span> a
  mappend <span style="color: #b8860b;">::</span> a <span style="color: #b8860b;">-&gt;</span> a <span style="color: #b8860b;">-&gt;</span> a
</code></pre>

<p>
比如 List 就是 Semigroup
</p>
<pre class="code"><code><span style="color: #00008b;">instance</span> <span style="color: #36648b;">Semigroup</span> [a] <span style="color: #00008b;">where</span>
  (<span style="color: #b8860b;">&lt;&gt;</span>) <span style="color: #b8860b;">=</span> (<span style="color: #b8860b;">++</span>)
</code></pre>
<p>
也是 Monoid
</p>
<pre class="code"><code><span style="color: #00008b;">instance</span> <span style="color: #36648b;">Monoid</span> [a] <span style="color: #00008b;">where</span>
  mempty  <span style="color: #b8860b;">=</span> <span style="color: #36648b;">[]</span>
  mappend <span style="color: #b8860b;">=</span> (<span style="color: #b8860b;">++</span>)
</code></pre>

<p>
Monoid 的 <code>&lt;&gt;</code> 满足：
</p>
<ul class="org-ul">
<li>mempty &lt;&gt; a = a</li>
<li>a &lt;&gt; b &lt;&gt; c = a &lt;&gt; (b &lt;&gt; c)</li>
</ul>
</div>
</div>
<div id="outline-container-orgd0bcad5" class="outline-4">
<h4 id="orgd0bcad5">回到 Validation</h4>
<div class="outline-text-4" id="text-orgd0bcad5">
<p>
现在让 Failure e 满足 Monoid，就可以 <code>mappend</code> 错误信息了。
</p>
<pre class="code"><code><span style="color: #00008b;">instance</span> <span style="color: #36648b;">Semigroup</span> e <span style="color: #b8860b;">=&gt;</span> <span style="color: #36648b;">Semigroup</span> (<span style="color: #36648b;">Validation</span> e a) <span style="color: #00008b;">where</span>
  <span style="color: #36648b;">Failure</span> e1 <span style="color: #b8860b;">&lt;&gt;</span> <span style="color: #36648b;">Failure</span> e2 <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Failure</span> (e1 <span style="color: #b8860b;">&lt;&gt;</span> e2)
  <span style="color: #36648b;">Failure</span> <span style="color: #00008b;">_</span>  <span style="color: #b8860b;">&lt;&gt;</span> <span style="color: #36648b;">Success</span> a2 <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Success</span> a2
  <span style="color: #36648b;">Success</span> a1 <span style="color: #b8860b;">&lt;&gt;</span> <span style="color: #36648b;">Failure</span> <span style="color: #00008b;">_</span>  <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Success</span> a1
  <span style="color: #36648b;">Success</span> a1 <span style="color: #b8860b;">&lt;&gt;</span> <span style="color: #36648b;">Success</span> <span style="color: #00008b;">_</span>  <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Success</span> a1
</code></pre>

<p>
下来，我们用一个简单的例子来看看 Validation 与 Either 有什么区别。
</p>

<p>
假设我们有一个form，需要输入姓名与电话，验证需要姓名是非空而电话是11位数字。
</p>

<p>
首先，我们需要有一个函数去创建包含姓名和电话的model
</p>
<pre class="code"><code><span style="color: #00008b;">data</span> <span style="color: #36648b;">Info</span> <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Info</span> {name<span style="color: #36648b;">:</span> <span style="color: #36648b;">String</span>, phone<span style="color: #36648b;">:</span> <span style="color: #36648b;">String</span>} <span style="color: #00008b;">deriving</span> <span style="color: #36648b;">Show</span>
</code></pre>

<p>
然后我们需要验证函数
</p>
<pre class="code"><code><span style="color: #6a5acd;">notEmpty</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">String</span> <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">String</span> <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">Validation</span> [<span style="color: #36648b;">String</span>] <span style="color: #36648b;">String</span>
<span style="color: #6a5acd;">notEmpty</span> desc <span style="color: #8b0000;">""</span> <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Failure</span> [desc <span style="color: #b8860b;">&lt;&gt;</span> <span style="color: #8b0000;">" cannot be empty!"</span>]
<span style="color: #6a5acd;">notEmpty</span> <span style="color: #00008b;">_</span> field <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Success</span> field
</code></pre>
<p>
notEmpty 检查字符是否为空，如果是空返回 Failure 包含错误信息，若是非空则返回 Success 包含 field
</p>

<p>
同样的可以创建 11位数字的验证函数
</p>
<pre class="code"><code><span style="color: #6a5acd;">phoneNumberLength</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">String</span> <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">String</span> <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">Validation</span> [<span style="color: #36648b;">String</span>] <span style="color: #36648b;">String</span>
<span style="color: #6a5acd;">phoneNumberLength</span> desc field <span style="color: #b8860b;">|</span> (length field) <span style="color: #b8860b;">==</span> 11 <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Success</span> field
                             <span style="color: #b8860b;">|</span> otherwise <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Failure</span> [desc <span style="color: #b8860b;">&lt;&gt;</span> <span style="color: #8b0000;">"'s length is not 11"</span>]
</code></pre>
<p>
实现 Validation 的 Applicative instance，这样就可以把函数调用lift成带有验证的 Applicative
</p>
<pre class="code"><code><span style="color: #00008b;">instance</span> <span style="color: #36648b;">Semigroup</span> e <span style="color: #b8860b;">=&gt;</span> <span style="color: #36648b;">Applicative</span> (<span style="color: #36648b;">Validation</span> e) <span style="color: #00008b;">where</span>
  pure <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Success</span>
  <span style="color: #36648b;">Failure</span> e1 <span style="color: #b8860b;">&lt;*&gt;</span> <span style="color: #36648b;">Failure</span> e2 <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Failure</span> e1 <span style="color: #b8860b;">&lt;&gt;</span> <span style="color: #36648b;">Failure</span> e2
  <span style="color: #36648b;">Failure</span> e1 <span style="color: #b8860b;">&lt;*&gt;</span> <span style="color: #36648b;">Success</span> <span style="color: #00008b;">_</span>  <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Failure</span> e1
  <span style="color: #36648b;">Success</span> <span style="color: #00008b;">_</span>  <span style="color: #b8860b;">&lt;*&gt;</span> <span style="color: #36648b;">Failure</span> e2 <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Failure</span> e2
  <span style="color: #36648b;">Success</span> f <span style="color: #b8860b;">&lt;*&gt;</span> <span style="color: #36648b;">Success</span> a <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Success</span> (f a)
</code></pre>
<ul class="org-ul">
<li>失败应用到失败会 concat 起来</li>
<li>失败跟应用或被成功应用还是失败</li>
<li>只有成功应用到成功才能成功，这很符合验证的逻辑，一旦验证中发生任何错误，都应该返回失败。</li>
</ul>

<pre class="code"><code><span style="color: #6a5acd;">createInfo</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">String</span> <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">String</span> <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">Validation</span> [<span style="color: #36648b;">String</span>] <span style="color: #36648b;">Info</span>
<span style="color: #6a5acd;">createInfo</span> name phone <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Info</span> <span style="color: #b8860b;">&lt;$&gt;</span> notEmpty <span style="color: #8b0000;">"name"</span> name <span style="color: #b8860b;">&lt;*&gt;</span> phoneNumberLength <span style="color: #8b0000;">"phone"</span> phone
</code></pre>

<p>
现在我们就可以使用带validation的 createInfo 来安全的创建 Info 了
</p>

<pre class="code"><code><span style="color: #6a5acd;">createInfo</span> <span style="color: #8b0000;">"jichao"</span> <span style="color: #8b0000;">"12345678910"</span> <span style="color: #8c8c8c; font-style: italic;">-- </span><span style="color: #8c8c8c; font-style: italic;">Success Info "jichao" "12345678910"</span>
<span style="color: #6a5acd;">createInfo</span> <span style="color: #8b0000;">""</span> <span style="color: #8b0000;">"123"</span> <span style="color: #8c8c8c; font-style: italic;">-- </span><span style="color: #8c8c8c; font-style: italic;">Failure ["name cannot be empty!", "phone's length is not 11"]</span>
</code></pre>
</div>
</div>
</div>

<div id="outline-container-orgbfc4526" class="outline-3">
<h3 id="orgbfc4526">Cont 接下来有</h3>
<div class="outline-text-3" id="text-orgbfc4526">
<p>
Cont 是 <ruby>Continuation Passing Style<rt>CPS</rt></ruby> 的 monad，也就是说，它是包含 cps 计算 monad。
</p>

<p>
先看一下什么是 CPS，比如有一个加法
</p>
<pre class="code"><code><span style="color: #6a5acd;">add</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">Int</span> <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">Int</span> <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">Int</span>
<span style="color: #6a5acd;">add</span> <span style="color: #b8860b;">=</span> (<span style="color: #b8860b;">+</span>)
</code></pre>

<p>
但是如果你想在算法加法后，能够继续进行一个其他的计算，那么就可以写一个 cps版本的加法
</p>
<pre class="code"><code><span style="color: #6a5acd;">addCPS</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">Int</span> <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">Int</span> <span style="color: #b8860b;">-&gt;</span> (<span style="color: #36648b;">Int</span> <span style="color: #b8860b;">-&gt;</span> r) <span style="color: #b8860b;">-&gt;</span> r
<span style="color: #6a5acd;">addCPS</span> a b k <span style="color: #b8860b;">=</span> k (a <span style="color: #b8860b;">+</span> b)
</code></pre>

<p>
非常简单，现在我们可以看看为什么需要一个 Cont monad 来包住 CPS 计算，首先，来看 ADT 定义
</p>
<pre class="code"><code><span style="color: #00008b;">newtype</span> <span style="color: #36648b;">Cont</span> r a <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Cont</span> { runCont <span style="color: #b8860b;">::</span> ((a <span style="color: #b8860b;">-&gt;</span> r) <span style="color: #b8860b;">-&gt;</span> r) }
</code></pre>

<p>
又是一个同构的类型，Cont 构造器只需要一个 runCount，也就是让他能继续计算的一个函数。
</p>

<p>
完了之后来把之前的 addCPS 改成 Cont
</p>
<pre class="code"><code><span style="color: #6a5acd;">add</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">Int</span> <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">Int</span> <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">Cont</span> k <span style="color: #36648b;">Int</span>
<span style="color: #6a5acd;">add</span> a b <span style="color: #b8860b;">=</span> return (a <span style="color: #b8860b;">+</span> b)
</code></pre>

<p>
注意到 addCPS 接收到 a 和 b 之后返回的类型是 <code>(Int -&gt; r) -&gt; r</code> ，而 Cont 版本的 <code>add</code> 返回 <code>Cont k Int</code>
</p>

<p>
明显构造 <code>Cont k Int</code> 也正是需要 <code>(Int -&gt; r) -&gt; r</code> ，所以 Cont 就是算了 k 的抽象了。
</p>

<pre class="code"><code><span style="color: #00008b;">instance</span> <span style="color: #36648b;">Monad</span> (<span style="color: #36648b;">Cont</span> r) <span style="color: #00008b;">where</span>
    return a <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Cont</span> (<span style="color: #b8860b;">$</span> a)
    m <span style="color: #b8860b;">&gt;&gt;=</span> k  <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Cont</span> <span style="color: #b8860b;">$</span> <span style="color: #b8860b;">\</span>c <span style="color: #b8860b;">-&gt;</span> runCont m <span style="color: #b8860b;">$</span> <span style="color: #b8860b;">\</span>a <span style="color: #b8860b;">-&gt;</span> runCont (k a) c
</code></pre>

<p>
<code>($ a)</code> 比较有意思, 我们都知道 <code>f $ g a</code> 其实就是 <code>f(g a)</code>, 所以 <code>$</code> 其实就是一个 apply 左边的函数到右边表达式的中缀函数, 如果写成前缀则是
<code>($ (g a) f)</code>. 是反的是因为 <code>$</code> 是有结合, 需要右边表达式先求值, 所以只给一个 a 就相当于 <code>($ a) = \f -&gt; f a</code>
</p>

<p>
回到 Monad Cont&#x2026;
</p>
</div>
</div>

<div id="outline-container-org05e7f17" class="outline-3">
<h3 id="org05e7f17">Summary</h3>
<div class="outline-text-3" id="text-org05e7f17">
<p>
第二部分食用部分也讲完了， 不知是否以及大致了解了monad的尿性各种基本玩法呢？通过这些常用的基本的 monad instance，解决命令式编程中的一些简单问题应该是够了。
</p>

<p>
不过，接下来还有更变态的猫，就先叫她 <del>搞基</del> 猫呢好了。
</p>

<ul class="org-ul">
<li>👉 <a href="./part3.html">第三部分：<ruby>搞基猫呢<rt> Advanced Monads</rt></ruby></a></li>
</ul>

<p>
当然我又还没空全部写完，如果还有很多人<ruby>预定<rt>只要998</rt></ruby> Gumroad 上的  <script src="https://gumroad.com/js/gumroad.js"></script><a class="gumroad-button" href="https://gum.co/grokking-monad" target="_blank">Grokking Monad</a> 电子书的话，我可能会稍微写得快一些。毕竟，写了也没人感兴趣也怪浪费时间的。不过，我猜也没几个人能看到这一行，就当是我又自言自语吧，怎么又突然觉得自己好分裂，诶~，为什么我要说又？
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
从来没见过有人给这些数据类型按过中文名字, 不然我来, 这样也更好的体会这些数据类型的意图.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
见 <a href="part1.html#orgf0aed70">第一部分 伴随函子</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
也就是 Kind * -&gt; *, 因为它非常的 nice, 一定要等到 a 才出类型
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
一定要记得小写哦
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
意思就是 <code>Maybe a</code> 但是 <code>a</code> 的类型约束为 <code>Num</code>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<footer>
  <p>Author: 欧阳继超
    <a class="github-button" href="https://github.com/sponsors/jcouyang" data-icon="octicon-heart" aria-label="Sponsor @jcouyang on GitHub">Sponsor</a>
    <a aria-label="Follow @jcouyang on GitHub" data-count-aria-label="# followers on GitHub" data-count-api="/users/jcouyang#followers" data-count-href="/jcouyang/followers" href="https://github.com/jcouyang" class="github-button">Follow</a>
  </p>
  <p>Created: 2017-02-10 Fri 00:00</p>
  <p>Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.2 (<a href="https://orgmode.org">Org</a> mode 9.2.6) &#215; <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.
  <input type="swiftype" class="st-default-search-input" placeholder="Search"/>
  <a class="gumroad-button" href="https://gum.co/grokking-monad?wanted=true" target="_blank" data-gumroad-single-product="true">范畴论装逼指南，请自觉排队装逼</a>
  <div id="danmaku-comments"></div>
  <div id="disqus_thread"></div>
</footer>
</div>
</body>
</html>
