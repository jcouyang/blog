<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2021-01-31 Sun 02:34 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>范畴论完全装逼手册 / Grokking Monad</title>
<meta name="generator" content="Org mode">
<meta name="author" content="欧阳继超">
<meta name="description" content="卷三 搞基猫呢"
>
<link rel="icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/toc.css"/>
<link rel="stylesheet" href="/style/tufte.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="https://feeds.oyanglul.us/JichaoOuyangsBlog"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJRFJGX"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<header>
    <a accesskey="h" href="/index.html"> HOME </a> |
    <a href="#" id="edit-in-github">EDIT</a> |
    <a href="https://feeds.oyanglul.us/JichaoOuyangsBlog">RSS</a> |
    <a href="https://blog.oyanglul.us/theindex">INDEX</a> |
    <a accesskey="H" href="/jichao.ouyang.html">ABOUT</a> |
    <a href="https://github.com/jcouyang/blog">GITHUB</a>
</header>
</div>
<div id="content">
<header>
<h1 class="title">范畴论完全装逼手册 / Grokking Monad</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9d9ec5e">第三部分:<ruby>搞基猫呢<rt>Advanced Monads</rt></ruby></a>
<ul>
<li><a href="#org94a258b">RWS</a></li>
<li><a href="#org2d76bbe">Monad Transform</a>
<ul>
<li><a href="#orga95d62b">ReaderT</a></li>
</ul>
</li>
<li><a href="#org4cd7db0">Alternative</a></li>
<li><a href="#org3847a38">MonadPlus</a></li>
<li><a href="#orgde953a0">ST Monad</a></li>
<li><a href="#orgd7125c4">Free Monad</a>
<ul>
<li><a href="#org39f2302">Free</a></li>
<li><a href="#org4526f48">Coyoneda</a></li>
<li><a href="#org3872010">Free Functor</a></li>
<li><a href="#orgf41b63e">Interpreter</a></li>
</ul>
</li>
<li><a href="#orgdaccf82"><span class="todo TODO">TODO</span> Free Monoid</a></li>
<li><a href="#org12cde21"><span class="todo TODO">TODO</span> Eff</a></li>
<li><a href="#orgffa68b7"><span class="todo TODO">TODO</span> Comonad</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<ul class="org-ul">
<li><a href="./part1.html">第一部分：猫论</a></li>
<li><a href="./part2.html">第二部分：食用猫呢</a></li>
<li><a href="./part3.html"><b>第三部分：搞基猫呢</b></a> 👈</li>
</ul>

<div id="outline-container-org9d9ec5e" class="outline-2">
<h2 id="org9d9ec5e">第三部分:<ruby>搞基猫呢<rt>Advanced Monads</rt></ruby></h2>
<div class="outline-text-2" id="text-org9d9ec5e">
<p>
第二部分介绍了一些实用的monad instances，这些 monad 都通过同样的抽象方式，解决了分离计算与副作用的工作。
</p>

<p>
通过它们可以解决大多数的基本问题，但是正对于复杂业务逻辑，我们可能还需要一些更高阶的 monad 或者 pattern。
</p>

<p>
当有了第一部分的理论基础和第二部分的实践，这部分要介绍的猫呢其实并不是很搞基。通过这一部分介绍的搞基猫呢，
我们还可以像 IO monad 一样，通过 free 或者 Eff 自定义自己的计算，和可能带副作用的解释器。
</p>
</div>

<div id="outline-container-org94a258b" class="outline-3">
<h3 id="org94a258b">RWS</h3>
<div class="outline-text-3" id="text-org94a258b">
<p>
RWS 是缩写 Reader Writer State monad, 所以明显是三个monad的合体。如果已经忘记 Reader Writer 或者 State，请到第二部分复习一下。
</p>

<p>
一旦把三个 monad 合体，意味着可以在同一个 monad 使用三个 monad 的方法，比如，可以同时使用 Reader 的 ask, State 的 get, put, 和 Writer 的 tell
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">readWriteState</span> <span style="color: #b8860b;">=</span> <span style="color: #00008b;">do</span>
  e <span style="color: #b8860b;">&lt;-</span> ask
  a <span style="color: #b8860b;">&lt;-</span> get
  <span style="color: #00008b;">let</span> res <span style="color: #b8860b;">=</span> a <span style="color: #b8860b;">+</span> e
  put res
  tell [res]
  return res
<span style="color: #6a5acd;">runRWS</span> readWriteState 1 2
<span style="color: #8c8c8c; font-style: italic;">-- </span><span style="color: #8c8c8c; font-style: italic;">(3 3 [3])</span>
</pre>
</div>

<p>
注意到跟 Reader 和 State 一样，run的时候输入初始值
</p>

<p>
其中 1 为 Reader 的值，2 为 State 的初始状态.
</p>
</div>
</div>

<div id="outline-container-org2d76bbe" class="outline-3">
<h3 id="org2d76bbe">Monad Transform</h3>
<div class="outline-text-3" id="text-org2d76bbe">
<p>
你会发现 RWS 一起用挺好的，能读能写能打 log，但是已经固定好搭配了，只能是 RWS ，如果我还想加入其它的 Monad，该怎么办呢？
</p>

<p>
这时候，简单的解决方案是加个 T，比如对于 Reader，我们有 ReaderT，RWS，也有对应的 RWST。其中 T 代表 Transform。
</p>
</div>

<div id="outline-container-orga95d62b" class="outline-4">
<h4 id="orga95d62b">ReaderT</h4>
<div class="outline-text-4" id="text-orga95d62b">
<p>
让我来通过简单的 ReaderT 来解释到底什么是 T 吧, 首先跟 Reader 一样我们有个 runReaderT
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">newtype</span> <span style="color: #36648b;">ReaderT</span> e m a <span style="color: #b8860b;">=</span> <span style="color: #36648b;">ReaderT</span> { runReaderT <span style="color: #b8860b;">::</span> e <span style="color: #b8860b;">-&gt;</span> m a }
</pre>
</div>

<p>
比较一下 Reader 的定义
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">newtype</span> <span style="color: #36648b;">Reader</span> e a <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Reader</span> { runReader <span style="color: #b8860b;">::</span> (e <span style="color: #b8860b;">-&gt;</span> a) }
</pre>
</div>

<p>
有没有发现多了一个 m, 也就是说, <code>runReader e</code> 会返回 a, 但是 <code>runReaderT e</code> 则会返回 <code>m a</code>
</p>


<figure>
<img src="images/p3-ReaderT.png" alt="p3-ReaderT.png">

</figure>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">instance</span> (<span style="color: #36648b;">Monad</span> m) <span style="color: #b8860b;">=&gt;</span> <span style="color: #36648b;">Monad</span> (<span style="color: #36648b;">ReaderT</span> e m) <span style="color: #00008b;">where</span>
    return   <span style="color: #b8860b;">=</span> lift <span style="color: #b8860b;">.</span> return
    r <span style="color: #b8860b;">&gt;&gt;=</span> k  <span style="color: #b8860b;">=</span> <span style="color: #36648b;">ReaderT</span> <span style="color: #b8860b;">$</span> <span style="color: #b8860b;">\</span> e <span style="color: #b8860b;">-&gt;</span> <span style="color: #00008b;">do</span>
        a <span style="color: #b8860b;">&lt;-</span> runReaderT r e
        runReaderT (k a) e
</pre>
</div>

<p>
再看看 monad 的实现, 也是一样的, 先 run 一下 <code>r e</code> 得到结果 <code>a</code>, 应用函数 <code>k</code> 到 <code>a</code>, 再 run 一把.
</p>


<p>
问题是, 这里的 <code>return</code> 里面的 <code>lift</code> 是哪来的?
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">instance</span> <span style="color: #36648b;">MonadTrans</span> (<span style="color: #36648b;">ReaderT</span> e) <span style="color: #00008b;">where</span>
  lift m <span style="color: #b8860b;">=</span> <span style="color: #36648b;">ReaderT</span> (const m)
</pre>
</div>


<figure>
<img src="images/p3-MonadTrans-ReaderT-e-m.png" alt="p3-MonadTrans-ReaderT-e-m.png">

</figure>

<p>
这个函数 <code>lift</code> 被定义在 MonadTrans 的实例中, 简单的把 m 放到 ReaderT 结果中.
</p>

<p>
例如, <code>lift (Just 1)</code> 会得到 ReaderT, 其中 e 随意, m 为 Maybe Num
</p>

<p>
重点需要体会的是, Reader 可以越过 Maybe 直接操作到 Num, 完了再包回来.
</p>

<p>
有了 ReaderT, 搭配 Id Monad 就很容易创建出来 Reader Monad
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">type</span> <span style="color: #36648b;">Reader</span> r a<span style="color: #b8860b;">=</span> <span style="color: #36648b;">ReaderT</span> r <span style="color: #36648b;">Identity</span> a
</pre>
</div>

<p>
越过 Id read 到 Id 内部, 完了再用 Id 包回来, 不就是 Reader 了么
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #36648b;">ReaderT</span> { runReaderT <span style="color: #b8860b;">::</span> r <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">Identity</span> a }
<span style="color: #8c8c8c; font-style: italic;">-- </span><span style="color: #8c8c8c; font-style: italic;">Identity a is a</span>
<span style="color: #36648b;">ReaderT</span> { runReaderT <span style="color: #b8860b;">::</span> r <span style="color: #b8860b;">-&gt;</span> a }
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org4cd7db0" class="outline-3">
<h3 id="org4cd7db0">Alternative</h3>
<div class="outline-text-3" id="text-org4cd7db0">
<p>
这个 typeclass 提供 <code>&lt;|&gt;</code> 函数, 表示要么计算左边, 要么计算右边
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">class</span> <span style="color: #36648b;">Applicative</span> f <span style="color: #b8860b;">=&gt;</span> <span style="color: #36648b;">Alternative</span> f <span style="color: #00008b;">where</span>
    empty <span style="color: #b8860b;">::</span> f a
    (<span style="color: #b8860b;">&lt;|&gt;</span>) <span style="color: #b8860b;">::</span> f a <span style="color: #b8860b;">-&gt;</span> f a <span style="color: #b8860b;">-&gt;</span> f a
</pre>
</div>


<figure>
<img src="images/p3-Alternative.png" alt="p3-Alternative.png">

</figure>

<p>
其实就是 Applicative 的 <code>或</code>
</p>

<p>
比如:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #36648b;">Just</span> 1 <span style="color: #b8860b;">&lt;|&gt;</span> <span style="color: #36648b;">Just</span> 2 <span style="color: #8c8c8c; font-style: italic;">-- </span><span style="color: #8c8c8c; font-style: italic;">Just 1</span>
<span style="color: #36648b;">Just</span> 1 <span style="color: #b8860b;">&lt;|&gt;</span> <span style="color: #36648b;">Nothing</span> <span style="color: #8c8c8c; font-style: italic;">-- </span><span style="color: #8c8c8c; font-style: italic;">Just 1</span>
<span style="color: #36648b;">Nothing</span> <span style="color: #6a5acd;">&lt;|&gt;</span> <span style="color: #36648b;">Just</span> 1 <span style="color: #8c8c8c; font-style: italic;">-- </span><span style="color: #8c8c8c; font-style: italic;">Just 1</span>
<span style="color: #36648b;">Nothing</span> <span style="color: #6a5acd;">&lt;|&gt;</span> <span style="color: #36648b;">Nothing</span> <span style="color: #8c8c8c; font-style: italic;">-- </span><span style="color: #8c8c8c; font-style: italic;">Nothing</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org3847a38" class="outline-3">
<h3 id="org3847a38">MonadPlus</h3>
<div class="outline-text-3" id="text-org3847a38">
<p>
这跟 Alternative 是一毛一样的, 只是限制的更细, 必须是 Monad才行
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">class</span> (<span style="color: #36648b;">Alternative</span> m, <span style="color: #36648b;">Monad</span> m) <span style="color: #b8860b;">=&gt;</span> <span style="color: #36648b;">MonadPlus</span> m <span style="color: #00008b;">where</span>
   mzero <span style="color: #b8860b;">::</span> m a
   mzero <span style="color: #b8860b;">=</span> empty
   mplus <span style="color: #b8860b;">::</span> m a <span style="color: #b8860b;">-&gt;</span> m a <span style="color: #b8860b;">-&gt;</span> m a
   mplus <span style="color: #b8860b;">=</span> (<span style="color: #b8860b;">&lt;|&gt;</span>)
</pre>
</div>

<p>
看, 实现中直接就调用了 Alternative 的 <code>empty</code> 和 <code>&lt;|&gt;</code>
</p>
</div>
</div>

<div id="outline-container-orgde953a0" class="outline-3">
<h3 id="orgde953a0">ST Monad</h3>
<div class="outline-text-3" id="text-orgde953a0">
<p>
ST Monad 跟 State Monad 的功能有些像, 不过更厉害的是, 他不是 immutable 的, 而是 "immutable" 的在原地做修改. 改完之后 runST 又然他回到了 immutable 的 Haskell 世界.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">sumST</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">Num</span> a <span style="color: #b8860b;">=&gt;</span> [a] <span style="color: #b8860b;">-&gt;</span> a
<span style="color: #6a5acd;">sumST</span> xs <span style="color: #b8860b;">=</span> runST <span style="color: #b8860b;">$</span> <span style="color: #00008b;">do</span>           <span style="color: #8c8c8c; font-style: italic;">-- </span><span style="color: #8c8c8c; font-style: italic;">do &#21518;&#38754;&#30340;&#20107;&#24773;&#20250;&#26159;&#19981;&#38169;&#30340;&#20869;&#23384;&#25805;&#20316;, runST &#21487;&#20197;&#25226;&#23427;&#25289;&#20250;&#32431;&#30340;&#19990;&#30028;</span>
    n <span style="color: #b8860b;">&lt;-</span> newSTRef 0             <span style="color: #8c8c8c; font-style: italic;">-- </span><span style="color: #8c8c8c; font-style: italic;">&#22312;&#20869;&#23384;&#20013;&#21019;&#24314;&#19968;&#22359;&#24182;&#25351;&#21040; STRef</span>
    forM_ xs <span style="color: #b8860b;">$</span> <span style="color: #b8860b;">\</span>x <span style="color: #b8860b;">-&gt;</span> <span style="color: #00008b;">do</span>         <span style="color: #8c8c8c; font-style: italic;">-- </span><span style="color: #8c8c8c; font-style: italic;">&#36825;&#36319;&#21629;&#20196;&#24335;&#30340;for&#24490;&#29615;&#25913;&#20889;&#21464;&#37327;&#26159;&#19968;&#27611;&#19968;&#26679;&#30340;</span>
        modifySTRef n (<span style="color: #b8860b;">+</span>x)
    readSTRef n                 <span style="color: #8c8c8c; font-style: italic;">-- </span><span style="color: #8c8c8c; font-style: italic;">&#36820;&#22238;&#25913;&#23436;&#20043;&#21518;&#30340; n &#30340;&#20540;</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd7125c4" class="outline-3">
<h3 id="orgd7125c4">Free Monad</h3>
<div class="outline-text-3" id="text-orgd7125c4">
<p>
上一章说过的 RWS Monad 毕竟是固定搭配，当你的业务需要更多的 Monad 来表示 Effect 时，
我们就需要有那么个小猪手帮我们定义自己的 Monad。
</p>

<p>
那就是 Free, Free 可以将任意 datatype lift 成为 Monad
</p>
</div>

<div id="outline-container-org39f2302" class="outline-4">
<h4 id="org39f2302">Free</h4>
<div class="outline-text-4" id="text-org39f2302">
<p>
先看 Free 什么定义:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">data</span> <span style="color: #36648b;">Free</span> f a <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Roll</span> (f (<span style="color: #36648b;">Free</span> f a)) <span style="color: #b8860b;">|</span> <span style="color: #36648b;">Return</span> a
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala">seal <span style="color: #00008b;">trait</span> <span style="color: #36648b;">Free</span>[<span style="color: #6b8e23;">F</span>[<span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">A</span>]
<span style="color: #00008b;">case</span> <span style="color: #00008b;">class</span> <span style="color: #36648b;">Roll</span>[<span style="color: #6b8e23;">S</span>[<span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">A</span>](a<span style="color: #00008b;">:</span> <span style="color: #36648b;">S</span>[<span style="color: #6b8e23;">Free</span>[<span style="color: #6b8e23;">S</span>,<span style="color: #6b8e23;">A</span>]]) <span style="color: #00008b;">extends</span> <span style="color: #36648b;">Free</span>[<span style="color: #6b8e23;">S</span>, <span style="color: #6b8e23;">A</span>]
<span style="color: #00008b;">case</span> <span style="color: #00008b;">class</span> <span style="color: #36648b;">Return</span>[<span style="color: #6b8e23;">F</span>[<span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">A</span>](a<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span>) <span style="color: #00008b;">extends</span> <span style="color: #36648b;">Free</span>[<span style="color: #6b8e23;">S</span>, <span style="color: #6b8e23;">A</span>]
</pre>
</div>

<p>
其中 <code>f</code> 就是你业务需要的 effect 类型, <code>a</code> 是这个 effect 所产生的返回值类型。
</p>

<p>
右边两种构造函数，如果把 <code>Role</code> 改成 <code>Cons</code>, <code>Return</code> 改成 <code>Nil</code> 的话, 是不是跟 List 其实是 <ruby>同构<rt>isomophic</rt></ruby> 的呢? 所以如果想象成 List, 那么 <code>f</code> 在这里就相当于 List 中的一个元素.
</p>

<p>
到那时, <code>&gt;&gt;=</code> 的操作又跟 List 略有不同, 我们都知道 <code>&gt;&gt;=</code> 会把每一个元素 map 成 List, 然后 flatten, 但 Free 其实是用来构建
顺序的 effect 的, 所以:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">instance</span> <span style="color: #36648b;">Functor</span> f <span style="color: #b8860b;">=&gt;</span> <span style="color: #36648b;">Monad</span> (<span style="color: #36648b;">Free</span> f) <span style="color: #00008b;">where</span>
  return a        <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Return</span> a
  <span style="color: #36648b;">Return</span> a <span style="color: #b8860b;">&gt;&gt;=</span> fn <span style="color: #b8860b;">=</span> fn a
  <span style="color: #36648b;">Roll</span> ffa <span style="color: #b8860b;">&gt;&gt;=</span> fn <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Roll</span> <span style="color: #b8860b;">$</span> fmap (<span style="color: #b8860b;">&gt;&gt;=</span> fn) ffa
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #228b22;">implicit</span> <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">monadForFree</span>[<span style="color: #6b8e23;">S</span>[<span style="color: #00008b;">_</span>]](<span style="color: #228b22;">implicit</span> <span style="color: #6b8e23;">F</span><span style="color: #00008b;">:</span><span style="color: #36648b;">Functor</span>[<span style="color: #6b8e23;">S</span>])<span style="color: #00008b;">:</span> <span style="color: #36648b;">Monad</span>[<span style="color: #6b8e23;">Free</span>[<span style="color: #6b8e23;">S</span>, ?]] <span style="color: #00008b;">=</span>
  <span style="color: #00008b;">new</span> <span style="color: #36648b;">Monad</span>[<span style="color: #6b8e23;">Free</span>[<span style="color: #6b8e23;">S</span>, ?]] {
    <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">pure</span>[<span style="color: #6b8e23;">A</span>](a<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span>)<span style="color: #00008b;">:</span> <span style="color: #36648b;">Free</span>[<span style="color: #6b8e23;">S</span>, <span style="color: #6b8e23;">A</span>] <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">Return</span>(a)
    <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">map</span>[<span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>](fa<span style="color: #00008b;">:</span> <span style="color: #36648b;">Free</span>[<span style="color: #6b8e23;">S</span>, <span style="color: #6b8e23;">A</span>])(f<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">B</span>)<span style="color: #00008b;">:</span> <span style="color: #36648b;">Free</span>[<span style="color: #6b8e23;">S</span>, <span style="color: #6b8e23;">B</span>] <span style="color: #00008b;">=</span> fa.flatMap(a<span style="color: #00008b;">=&gt;</span><span style="color: #6b8e23;">Return</span>(f(a)))
    <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">flatMap</span>[<span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>](a<span style="color: #00008b;">:</span> <span style="color: #36648b;">Free</span>[<span style="color: #6b8e23;">S</span>, <span style="color: #6b8e23;">A</span>])(f<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">Free</span>[<span style="color: #6b8e23;">S</span>, <span style="color: #6b8e23;">B</span>])<span style="color: #00008b;">:</span> <span style="color: #36648b;">Free</span>[<span style="color: #6b8e23;">S</span>, <span style="color: #6b8e23;">B</span>] <span style="color: #00008b;">=</span> a <span style="color: #00008b;">match</span> {
      <span style="color: #00008b;">case</span> <span style="color: #36648b;">Return</span>(<span style="color: #b8860b;">a</span>) <span style="color: #00008b;">=&gt;</span> f(a)
      <span style="color: #00008b;">case</span> <span style="color: #36648b;">Roll</span>(<span style="color: #b8860b;">a</span>) <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">Roll</span>(<span style="color: #6b8e23;">F</span>.map(a)(<span style="color: #00008b;">_</span>.flatMap(f)))
    }
  }
</pre>
</div>
<p>
你会发现 <code>&gt;&gt;=</code> 会递归的 <code>fmap</code> 到 <code>Roll</code> 上, 直到最后一个 <code>Return</code>.
</p>

<p>
比如, 如果你有一个 program 有三种副作用 Eff1, Eff2, Eff3
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">data</span> <span style="color: #36648b;">Eff</span> a <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Eff1</span> a <span style="color: #b8860b;">|</span> <span style="color: #36648b;">Eff2</span> a <span style="color: #b8860b;">|</span> <span style="color: #36648b;">Eff3</span> a
<span style="color: #6a5acd;">program</span> <span style="color: #b8860b;">=</span> <span style="color: #00008b;">do</span>
 a <span style="color: #b8860b;">&lt;-</span> liftF <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff1</span> 1
 b <span style="color: #b8860b;">&lt;-</span> liftF <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff2</span> 2
 c <span style="color: #b8860b;">&lt;-</span> liftF <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff3</span> 3
 return a <span style="color: #b8860b;">+</span> b <span style="color: #b8860b;">+</span> c
</pre>
</div>
<div class="org-src-container">
<pre class="src src-scala"><span style="color: #228b22;">sealed</span> <span style="color: #00008b;">trait</span> <span style="color: #36648b;">Eff</span>[<span style="color: #6b8e23;">A</span>] {
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">eff1</span>[<span style="color: #6b8e23;">A</span>](a<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span>)<span style="color: #00008b;">:</span> <span style="color: #36648b;">Eff</span>[<span style="color: #6b8e23;">A</span>] <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">Free</span>.liftF[<span style="color: #6b8e23;">Eff</span>, <span style="color: #6b8e23;">A</span>](<span style="color: #6b8e23;">Eff1</span>(a))
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">eff2</span>[<span style="color: #6b8e23;">A</span>](a<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span>)<span style="color: #00008b;">:</span> <span style="color: #36648b;">Eff</span>[<span style="color: #6b8e23;">A</span>] <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">Free</span>.liftF[<span style="color: #6b8e23;">Eff</span>, <span style="color: #6b8e23;">A</span>](<span style="color: #6b8e23;">Eff2</span>(a))
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">eff3</span>[<span style="color: #6b8e23;">A</span>](a<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span>)<span style="color: #00008b;">:</span> <span style="color: #36648b;">Eff</span>[<span style="color: #6b8e23;">A</span>] <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">Free</span>.liftF[<span style="color: #6b8e23;">Eff</span>, <span style="color: #6b8e23;">A</span>](<span style="color: #6b8e23;">Eff3</span>(a))
}
<span style="color: #00008b;">case</span> <span style="color: #00008b;">class</span> <span style="color: #36648b;">Eff1</span>[<span style="color: #6b8e23;">A</span>](a<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span>) <span style="color: #00008b;">extends</span> <span style="color: #36648b;">Eff</span>[<span style="color: #6b8e23;">A</span>]
<span style="color: #00008b;">case</span> <span style="color: #00008b;">class</span> <span style="color: #36648b;">Eff2</span>[<span style="color: #6b8e23;">A</span>](a<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span>) <span style="color: #00008b;">extends</span> <span style="color: #36648b;">Eff</span>[<span style="color: #6b8e23;">A</span>]
<span style="color: #00008b;">case</span> <span style="color: #00008b;">class</span> <span style="color: #36648b;">Eff3</span>[<span style="color: #6b8e23;">A</span>](a<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span>) <span style="color: #00008b;">extends</span> <span style="color: #36648b;">Eff</span>[<span style="color: #6b8e23;">A</span>]

<span style="color: #00008b;">val</span> <span style="color: #b8860b;">program</span> <span style="color: #00008b;">=</span> <span style="color: #00008b;">for</span> {
  a <span style="color: #00008b;">&lt;-</span> eff1(<span style="color: #6b8e23;">1</span>)
  b <span style="color: #00008b;">&lt;-</span> eff2(<span style="color: #6b8e23;">2</span>)
  c <span style="color: #00008b;">&lt;-</span> eff3(<span style="color: #6b8e23;">3</span>)
} <span style="color: #00008b;">yield</span> a + b + c
</pre>
</div>

<p>
如果我们把 program 展开, 每一步 <code>&gt;&gt;=</code> 大概是这样:
</p>

<div class="org-src-container">
<pre class="src src-haskell">liftF <span style="color: #6a5acd;">$</span> <span style="color: #36648b;">Eff1</span> 1
</pre>
</div>

<p>
展开既是:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #36648b;">Roll</span> (<span style="color: #36648b;">Eff1</span> (<span style="color: #36648b;">Return</span> 1))
</pre>
</div>

<p>
代入到 program 即:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">program</span> <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Roll</span> (<span style="color: #36648b;">Eff1</span> (<span style="color: #36648b;">Return</span> 1)) <span style="color: #b8860b;">&gt;&gt;=</span> <span style="color: #b8860b;">\</span>a <span style="color: #b8860b;">-&gt;</span> <span style="color: #00008b;">do</span>
   b <span style="color: #b8860b;">&lt;-</span> liftF <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff2</span> 2
   c <span style="color: #b8860b;">&lt;-</span> liftF <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff3</span> 3
   return a <span style="color: #b8860b;">+</span> b <span style="color: #b8860b;">+</span> c
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">val</span> <span style="color: #b8860b;">program</span> <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">Roll</span>(<span style="color: #6b8e23;">Eff1</span>(<span style="color: #6b8e23;">Return</span>(<span style="color: #6b8e23;">1</span>))).flatMap(a<span style="color: #00008b;">=&gt;</span>
  <span style="color: #00008b;">for</span> {
    b <span style="color: #00008b;">&lt;-</span> eff2(<span style="color: #6b8e23;">2</span>)
    c <span style="color: #00008b;">&lt;-</span> eff3(<span style="color: #6b8e23;">3</span>)
  } <span style="color: #00008b;">yield</span> a + b + c
)
</pre>
</div>
<p>
用 Free 的 <code>&gt;&gt;=</code> 公式 <code>Roll ffa &gt;&gt;= fn = Roll $ fmap (&gt;&gt;= fn) ffa</code> 去展开上面就得到:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">program</span> <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Roll</span> <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff1</span> (<span style="color: #36648b;">Return</span> 1 <span style="color: #b8860b;">&gt;&gt;=</span> fn1)) <span style="color: #00008b;">where</span>
  fn1 <span style="color: #b8860b;">=</span> <span style="color: #b8860b;">\</span>a <span style="color: #b8860b;">-&gt;</span> <span style="color: #00008b;">do</span>
   b <span style="color: #b8860b;">&lt;-</span> liftF <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff2</span> 2
   c <span style="color: #b8860b;">&lt;-</span> liftF <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff3</span> 3
   return a <span style="color: #b8860b;">+</span> b <span style="color: #b8860b;">+</span> c
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">val</span> <span style="color: #b8860b;">fn1</span> <span style="color: #00008b;">=</span> (a<span style="color: #00008b;">:</span> <span style="color: #36648b;">Int</span>) <span style="color: #00008b;">=&gt;</span>
    <span style="color: #00008b;">for</span> {
      b <span style="color: #00008b;">&lt;-</span> eff2(<span style="color: #6b8e23;">2</span>)
      c <span style="color: #00008b;">&lt;-</span> eff3(<span style="color: #6b8e23;">3</span>)
    } <span style="color: #00008b;">yield</span> a + b + c

<span style="color: #00008b;">val</span> <span style="color: #b8860b;">program</span> <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">Roll</span>(<span style="color: #6b8e23;">Eff1</span>(<span style="color: #6b8e23;">Return</span>(<span style="color: #6b8e23;">1</span>).flatMap(fn1)))
</pre>
</div>
<p>
<code>Return 1 &gt;&gt;= fn1</code> 我们都知道怎么展开:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">program</span> <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Roll</span> <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff1</span> (fn1 1) <span style="color: #00008b;">where</span>
  fn1 <span style="color: #b8860b;">=</span> <span style="color: #b8860b;">\</span>a <span style="color: #b8860b;">-&gt;</span> <span style="color: #00008b;">do</span>
   b <span style="color: #b8860b;">&lt;-</span> liftF <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff2</span> 2
   c <span style="color: #b8860b;">&lt;-</span> liftF <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff3</span> 3
   return a <span style="color: #b8860b;">+</span> b <span style="color: #b8860b;">+</span> c
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">val</span> <span style="color: #b8860b;">fn1</span> <span style="color: #00008b;">=</span> (a<span style="color: #00008b;">:</span> <span style="color: #36648b;">Int</span>) <span style="color: #00008b;">=&gt;</span>
    <span style="color: #00008b;">for</span> {
      b <span style="color: #00008b;">&lt;-</span> eff2(<span style="color: #6b8e23;">2</span>)
      c <span style="color: #00008b;">&lt;-</span> eff3(<span style="color: #6b8e23;">3</span>)
    } <span style="color: #00008b;">yield</span> a + b + c

<span style="color: #00008b;">val</span> <span style="color: #b8860b;">program</span> <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">Roll</span>(<span style="color: #6b8e23;">Eff1</span>(fn1(<span style="color: #6b8e23;">1</span>)))
</pre>
</div>

<p>
展开 <code>fn1</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">program</span> <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Roll</span> <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff1</span> <span style="color: #00008b;">do</span>
   b <span style="color: #b8860b;">&lt;-</span> liftF <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff2</span> 2
   c <span style="color: #b8860b;">&lt;-</span> liftF <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff3</span> 3
   return 1 <span style="color: #b8860b;">+</span> b <span style="color: #b8860b;">+</span> c
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">val</span> <span style="color: #b8860b;">program</span> <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">Roll</span>(<span style="color: #6b8e23;">Eff1</span>(<span style="color: #00008b;">for</span> {
      b <span style="color: #00008b;">&lt;-</span> eff2(<span style="color: #6b8e23;">2</span>)
      c <span style="color: #00008b;">&lt;-</span> eff3(<span style="color: #6b8e23;">3</span>)
    } <span style="color: #00008b;">yield</span> <span style="color: #6b8e23;">1</span> + b + c))
</pre>
</div>

<p>
同样的步骤展开 Eff2
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">program</span> <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Roll</span> <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff1</span> <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Roll</span> <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff2</span> <span style="color: #00008b;">do</span>
   c <span style="color: #b8860b;">&lt;-</span> liftF <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff3</span> 3
   return 1 <span style="color: #b8860b;">+</span> 2 <span style="color: #b8860b;">+</span> c
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">val</span> <span style="color: #b8860b;">program</span> <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">Roll</span>(<span style="color: #6b8e23;">Eff1</span>(<span style="color: #6b8e23;">Roll</span>(<span style="color: #6b8e23;">Eff2</span>(<span style="color: #00008b;">for</span> {
      c <span style="color: #00008b;">&lt;-</span> eff3(<span style="color: #6b8e23;">3</span>)
    } <span style="color: #00008b;">yield</span> <span style="color: #6b8e23;">1</span> + <span style="color: #6b8e23;">2</span> + c))))
</pre>
</div>

<p>
和 Eff3
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">program</span> <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Roll</span> <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff1</span> <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Roll</span> <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff2</span> <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Roll</span> <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff3</span> <span style="color: #00008b;">do</span>
   return 1 <span style="color: #b8860b;">+</span> 2 <span style="color: #b8860b;">+</span> 3
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">val</span> <span style="color: #b8860b;">program</span> <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">Roll</span>(<span style="color: #6b8e23;">Eff1</span>(<span style="color: #6b8e23;">Roll</span>(<span style="color: #6b8e23;">Eff2</span>(<span style="color: #6b8e23;">Roll</span>(<span style="color: #6b8e23;">Eff3</span>(<span style="color: #6b8e23;">Return</span>(<span style="color: #6b8e23;">1</span> + <span style="color: #6b8e23;">2</span> + <span style="color: #6b8e23;">3</span>)))))))
</pre>
</div>

<p>
最后的 program 是不是很像 List 的 Cons 和 Nil 呢?
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">program</span> <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Roll</span> <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff1</span> <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Roll</span> <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff2</span> <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Roll</span> <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Eff3</span> <span style="color: #b8860b;">$</span> <span style="color: #36648b;">Return</span> 1 <span style="color: #b8860b;">+</span> 2 <span style="color: #b8860b;">+</span> 3
</pre>
</div>


<p>
但是, 细心的你可能早都发现了 <code>Eff</code> 这货必须是个 <code>Functor</code> 才行. 那我们如何随便定义一个 <code>data Eff</code> 直接能生成 <code>Functor Eff</code> 的实例呢?
</p>
</div>
</div>

<div id="outline-container-org4526f48" class="outline-4">
<h4 id="org4526f48">Coyoneda</h4>
<div class="outline-text-4" id="text-org4526f48">
<p>
希望你还依然记得第一部分的米田 <del>共</del> 引理
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">data</span> <span style="color: #36648b;">CoYoneda</span> f a <span style="color: #b8860b;">=</span> forall b<span style="color: #b8860b;">.</span> <span style="color: #36648b;">CoYoneda</span> (b <span style="color: #b8860b;">-&gt;</span> a) (f b)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">trait</span> <span style="color: #36648b;">CoYoneda</span>[<span style="color: #6b8e23;">F</span>[<span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">A</span>] {
  <span style="color: #00008b;">type</span> <span style="color: #6b8e23;">P</span>
  <span style="color: #00008b;">val</span> <span style="color: #b8860b;">fi</span><span style="color: #00008b;">:</span> <span style="color: #36648b;">F</span>[<span style="color: #6b8e23;">P</span>]
  <span style="color: #00008b;">val</span> <span style="color: #b8860b;">ks</span><span style="color: #00008b;">:</span> <span style="color: #36648b;">P</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">A</span>
}
<span style="color: #00008b;">object</span> <span style="color: #6b8e23;">CoYoneda</span>{
  <span style="color: #00008b;">type</span> <span style="color: #6b8e23;">Aux</span>[<span style="color: #6b8e23;">F</span>[<span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>] <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">CoYoneda</span>[<span style="color: #6b8e23;">F</span>, <span style="color: #6b8e23;">A</span>] { <span style="color: #00008b;">type</span> <span style="color: #6b8e23;">P</span> <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">B</span> }
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">apply</span>[<span style="color: #6b8e23;">F</span>[<span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>](f<span style="color: #00008b;">:</span> <span style="color: #36648b;">B</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">A</span>)(fa<span style="color: #00008b;">:</span> <span style="color: #36648b;">F</span>[<span style="color: #6b8e23;">B</span>])<span style="color: #00008b;">:</span> <span style="color: #36648b;">Aux</span>[<span style="color: #6b8e23;">F</span>, <span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>] <span style="color: #00008b;">=</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">CoYoneda</span>[<span style="color: #6b8e23;">F</span>, <span style="color: #6b8e23;">A</span>] {
    <span style="color: #00008b;">type</span> <span style="color: #6b8e23;">P</span> <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">B</span>
    <span style="color: #00008b;">val</span> <span style="color: #b8860b;">fi</span> <span style="color: #00008b;">=</span> fa
    <span style="color: #00008b;">val</span> <span style="color: #b8860b;">ks</span> <span style="color: #00008b;">=</span> f
  }
}
</pre>
</div>


<figure>
<img src="images/p3-CoYoneda.png" alt="p3-CoYoneda.png">

</figure>

<p>
事实上很简单可以把任何 <code>f</code> 变成 <code>CoYoneda f</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">phi</span> <span style="color: #b8860b;">::</span> f a <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">CoYoneda</span> f a
<span style="color: #6a5acd;">phi</span> fa <span style="color: #b8860b;">=</span> <span style="color: #36648b;">CoYoneda</span> id fa
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">def</span> <span style="color: #6a5acd;">phi</span>[<span style="color: #6b8e23;">F</span>[<span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">A</span>](fa<span style="color: #00008b;">:</span> <span style="color: #36648b;">F</span>[<span style="color: #6b8e23;">A</span>])<span style="color: #00008b;">:</span> <span style="color: #36648b;">Aux</span>[<span style="color: #6b8e23;">F</span>, <span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">A</span>] <span style="color: #00008b;">=</span> apply(identity)(fa)
</pre>
</div>


<figure>
<img src="images/p3-CoYoneda-phi.png" alt="p3-CoYoneda-phi.png">

</figure>

<p>
诀窍就是 <code>id</code>, 也就是你把 <code>b</code> 变成 <code>a</code>, 再把 <code>fa</code> 放到 <code>CoYoneda</code> 里就好了
</p>

<p>
当 <code>f</code> 是 <code>Functor</code> 时, 又可以把 <code>CoYoneda</code> 变成 <code>f</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">psi</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">Functor</span> f <span style="color: #b8860b;">=&gt;</span> <span style="color: #36648b;">CoYoneda</span> f a <span style="color: #b8860b;">-&gt;</span> f a
<span style="color: #6a5acd;">psi</span> (<span style="color: #36648b;">CoYoneda</span> g fa) <span style="color: #b8860b;">=</span> fmap g fa
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">def</span> <span style="color: #6a5acd;">psi</span>[<span style="color: #6b8e23;">F</span>[<span style="color: #00008b;">_</span>]<span style="color: #00008b;">:</span><span style="color: #36648b;">Functor</span>, <span style="color: #6b8e23;">A</span>](fa<span style="color: #00008b;">:</span> <span style="color: #36648b;">CoYoneda</span>[<span style="color: #6b8e23;">F</span>, <span style="color: #6b8e23;">A</span>])<span style="color: #00008b;">:</span> <span style="color: #36648b;">F</span>[<span style="color: #6b8e23;">A</span>] <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">Functor</span>[<span style="color: #6b8e23;">F</span>].map(fa.fi)(fa.ki)
</pre>
</div>


<figure>
<img src="images/p3-CoYoneda-psi.png" alt="p3-CoYoneda-psi.png">

</figure>

<p>
反过来的这个不重要, 重要的是 <code>phi</code>, 因为如果你可以把任何 <code>f</code> 变成 <code>CoYoneda f</code>, 而 <code>CoYoneda f</code> 又是 <code>Functor</code>,
我们不就免费得到一个 <code>Functor</code>?
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">instance</span> <span style="color: #36648b;">Functor</span> (<span style="color: #36648b;">Coyoneda</span> f) <span style="color: #00008b;">where</span>
  fmap f (<span style="color: #36648b;">Coyoneda</span> g fb) <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Coyoneda</span> (f <span style="color: #b8860b;">.</span> g) fb
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #228b22;">implicit</span> <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">freeFunctorForCoyoneda</span>[<span style="color: #6b8e23;">F</span>[<span style="color: #00008b;">_</span>]]<span style="color: #00008b;">:</span> <span style="color: #36648b;">Functor</span>[<span style="color: #6b8e23;">CoYoneda</span>[<span style="color: #6b8e23;">F</span>, <span style="color: #00008b;">_</span>]] <span style="color: #00008b;">=</span>
  <span style="color: #00008b;">new</span> <span style="color: #36648b;">Functor</span>[<span style="color: #6b8e23;">CoYoneda</span>[<span style="color: #6b8e23;">F</span>, <span style="color: #00008b;">_</span>]] {
    <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">map</span>[<span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>, <span style="color: #6b8e23;">C</span>](cfa<span style="color: #00008b;">:</span> <span style="color: #36648b;">Aux</span>[<span style="color: #6b8e23;">F</span>, <span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">C</span>])(f<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">B</span>)<span style="color: #00008b;">:</span> <span style="color: #36648b;">Aux</span>[<span style="color: #6b8e23;">F</span>, <span style="color: #6b8e23;">B</span>, <span style="color: #6b8e23;">C</span>] <span style="color: #00008b;">=</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">CoYoneda</span>[<span style="color: #6b8e23;">F</span>, <span style="color: #6b8e23;">B</span>] {
      <span style="color: #00008b;">type</span> <span style="color: #6b8e23;">P</span> <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">C</span>
      <span style="color: #00008b;">val</span> <span style="color: #b8860b;">fi</span><span style="color: #00008b;">:</span> <span style="color: #36648b;">F</span>[<span style="color: #6b8e23;">C</span>] <span style="color: #00008b;">=</span> cfa.fi
      <span style="color: #00008b;">val</span> <span style="color: #b8860b;">ki</span><span style="color: #00008b;">:</span> <span style="color: #36648b;">C</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">B</span> <span style="color: #00008b;">=</span> f compose cfa.ki
    }
  }
</pre>
</div>
</div>
</div>
<div id="outline-container-org3872010" class="outline-4">
<h4 id="org3872010">Free Functor</h4>
<div class="outline-text-4" id="text-org3872010">
<p>
比如我们的 <code>Eff</code> 就可以直接通过 <code>phi</code> 变成 <code>CoYoneda Eff</code>, 从而得到免费的 Functor
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">data</span> <span style="color: #36648b;">Eff</span> a <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Eff1</span> a <span style="color: #b8860b;">|</span> <span style="color: #36648b;">Eff2</span> a <span style="color: #b8860b;">|</span> <span style="color: #36648b;">Eff3</span> a
<span style="color: #6a5acd;">program</span> <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Roll</span> (phi (<span style="color: #36648b;">Eff1</span> (<span style="color: #36648b;">Roll</span> (phi (<span style="color: #36648b;">Eff2</span> (<span style="color: #36648b;">Return</span> <span style="color: #36648b;">Int</span>))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">val</span> <span style="color: #b8860b;">program</span> <span style="color: #00008b;">=</span> <span style="color: #6b8e23;">Roll</span>(phi(<span style="color: #6b8e23;">Eff1</span>(<span style="color: #6b8e23;">Roll</span>((phi(<span style="color: #6b8e23;">Eff2</span>(<span style="color: #6b8e23;">Roll</span>(phi(<span style="color: #6b8e23;">Eff3</span>(<span style="color: #6b8e23;">Return</span>(<span style="color: #6b8e23;">1</span> + <span style="color: #6b8e23;">2</span> + <span style="color: #6b8e23;">3</span>)))))))))))
</pre>
</div>


<figure>
<img src="images/p3-Free.png" alt="p3-Free.png">

</figure>
</div>
</div>

<div id="outline-container-orgf41b63e" class="outline-4">
<h4 id="orgf41b63e">Interpreter</h4>
<div class="outline-text-4" id="text-orgf41b63e">
<p>
构造完一个 free program 后,我们得到的是一个嵌套的数据结构, 当我们需要 run 这个 program 时, 我们需要 foldMap 一个
Interpreter 去一层层拨开 这个 free program.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">foldMap</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">Monad</span> m <span style="color: #b8860b;">=&gt;</span> (<span style="color: #00008b;">forall</span> x <span style="color: #b8860b;">.</span> f x <span style="color: #b8860b;">-&gt;</span> m x) <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">Free</span> f a <span style="color: #b8860b;">-&gt;</span> m a
<span style="color: #6a5acd;">foldMap</span> <span style="color: #00008b;">_</span> (<span style="color: #36648b;">Return</span> a)  <span style="color: #b8860b;">=</span> return a
<span style="color: #6a5acd;">foldMap</span> f (<span style="color: #36648b;">Roll</span> a) <span style="color: #b8860b;">=</span> f a <span style="color: #b8860b;">&gt;&gt;=</span> foldMap f
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">def</span> <span style="color: #6a5acd;">foldMap</span>[<span style="color: #6b8e23;">F</span>[<span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">M</span>[<span style="color: #00008b;">_</span>]<span style="color: #00008b;">:</span> <span style="color: #36648b;">Monad</span>, <span style="color: #6b8e23;">A</span>](free<span style="color: #00008b;">:</span> <span style="color: #36648b;">Free</span>[<span style="color: #6b8e23;">F</span>, <span style="color: #6b8e23;">A</span>])(fk<span style="color: #00008b;">:</span> <span style="color: #36648b;">F</span> ~&gt; <span style="color: #6b8e23;">M</span>)<span style="color: #00008b;">:</span> <span style="color: #36648b;">M</span>[<span style="color: #6b8e23;">A</span>] <span style="color: #00008b;">=</span> free <span style="color: #00008b;">match</span> {
  <span style="color: #00008b;">case</span> <span style="color: #36648b;">Return</span>(<span style="color: #b8860b;">a</span>) <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">Monad</span>[<span style="color: #6b8e23;">M</span>].pure(a)
  <span style="color: #00008b;">case</span> <span style="color: #36648b;">Roll</span>(<span style="color: #b8860b;">a</span>) <span style="color: #00008b;">=&gt;</span> fk(a).flatMap(foldMap(<span style="color: #00008b;">_</span>)(fk))
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgdaccf82" class="outline-3">
<h3 id="orgdaccf82"><span class="todo TODO">TODO</span> Free Monoid</h3>
</div>
<div id="outline-container-org12cde21" class="outline-3">
<h3 id="org12cde21"><span class="todo TODO">TODO</span> Eff</h3>
</div>

<div id="outline-container-orgffa68b7" class="outline-3">
<h3 id="orgffa68b7"><span class="todo TODO">TODO</span> Comonad</h3>
</div>
</div>
</div>
<div id="postamble" class="status">
<footer>
  <p>Author: 欧阳继超
    <a class="github-button" href="https://github.com/sponsors/jcouyang" data-icon="octicon-heart" aria-label="Sponsor @jcouyang on GitHub">Sponsor</a>
    <a aria-label="Follow @jcouyang on GitHub" data-count-aria-label="# followers on GitHub" data-count-api="/users/jcouyang#followers" data-count-href="/jcouyang/followers" href="https://github.com/jcouyang" class="github-button">Follow</a>
    <a href="https://twitter.com/oyanglulu" class="twitter-follow-button" data-show-screen-name="false" data-show-count="false">Follow @oyanglulu</a>
  </p>
  <p>Created: 2018-07-28 Sat 00:00</p>
  <p>Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.3 (<a href="https://orgmode.org">Org</a> mode 9.3.6) &#215; <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.
  <input type="swiftype" class="st-default-search-input" placeholder="Search"/>
  <a class="gumroad-button" href="https://gum.co/grokking-monad?wanted=true" target="_blank" data-gumroad-single-product="true">范畴论装逼指南，请自觉排队装逼</a>
  <div id="danmaku-comments"></div>
  <div id="disqus_thread"></div>
</footer>
</div>
</body>
</html>
