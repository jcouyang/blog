<!DOCTYPE html>
<html lang="zh">
<head>
<!-- 2020-04-06 Mon 07:31 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>范畴论完全装逼手册 / Grokking Monad</title>
<meta name="generator" content="Org mode">
<meta name="author" content="欧阳继超">
<meta name="description" content="卷一 猫论"
>
<link rel="icon" href="/favicon.ico">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/toc.css"/>
<link rel="stylesheet" href="/style/tufte.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="https://feeds.oyanglul.us/JichaoOuyangsBlog"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-NJRFJGX"
                  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
<header>
    <a accesskey="h" href="/index.html"> HOME </a> |
    <a href="#" id="edit-in-github">EDIT</a> |
    <a href="https://feeds.oyanglul.us/JichaoOuyangsBlog">RSS</a> |
    <a href="https://blog.oyanglul.us/theindex">INDEX</a> |
    <a accesskey="H" href="/jichao.ouyang.html">ABOUT</a> |
    <a href="https://github.com/jcouyang/blog">GITHUB</a>
</header>
</div>
<div id="content">
<header>
<h1 class="title">范畴论完全装逼手册 / Grokking Monad</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgd9a36f1">第一部分：<ruby>猫论<rt>Catergory Theory</rt></ruby></a>
<ul>
<li><a href="#orgbf900a8"><i>Category</i></a>
<ul>
<li><a href="#org1dc3286"><i>Hask</i></a></li>
<li><a href="#org52ba652"><i>Duel</i></a></li>
</ul>
</li>
<li><a href="#orgea2dda4">函子 / Functor</a></li>
<li><a href="#org6e0cc40"><span class="todo TODO">TODO</span> <i><ruby>Cat<rt> +猫+</rt></ruby></i></a></li>
<li><a href="#org5305314">自然变换 / Natural Transformations </a></li>
<li><a href="#org55c5c26">String Diagram</a></li>
<li><a href="#org02ba778"><i>Adjunction Functor</i> 伴随函子</a></li>
<li><a href="#org157f17f">从伴随函子到 <ruby>单子<rt> Monad</rt></ruby></a>
<ul>
<li><a href="#orgca7d5a1">三角等式</a></li>
<li><a href="#orgf2a5830">结合律</a></li>
</ul>
</li>
<li><a href="#org1a754d9">Yoneda lemma / <del>米田共</del> 米田引理</a>
<ul>
<li><a href="#orgade6eef">Rank N Type</a></li>
</ul>
</li>
<li><a href="#org0fb6f6c">Kan extensions 看展</a>
<ul>
<li><a href="#org043688b"><span class="todo TODO">TODO</span> insert diagram</a></li>
<li><a href="#org77bbe66"><span class="todo TODO">TODO</span> insert diagram</a></li>
</ul>
</li>
<li><a href="#org733f8e7"><i>Kleisli Catergory</i></a></li>
<li><a href="#orgc07522e">Summary</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<ul class="org-ul">
<li><b><a href="./part1.html">第一部分：猫论</a></b> 👈</li>
<li><a href="./part2.html">第二部分：食用猫呢</a></li>
<li><a href="./part3.html">第三部分：搞基猫呢</a></li>
</ul>
<div id="outline-container-orgd9a36f1" class="outline-2">
<h2 id="orgd9a36f1">第一部分：<ruby>猫论<rt>Catergory Theory</rt></ruby></h2>
<div class="outline-text-2" id="text-orgd9a36f1">
<p>
<img src="./images/Cheshire_Cat.png" alt="Cheshire_Cat.png"> <label for="1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="1" class="margin-toggle"/><span class="sidenote">
<a href="https://en.wikipedia.org/wiki/Cheshire_Cat">https://en.wikipedia.org/wiki/Cheshire_Cat</a>
</span>
</p>

<div class="epigraph"><blockquote>
<p>
`But I don’t want to go among mad people,’ Alice remarked.
</p>

<p>
`Oh, you can’t help that,’ said the Cat: `we’re all mad here. I’m mad. You’re mad.’
</p>

<p>
`How do you know I’m mad?’ said Alice.
`You must be,’ said the Cat, `or you wouldn’t have come here.’
</p>

<p>
Alice didn’t think that proved it at all; however, she went on `And how do you know that you’re mad?’
</p>

<p>
&#x2013; Alice's Adventures in Wonderland
</p>

</blockquote></div>

<p>
<ruby>单子<rt>Monad</rt></ruby>是什么? 你也不懂, 我也不懂, 我们都不懂.
</p>

<p>
话说, 我又怎么知道你不懂呢?
</p>

<p>
当然不懂, 不然, 你怎么会来到这里?
</p>

<p>
我又是怎么知道自己不懂呢?
</p>

<p>
因为, 我知道懂的人什么样子. 显然, 我不是.
</p>

<p>
懂的人一定知道<ruby>猫论<rt> Category Theory</rt></ruby>.
</p>

<p>
懂猫论的人又不一定知道编程. 但是懂编程的人可以略懂猫论.
</p>

<p>
编程是项技术, 即理论的降维. 所以要降低门槛, 比如我在书中也<a href="https://book.douban.com/subject/26883736/">写过一章</a>用JavaScript来解释，某人也尝试过<a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html">写博客解释</a>，<label for="2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="2" class="margin-toggle"/><span class="sidenote">
如果没看就刚好不要看了, 确实有些误导
</span>没想到那些也不知道会不会 Haskell/Scala 的人就跑出来喷你们前端<label for="3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="3" class="margin-toggle"/><span class="sidenote">
等等, 写前端怎么了? JavaScript 只是我觉得顺手的若干语言之一, JS用户那么多, 写书当然要用 JS 啦, 难道用 Idris 那还能卖得掉吗? <del>当然最后用JS也没怎么卖掉&#x2026;</del>
</span>这些不懂函数式的渣渣乱搞出来的东西根本就不是单子。
</p>

<p>
我也画过一些图来解释，又会被嫌弃画风不好。但是，作为灵魂画师，我只 <del>是觉得自己萌萌的啊</del> 在乎画的灵魂是否能够给你一点启发。好吧，讲这么学术的东西，还是用dot来画吧，看起来好正规呢。
</p>

<p>
好了，安全带系好，我真的要开车了。为了防止<ruby>解释的不到位<rt>又被喷</rt></ruby>，就用 Haskell/Scala 好了<label for="4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="4" class="margin-toggle"/><span class="sidenote">
并不是说这两门语言一定在鄙视链顶端, 而是拥有强大类型系统的语言才能体现出范畴论的内容
</span>，其实也不难解释清楚 <del>才怪</del> 。
</p>

<p>
这里面很多很装逼的单词，它们都是 <i>斜体</i> ，就算没看懂，把这些词背下来也足够<ruby>装好一阵子逼了<rt>买一阵子萌了</rt></ruby>。
</p>

<p>
这里还有很多代码, 它们都成对出现, 第一段是 Haskell, 第二段是 Scala.
</p>
</div>

<div id="outline-container-orgbf900a8" class="outline-3">
<h3 id="orgbf900a8"><i>Category</i></h3>
<div class="outline-text-3" id="text-orgbf900a8">
<p>
一个 <i><ruby>范畴<rt>Category</rt></ruby></i> 包含两个玩意
</p>
<ul class="org-ul">
<li>东西 <code>O</code> （Object）</li>
<li>两个东西的关系，箭头 <code>~&gt;</code> （ <i><ruby>态射<rt>Morphism</rt></ruby></i> ）</li>
</ul>

<p>
还必须带上一些属性: 
</p>
<ul class="org-ul">
<li>一定有一个叫 id 的箭头，也叫做 1</li>
<li>箭头可以 <i><ruby>组合<rt> compose</rt></ruby></i></li>
</ul>

<p>
恩, 就是这么简单!
</p>


<figure>
<object type="image/svg+xml" data="images/category.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>

<figcaption><span class="figure-number">Figure 1: </span>有东西 a, b, c 和箭头 f, g 的 Category，其中 f . g 表示 compose f 和 g</figcaption>
</figure>


<div class="epigraph"><blockquote>
<p>
注意到为什么我会箭头从右往左，接着看代码, 你会发现这个方向跟 compose 的方向刚好一致!
</p>

</blockquote></div>

<p>
这些玩意对应到 haskell 的 typeclass 大致就是这样:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">class</span> <span style="color: #36648b;">Category</span> (c <span style="color: #b8860b;">::</span> <span style="color: #b8860b;">*</span> <span style="color: #b8860b;">-&gt;</span> <span style="color: #b8860b;">*</span> <span style="color: #b8860b;">-&gt;</span> <span style="color: #b8860b;">*</span>) <span style="color: #00008b;">where</span>
  id <span style="color: #b8860b;">::</span> c a a
  (<span style="color: #b8860b;">.</span>) <span style="color: #b8860b;">::</span> c y z <span style="color: #b8860b;">-&gt;</span> c x y <span style="color: #b8860b;">-&gt;</span> c x z
</pre>
</div>


<p>
而 Scala 可以用 trait 来表示这个 typeclass:
</p>
<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">trait</span> <span style="color: #36648b;">Category</span>[<span style="color: #6b8e23;">C</span>[<span style="color: #00008b;">_</span>, <span style="color: #00008b;">_</span>]] {
  <span style="color: #00008b;">val</span> <span style="color: #b8860b;">id</span>[<span style="color: #6b8e23;">A</span>]<span style="color: #00008b;">:</span> <span style="color: #36648b;">C</span>[<span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">A</span>]
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">&lt;&lt;&lt;</span>(a<span style="color: #00008b;">:</span> <span style="color: #36648b;">C</span>[<span style="color: #6b8e23;">Y</span>, <span style="color: #6b8e23;">Z</span>], b<span style="color: #00008b;">:</span> <span style="color: #36648b;">C</span>[<span style="color: #6b8e23;">X</span>, <span style="color: #6b8e23;">Y</span>])<span style="color: #00008b;">:</span> <span style="color: #36648b;">C</span>[<span style="color: #6b8e23;">X</span>, <span style="color: #6b8e23;">Z</span>] 
}
</pre>
</div>

<p>
如果这是你第一次见到 Haskell 代码，没有关系，语法真的很简单 <del>才怪</del>
</p>
<ul class="org-ul">
<li><code>class</code> 定义了一个 TypeClass， <code>Category</code> 是这个 TypeClass 的名字</li>
<li>Type class 类似于定义类型的规范，规范为 <code>where</code> 后面那一坨</li>
<li>类型规范的对象是参数 <code>(c:: * -&gt; * -&gt; *)</code> ， <code>::</code> 后面是c的类型</li>
<li>c 是 <i>higher kind</i> <code>* -&gt; *</code> ，跟higher order function的定义差不多，它是接收类型，构造新类型的类型。这里的 c 接收一个类型，再接收一个类型，就可以返回个类型。</li>
</ul>
<ul class="org-ul">
<li><code>id:: c a a</code> 表示 c 范畴上的 a 到 a 的箭头</li>
<li><code>.</code> 的意思 c 范畴上，如果喂一个 y 到 z 的箭头，再喂一个 x 到 y 的箭头，那么就返回 x 到 z 的箭头。</li>
</ul>

<p>
另外 compose 在 haskell 中直接是句号 <code>.</code>
</p>

<p>
scala 中用 <code>&lt;&lt;&lt;</code> 或者 <code>compose</code>
</p>

<p>
总之, 用文字再读一遍上面这些代码就了然了.
</p>

<p>
范畴 C 其实就包含
</p>
<ol class="org-ol">
<li>返回 A 对象到 A 对象的 id 箭头</li>
<li>可以组合 Y 对象到 Z 对象 和 X 对象到 Y 对象的箭头 compose</li>
</ol>

<p>
<ruby>简单吧<rt>hen nan ba</rt></ruby>?还没有高数抽象呢。
</p>
</div>

<div id="outline-container-org1dc3286" class="outline-4">
<h4 id="org1dc3286"><i>Hask</i></h4>
<div class="outline-text-4" id="text-org1dc3286">
<p>
Haskell 类型系统范畴叫做 Hask
</p>
<p>
在 Hask 范畴上：
</p>

<ul class="org-ul">
<li>东西就是类型</li>
<li>箭头是类型的变换，即 <code>-&gt;</code></li>
<li>id 就是 id 函数的类型 <code>a -&gt; a</code></li>
<li>compose 当然就是函数组合的类型</li>
</ul>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">type</span> <span style="color: #36648b;">Hask</span> <span style="color: #b8860b;">=</span> <span style="color: #36648b;">(-&gt;)</span>
<span style="color: #00008b;">instance</span> <span style="color: #36648b;">Category</span> (<span style="color: #36648b;">Hask</span><span style="color: #b8860b;">::</span> <span style="color: #b8860b;">*</span> <span style="color: #b8860b;">-&gt;</span> <span style="color: #b8860b;">*</span> <span style="color: #b8860b;">-&gt;</span> <span style="color: #b8860b;">*</span>) <span style="color: #00008b;">where</span>
  (f <span style="color: #b8860b;">.</span> g) x <span style="color: #b8860b;">=</span> f (g x)
</pre>
</div>

<p>
我们看见新的关键字 <code>instance</code> ，这表示 Hask 是 Type class Category 的实例类型，也就是说对任意Hask类型, 那么就能找到它的 id 和 compose
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #228b22;">implicit</span> <span style="color: #00008b;">val</span> <span style="color: #b8860b;">haskCat</span><span style="color: #00008b;">:</span> <span style="color: #36648b;">Category</span>[<span style="color: #6b8e23;">Hask</span>[<span style="color: #00008b;">_</span>, <span style="color: #00008b;">_</span>]] <span style="color: #00008b;">=</span> <span style="color: #00008b;">new</span> <span style="color: #36648b;">Category</span>[<span style="color: #6b8e23;">Hask</span>] {
  <span style="color: #00008b;">val</span> <span style="color: #b8860b;">id</span>[<span style="color: #6b8e23;">A</span>] <span style="color: #00008b;">=</span> identity[<span style="color: #6b8e23;">A</span>]
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">&lt;&lt;&lt;</span>[<span style="color: #6b8e23;">X</span>, <span style="color: #6b8e23;">Y</span>, <span style="color: #6b8e23;">Z</span>](a<span style="color: #00008b;">:</span> <span style="color: #36648b;">Hask</span>[<span style="color: #6b8e23;">Y</span>, <span style="color: #6b8e23;">Z</span>], b<span style="color: #00008b;">:</span> <span style="color: #36648b;">Hask</span>[<span style="color: #6b8e23;">X</span>, <span style="color: #6b8e23;">Y</span>]) <span style="color: #00008b;">=</span> a compose b
}
</pre>
</div>

<p>
Scala 中, 只需要 new 这个 trait 就可以实现这个 typeclass
</p>

<p>
其中: identity <code>Hask a a</code> 就是
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #36648b;">(-&gt;)</span> a a <span style="color: #8c8c8c; font-style: italic;">-- </span><span style="color: #8c8c8c; font-style: italic;">or</span>
a <span style="color: #b8860b;">-&gt;</span> a <span style="color: #8c8c8c; font-style: italic;">-- </span><span style="color: #8c8c8c; font-style: italic;">&#22240;&#20026; -&gt; &#26159;&#20013;&#32512;&#26500;&#36896;&#22120;</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #6b8e23;">A</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">A</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org52ba652" class="outline-4">
<h4 id="org52ba652"><i>Duel</i></h4>
<div class="outline-text-4" id="text-org52ba652">
<p>
每个 Category 还有一个镜像，什么都一样，除了箭头是反的
</p>
</div>
</div>
</div>

<div id="outline-container-orgea2dda4" class="outline-3">
<h3 id="orgea2dda4">函子 / Functor</h3>
<div class="outline-text-3" id="text-orgea2dda4">
<p>
两个范畴中间可以用叫 Functor 的东西来连接起来，简称 T。
</p>


<figure>
<object type="image/svg+xml" data="images/functor.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>

<figcaption><span class="figure-number">Figure 2: </span>Functor C D T, 从 C 到 D 范畴的Functor T</figcaption>
</figure>

<p>
所以大部分把 Functor/Monad 比喻成盒子其实在定义上是错的，虽然这样比喻比较容易理解，在使用上问题也不大。但是，Functor 只是从一个范畴到另一个范畴的映射关系而已。
</p>

<ul class="org-ul">
<li>范畴间 东西的 Functor 标记为 <code>T(O)</code></li>
<li>范畴间 箭头的 Functor 标记为 <code>T(~&gt;)</code></li>
<li>任何范畴C上存在一个 T 把所有的 O 和 ~&gt; 都映射到自己，标记为id functor 1<sub>C</sub>
<ul class="org-ul">
<li>1<sub>C</sub>(O) = O</li>
<li>1<sub>C</sub>(~&gt;) = ~&gt;</li>
</ul></li>
</ul>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">class</span> (<span style="color: #36648b;">Category</span> c, <span style="color: #36648b;">Category</span> d) <span style="color: #b8860b;">=&gt;</span> <span style="color: #36648b;">Functor</span> c d t <span style="color: #00008b;">where</span>
  fmap <span style="color: #b8860b;">::</span> c a b <span style="color: #b8860b;">-&gt;</span> d (t a) (t b)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">trait</span> <span style="color: #36648b;">Functor</span>[<span style="color: #6b8e23;">C</span>[<span style="color: #00008b;">_</span>, <span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">D</span>[<span style="color: #00008b;">_</span>, <span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">T</span>[<span style="color: #00008b;">_</span>]] {
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">fmap</span>[<span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>](c<span style="color: #00008b;">:</span> <span style="color: #36648b;">C</span>[<span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>])<span style="color: #00008b;">:</span> <span style="color: #36648b;">D</span>[<span style="color: #6b8e23;">T</span>[<span style="color: #6b8e23;">A</span>], <span style="color: #6b8e23;">T</span>[<span style="color: #6b8e23;">B</span>]]
}
</pre>
</div>

<p>
<code>Functor c d t</code> 这表示从范畴 c 到范畴 d 的一个 Functor t
</p>

<p>
如果把范畴 c 和 d 都限制到 Hask 范畴
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">class</span> <span style="color: #36648b;">Functor</span> <span style="color: #36648b;">(-&gt;)</span> <span style="color: #36648b;">(-&gt;)</span> t <span style="color: #00008b;">where</span>
  fmap <span style="color: #b8860b;">::</span> <span style="color: #36648b;">(-&gt;)</span> a b <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">(-&gt;)</span> (t a) (t b)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">trait</span> <span style="color: #36648b;">Functor</span>[<span style="color: #00008b;">=&gt;</span>[<span style="color: #00008b;">_</span>, <span style="color: #00008b;">_</span>], <span style="color: #00008b;">=&gt;</span>[<span style="color: #00008b;">_</span>, <span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">T</span>[<span style="color: #00008b;">_</span>]] {
 <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">fmap</span>[<span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>](c<span style="color: #00008b;">:</span> <span style="color: #00008b;">=&gt;</span>[<span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>])<span style="color: #00008b;">:</span> <span style="color: #00008b;">=&gt;</span>[<span style="color: #6b8e23;">T</span>[<span style="color: #6b8e23;">A</span>], <span style="color: #6b8e23;">T</span>[<span style="color: #6b8e23;">B</span>]]
}
</pre>
</div>
<p>
<code>-&gt;</code> 在 Haskell 中是中缀类型构造器，所以是可以写在中间的
</p>

<p>
这样就会变成我们熟悉的 Funtor 的 Typeclass<label for="5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="5" class="margin-toggle"/><span class="sidenote">
这里可以把 Functor 的第一第二个参数消掉, 因为已经知道是在 Hask 范畴了
</span>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">class</span> <span style="color: #36648b;">Functor</span> t <span style="color: #00008b;">where</span>
  fmap <span style="color: #b8860b;">::</span> (a <span style="color: #b8860b;">-&gt;</span> b) <span style="color: #b8860b;">-&gt;</span> (t a <span style="color: #b8860b;">-&gt;</span> t b)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">trait</span> <span style="color: #36648b;">Functor</span>[<span style="color: #6b8e23;">T</span>[<span style="color: #00008b;">_</span>]] {
 <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">fmap</span>[<span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>](c<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">B</span>)<span style="color: #00008b;">:</span> <span style="color: #36648b;">T</span>[<span style="color: #6b8e23;">A</span>] <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">T</span>[<span style="color: #6b8e23;">B</span>]
}
</pre>
</div>

<p>
而 <i><ruby>自函子<rt>endofunctor</rt></ruby></i> 就是这种连接相同范畴的 Functor，因为它从范畴 Hask 到达同样的范畴 Hask
</p>
<p>
这回看代码就很容易对应上图和概念了, 这里的自函子只是映射范畴 <code>-&gt;</code> 到 <code>-&gt;</code>, 箭头函数那个箭头, 类型却变成了 t a
</p>

<p>
这里的 fmap 就是 T(~&gt;)，在 Hask 范畴上，所以是 T(-&gt;), 这个箭头是函数，所以也能表示成 T(f) 如果 <code>f:: a -&gt; b</code>
</p>
</div>
</div>

<div id="outline-container-org6e0cc40" class="outline-3">
<h3 id="org6e0cc40"><span class="todo TODO">TODO</span> <i><ruby>Cat<rt> +猫+</rt></ruby></i></h3>
<div class="outline-text-3" id="text-org6e0cc40">
<p>
递归的, 当我们可以把一个 Category 看成一个 object，functor 看成箭头，那么我们又得到了一个 Category，这种 object 是 category 的 category 我们叫它 &#x2013; <i>Cat</i>
</p>

<p>
已经<ruby>没<rt> meow</rt></ruby>的办法用语言描述这么高维度的事情了，看图吧&#x2026;
</p>
</div>
</div>

<div id="outline-container-org5305314" class="outline-3">
<h3 id="org5305314">自然变换 / Natural Transformations <a id="orgb1490d8"></a></h3>
<div class="outline-text-3" id="text-org5305314">
<p>
Functor 是范畴间的映射，所以在这个 Cat 范畴中, 把范畴看成是对象, 那么 Functor 在 Cat 范畴又是个箭头
</p>

<figure>
<object type="image/svg+xml" data="images/natrual-transformation.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>

<figcaption><span class="figure-number">Figure 3: </span>Functor F和G，以及 F 到 G 的自然变化 &eta;</figcaption>
</figure>

<p>
而 Functor 间也有映射，叫做 <del>喵的变换</del> <i>自然变换</i>
</p>

<p>
范畴 c 上的函子 f 到 g 的自然变化就可以表示成
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">type</span> <span style="color: #36648b;">Nat</span> c f g <span style="color: #b8860b;">=</span> c (f a) (g a)
</pre>
</div>

<p>
Scala 没有 rank n type<label for="6" class="margin-toggle sidenote-number"></label><input type="checkbox" id="6" class="margin-toggle"/><span class="sidenote">
别急, 后面马上讲到
</span>, 只能靠 apply 来 meme 了
</p>
<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">trait</span> <span style="color: #36648b;">Nat</span>[<span style="color: #6b8e23;">C</span>[<span style="color: #00008b;">_</span>, <span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">F</span>[<span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">G</span>[<span style="color: #00008b;">_</span>]] {
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">apply</span>[<span style="color: #6b8e23;">A</span>]<span style="color: #00008b;">:</span> <span style="color: #36648b;">C</span>[<span style="color: #6b8e23;">F</span>[<span style="color: #6b8e23;">A</span>], <span style="color: #6b8e23;">G</span>[<span style="color: #6b8e23;">A</span>]]
}
</pre>
</div>

<p>
Hask 范畴上的自然变化就变成了
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">type</span> <span style="color: #36648b;">NatHask</span> f g <span style="color: #b8860b;">=</span> f a <span style="color: #b8860b;">-&gt;</span> g a
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">trait</span> <span style="color: #36648b;">NatHask</span>[<span style="color: #6b8e23;">F</span>[<span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">G</span>[<span style="color: #00008b;">_</span>]] {
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">apply</span>[<span style="color: #6b8e23;">A</span>]<span style="color: #00008b;">:</span> <span style="color: #36648b;">F</span>[<span style="color: #6b8e23;">A</span>] <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">G</span>[<span style="color: #6b8e23;">A</span>]
}

</pre>
</div>

<p>
有趣的是, 还可以继续升维度, 比如
</p>

<ul class="org-ul">
<li>东西是函子</li>
<li>箭头是自然变换</li>
</ul>

<p>
恭喜你到达 Functor 范畴.
</p>

<p>
当然, 要成为范畴，还有两个属性:
</p>
<ul class="org-ul">
<li>id 为 f a 到 f a 的自然变换</li>
<li>自然变换的组合</li>
</ul>


<figure>
<object type="image/svg+xml" data="images/functor-category.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>

</figure>

<p>
别着急, 我们来梳理一下，如果已经不知道升了几个维度了，我们假设类型所在范畴是第一维度
</p>
<ul class="org-ul">
<li>一维： Hask， 东西是类型，箭头是 -&gt;</li>
<li>二维： Cat， 东西是 Hask， 箭头是 Functor</li>
<li>三维： Functor范畴， 东西是Functor， 箭头是自然变换</li>
</ul>

<p>
感觉到达三维已经是极限了，尼玛还有完没完了，每升一个维度还要起这么多装逼的名字，再升维度老子就画不出来了
</p>

<p>
所以这时候, 需要引入 String Diagram。
</p>
</div>
</div>

<div id="outline-container-org55c5c26" class="outline-3">
<h3 id="org55c5c26">String Diagram</h3>
<div class="outline-text-3" id="text-org55c5c26">
<p>
String Diagram 的概念很简单，就是点变线线变点。
</p>

<p>
还记得当有了自然变换之后，三个维度已经没法表示了，那原来的点和线都升一维度，变成线和面，这样，就腾出一个点来表示自然变换了。
</p>


<figure>
<img src="images/p1-string-diagram.png" alt="p1-string-diagram.png">

<figcaption><span class="figure-number">Figure 5: </span>String Diagram：自然变换是点，Functor是线，范畴是面</figcaption>
</figure>

<p>
compose的方向是从右往左，从下到上。
</p>
</div>
</div>

<div id="outline-container-org02ba778" class="outline-3">
<h3 id="org02ba778"><i>Adjunction Functor</i> 伴随函子</h3>
<div class="outline-text-3" id="text-org02ba778">
<p>
范畴C和D直接有来有回的函子，为什么要介绍这个，因为它直接可以推出 Monad
</p>

<p>
让我们来看看什么叫有来回。
</p>


<figure>
<img src="images/p1-adjunction-functor.png" alt="p1-adjunction-functor.png">

</figure>

<p>
其中：
</p>

<ul class="org-ul">
<li>一个范畴 C 可以通过函子 G 到 D，再通过函子 F 回到 C，那么 F 和 G 就是伴随函子。</li>
<li>&eta; 是 GF 到 1<sub>D</sub> 的自然变换</li>
<li>&epsilon; 是 1<sub>C</sub> 到 FG 的自然变换</li>
</ul>

<p>
同时根据同构的定义，G 与 F 是 <i>同构</i> 的。
</p>
<p>
同构指的是若是有
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">f</span> <span style="color: #b8860b;">::</span> a <span style="color: #b8860b;">-&gt;</span> b
f'<span style="color: #b8860b;">::</span> b <span style="color: #b8860b;">-&gt;</span> a
</pre>
</div>

<p>
那么 f 与 f' 同构，因为 f . f' = id = f' . f
</p>

<p>
伴随函子的 FG 组合是 C 范畴的 id 函子 F . G = 1<sub>c</sub>
</p>


<figure>
<img src="images/p1-ajunction-functor-compose.png" alt="p1-ajunction-functor-compose.png">

<figcaption><span class="figure-number">Figure 7: </span>伴随函子的两个Functor组合, 左侧为 F &eta;, 右侧为 &epsilon; F</figcaption>
</figure>

<p>
Functor 不仅横着可以组合，竖着(自然变换维度)也是可以组合的，因为自然变换是 Functor 范畴的箭头。
</p>


<figure>
<img src="images/p1-ajunction-functor-compose-nat.png" alt="p1-ajunction-functor-compose-nat.png">

<figcaption><span class="figure-number">Figure 8: </span>F &eta; . &epsilon; F  = F</figcaption>
</figure>

<p>
当到组合 F &eta; . &epsilon; F 得到一个弯弯曲曲的 F 时，我们可以拽着F的两段一拉，就得到了直的 F。
</p>

<p>
String Diagram 神奇的地方是所有线都可以拉上下两端，这个技巧非常有用，在之后的单子推导还需要用到。
</p>
</div>
</div>

<div id="outline-container-org157f17f" class="outline-3">
<h3 id="org157f17f">从伴随函子到 <ruby>单子<rt> Monad</rt></ruby></h3>
<div class="outline-text-3" id="text-org157f17f">
<p>
有了伴随函子，很容易推出单子，让我们先来看看什么是单子
</p>

<ul class="org-ul">
<li>首先，它是一个 endofunctor T</li>
<li>有一个从 i<sub>c</sub> 到 T 的自然变化 &eta; (eta)</li>
<li>有一个从 T<sup>2</sup> 到 T 的自然变化 &mu; (mu)</li>
</ul>


<figure>
<img src="images/p1-monad-properties.png" alt="p1-monad-properties.png">

</figure>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">class</span> <span style="color: #36648b;">Endofunctor</span> c t <span style="color: #b8860b;">=&gt;</span> <span style="color: #36648b;">Monad</span> c t <span style="color: #00008b;">where</span>
  eta <span style="color: #b8860b;">::</span> c a (t a)
  mu  <span style="color: #b8860b;">::</span> c (t (t a)) (t a)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">trait</span> <span style="color: #36648b;">Monad</span>[<span style="color: #6b8e23;">C</span>[<span style="color: #00008b;">_</span>, <span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">T</span>[<span style="color: #00008b;">_</span>]]] <span style="color: #00008b;">extends</span> <span style="color: #36648b;">Endofunctor</span>[<span style="color: #6b8e23;">C</span>, <span style="color: #6b8e23;">T</span>] {
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">eta</span>[<span style="color: #6b8e23;">A</span>]<span style="color: #00008b;">:</span> <span style="color: #36648b;">C</span>[<span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">T</span>[<span style="color: #6b8e23;">A</span>]]
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">mu</span>[<span style="color: #6b8e23;">A</span>]<span style="color: #00008b;">:</span> <span style="color: #36648b;">C</span>[<span style="color: #6b8e23;">T</span>[<span style="color: #6b8e23;">T</span>[<span style="color: #6b8e23;">A</span>]], <span style="color: #6b8e23;">T</span>[<span style="color: #6b8e23;">A</span>]]
}
</pre>
</div>
<p>
同样，把 c = Hask 替换进去，就得到更类似我们 Haskell 中 Monad 的定义
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">class</span> <span style="color: #36648b;">Endofunctor</span> m <span style="color: #b8860b;">=&gt;</span> <span style="color: #36648b;">Monad</span> m <span style="color: #00008b;">where</span>
  eta <span style="color: #b8860b;">::</span> a <span style="color: #b8860b;">-&gt;</span> (m a)
  mu <span style="color: #b8860b;">::</span> m m a <span style="color: #b8860b;">-&gt;</span> m a
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">trait</span> <span style="color: #36648b;">Monad</span>[<span style="color: #6b8e23;">M</span>[<span style="color: #00008b;">_</span>]] <span style="color: #00008b;">extends</span> <span style="color: #36648b;">Endofunctor</span>[<span style="color: #6b8e23;">M</span>] {
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">eta</span>[<span style="color: #6b8e23;">A</span>]<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">M</span>[<span style="color: #6b8e23;">A</span>]
  <span style="color: #00008b;">def</span> <span style="color: #6a5acd;">mu</span>[<span style="color: #6b8e23;">A</span>]<span style="color: #00008b;">:</span> <span style="color: #36648b;">M</span>[<span style="color: #6b8e23;">M</span>[<span style="color: #6b8e23;">A</span>]] <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">M</span>[<span style="color: #6b8e23;">A</span>]
}
</pre>
</div>
<p>
要推出单子的 &eta; 变换，只需要让 FG = T
</p>

<figure>
<img src="images/p1-ajunction-functor-to-monad-eta.png" alt="p1-ajunction-functor-to-monad-eta.png">

<figcaption><span class="figure-number">Figure 10: </span>伴随函子的 &epsilon; 就是单子的 &eta;</figcaption>
</figure>

<p>
同样的，当 FG = T, F &eta; G 就可以变成 &mu;
</p>

<figure>
<img src="images/p1-ajunction-functor-to-monad-mu.png" alt="p1-ajunction-functor-to-monad-mu.png">

<figcaption><span class="figure-number">Figure 11: </span>伴随函子的 F &eta; G 是函子的 &mu;</figcaption>
</figure>
</div>

<div id="outline-container-orgca7d5a1" class="outline-4">
<h4 id="orgca7d5a1">三角等式</h4>
<div class="outline-text-4" id="text-orgca7d5a1">
<p>
三角等式是指 &mu; . T &eta; = T = &mu; . &eta; T
</p>

<p>
要推出三角等式只需要组合 F &eta; G 和 &epsilon; F G
</p>

<figure>
<img src="images/p1-adjunction-functor-triangle.png" alt="p1-adjunction-functor-triangle.png">

<figcaption><span class="figure-number">Figure 12: </span>F &eta; G  . &epsilon; F G = F G</figcaption>
</figure>

<figure>
<img src="images/p1-monad-triangle.png" alt="p1-monad-triangle.png">

<figcaption><span class="figure-number">Figure 13: </span>F &eta; G  . &epsilon; F G= F G 对应到Monad就是 &mu; . &eta; T = T</figcaption>
</figure>

<p>
换到代码上来说
</p>
<div class="org-src-container">
<pre class="src src-haskell">(mu <span style="color: #b8860b;">.</span> eta) m <span style="color: #b8860b;">=</span> m
</pre>
</div>

<p>
同样的，左右翻转也成立
</p>


<figure>
<img src="images/p1-adjunction-functor-triangle-reverse.png" alt="p1-adjunction-functor-triangle-reverse.png">

<figcaption><span class="figure-number">Figure 14: </span>F &eta; G . F G &epsilon; = F G</figcaption>
</figure>
<p>
<img src="images/p1-monad-triangle-reverse.png" alt="p1-monad-triangle-reverse.png">
T &eta; 就是 fmap eta
</p>
<div class="org-src-container">
<pre class="src src-haskell">(mu <span style="color: #b8860b;">.</span> fmap eta) m <span style="color: #b8860b;">=</span> m
</pre>
</div>

<p>
如果把 <code>mu . fmap</code> 写成 <code>&gt;&gt;=</code> , 就有了
</p>

<div class="org-src-container">
<pre class="src src-haskell">m <span style="color: #6a5acd;">&gt;&gt;=</span> eta <span style="color: #b8860b;">=</span> m
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf2a5830" class="outline-4">
<h4 id="orgf2a5830">结合律</h4>
<div class="outline-text-4" id="text-orgf2a5830">
<p>
单子另一大定律是结合律，让我们从伴随函子推起
</p>

<p>
假设我们现在有函子 F &eta; G 和 函子 F &eta; G F G, compose 起来会变成  F &eta; G . F &eta; G F G
<img src="images/p1-ajunction-functor-monad-laws-1.png" alt="p1-ajunction-functor-monad-laws-1.png">
</p>

<p>
用 F G = T ， F &eta; G = &mu; 代换那么就得到了单子的 &mu; . &mu; T
<img src="images/p1-ajunction-functor-monad-laws-2.png" alt="p1-ajunction-functor-monad-laws-2.png">
</p>

<p>
当组合 F &eta; G 和 F G F &mu; G 后，会得到一个镜像的图
<img src="images/p1-ajunction-functor-monad-laws-3.png" alt="p1-ajunction-functor-monad-laws-3.png">
</p>

<p>
对应到单子的 &mu; . T &mu;
</p>

<p>
结合律是说 &mu; . &mu; T = &mu; . T &mu; , 即图左右翻转结果是相等的，为什么呢？看单子的String Diagram 不太好看出来，我们来看伴随函子
</p>

<p>
如果把左图的左边的 &mu; 往上挪一点，右边的 &mu; 往下挪一点，是不是跟右图就一样了
<img src="images/p1-ajunction-functor-monad-laws-4.png" alt="p1-ajunction-functor-monad-laws-4.png">
</p>

<p>
结合律反映到代码中就是
</p>
<div class="org-src-container">
<pre class="src src-haskell">mu <span style="color: #6a5acd;">.</span> fmap mu <span style="color: #b8860b;">=</span> mu <span style="color: #b8860b;">.</span> mu
</pre>
</div>

<p>
代码很难看出结合在哪里，因为正常的结合律应该是这样的 (1+2)+3 = 1+(2+3)，但是不想加法的维度不一样，这里说的是自然变换维度的结合，可以通过String Diagram 很清楚的看见结合的过程，即 &mu; 左边的两个T和先 &mu; 右边两个 T 是相等的。
</p>
</div>
</div>
</div>

<div id="outline-container-org1a754d9" class="outline-3">
<h3 id="org1a754d9">Yoneda lemma / <del>米田共</del> 米田引理</h3>
<div class="outline-text-3" id="text-org1a754d9">
<p>
米田引理是说所有Functor <code>f a</code> 一定存在 embed 和 unembed，使得 <code>f a</code> 和 <code>(a -&gt; b) -&gt; F b</code> isomorphic 同构
</p>

<p>
haskell还要先打开 RankNTypes 的 feature
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #228b22;">{-# LANGUAGE RankNTypes #-}</span>

<span style="color: #6a5acd;">embed</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">Functor</span> f <span style="color: #b8860b;">=&gt;</span> f a <span style="color: #b8860b;">-&gt;</span> (<span style="color: #00008b;">forall</span> b <span style="color: #b8860b;">.</span> (a <span style="color: #b8860b;">-&gt;</span> b) <span style="color: #b8860b;">-&gt;</span> f b)
<span style="color: #6a5acd;">embed</span> x f <span style="color: #b8860b;">=</span> fmap f x

<span style="color: #6a5acd;">unembed</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">Functor</span> f <span style="color: #b8860b;">=&gt;</span> (<span style="color: #00008b;">forall</span> b <span style="color: #b8860b;">.</span> (a <span style="color: #b8860b;">-&gt;</span> b) <span style="color: #b8860b;">-&gt;</span> f b) <span style="color: #b8860b;">-&gt;</span> f a
<span style="color: #6a5acd;">unembed</span> f <span style="color: #b8860b;">=</span> f id
</pre>
</div>

<p>
Scala 语言没有 Rank N Type支持, 但是 <a href="#orgb1490d8"><ruby>自然变换<rt>Natural Transformations</rt></ruby></a> 提到过可以用 <code>apply</code> 来模拟. 其实可以使用 Cats 的 <a href="https://typelevel.org/cats/datatypes/functionk.html">FunctionK(~&gt;)</a> 更方便:
</p>
<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">def</span> <span style="color: #6a5acd;">embed</span>[<span style="color: #6b8e23;">F</span>[<span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">A</span>](fa<span style="color: #00008b;">:</span> <span style="color: #36648b;">F</span>[<span style="color: #6b8e23;">A</span>])(<span style="color: #228b22;">implicit</span> f<span style="color: #00008b;">:</span> <span style="color: #36648b;">Functor</span>[<span style="color: #6b8e23;">F</span>])<span style="color: #00008b;">:</span> (<span style="color: #6b8e23;">A</span> <span style="color: #00008b;">=&gt;</span> ?) ~&gt; <span style="color: #6b8e23;">F</span> <span style="color: #00008b;">=</span>
  <span style="color: #6b8e23;">Lambda</span>[(<span style="color: #6b8e23;">A</span> <span style="color: #00008b;">=&gt;</span> ?) ~&gt; <span style="color: #6b8e23;">F</span>](f.fmap(<span style="color: #00008b;">_</span>)(fa))
<span style="color: #00008b;">def</span> <span style="color: #6a5acd;">unembed</span>[<span style="color: #6b8e23;">F</span>[<span style="color: #00008b;">_</span>]](fnk<span style="color: #00008b;">:</span> (<span style="color: #6b8e23;">A</span> <span style="color: #00008b;">=&gt;</span> ?) ~&gt; <span style="color: #6b8e23;">F</span>)<span style="color: #00008b;">:</span> <span style="color: #36648b;">F</span>[<span style="color: #6b8e23;">A</span>] <span style="color: #00008b;">=</span>
  fnk(identity)
</pre>
</div>

<p>
embed 可以把 functor <code>f a</code> 变成 <code>(a -&gt; b) -&gt; f b</code>
</p>

<p>
unembed 是反过来， <code>(a -&gt; b) -&gt; f b</code> 变成 <code>f a</code>
</p>

<p>
上个图就明白了
</p>

<figure>
<object type="image/svg+xml" data="images/yoneda-lemma.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>

<figcaption><span class="figure-number">Figure 15: </span>也就是说，图中无论知道a-&gt;b 再加上任意一个 F x，都能推出另外一个 F</figcaption>
</figure>
</div>

<div id="outline-container-orgade6eef" class="outline-4">
<h4 id="orgade6eef">Rank N Type</h4>
<div class="outline-text-4" id="text-orgade6eef">
<p>
说好的要解释 Rank N Type
</p>

<p>
Haskell 中可以不用声明类型, 但是其实是省略掉 universally quantified <code>forall</code>, 如果把 forall 全部加回来,
就明了很多:
</p>

<ul class="org-ul">
<li>Monomorphic Rank 0 / 0级单态<label for="7" class="margin-toggle sidenote-number"></label><input type="checkbox" id="7" class="margin-toggle"/><span class="sidenote">
也就不是不变态
</span>: t</li>
<li>Polymorphic Rank 1 / 1级 <del>变态</del> 多态: forall a b. a -&gt; b</li>
<li>Polymorphic Rank 2 / 2级多态: forall c. (forall a b. a -&gt; b) -&gt; c</li>
<li>Polymorphic Rank 3 / 3级多态: forall d . (forall c . (forall a b . a -&gt; b) -&gt; c) -&gt; d</li>
</ul>

<p>
看 rank 几只要数左边 forall 的个数就好了.
</p>

<p>
一级多态只锁定一次类型 a 和 b
</p>

<p>
二级多态可以分两次确定类型, 第一次确定 c, 第二次确定 a b
</p>

<p>
三级多台分三次: 第一次 d, 第二次 c, 第三次 a b
</p>

<p>
比如:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">rank2</span> <span style="color: #b8860b;">::</span> <span style="color: #00008b;">forall</span> b c <span style="color: #b8860b;">.</span> b <span style="color: #b8860b;">-&gt;</span> c <span style="color: #b8860b;">-&gt;</span> (<span style="color: #00008b;">forall</span> a<span style="color: #b8860b;">.</span> a <span style="color: #b8860b;">-&gt;</span> a) <span style="color: #b8860b;">-&gt;</span> (b, c)
<span style="color: #6a5acd;">rank2</span> b c f <span style="color: #b8860b;">=</span> (f b, f c)

<span style="color: #6a5acd;">rank2</span> <span style="color: #36648b;">True</span> <span style="color: #8b0000;">'a'</span> id
<span style="color: #8c8c8c; font-style: italic;">-- </span><span style="color: #8c8c8c; font-style: italic;">(True, 'a')</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">def</span> <span style="color: #6a5acd;">rank2</span>[<span style="color: #6b8e23;">B</span>, <span style="color: #6b8e23;">C</span>](b<span style="color: #00008b;">:</span> <span style="color: #36648b;">B</span>, c<span style="color: #00008b;">:</span> <span style="color: #36648b;">C</span>)(fnk<span style="color: #00008b;">:</span> <span style="color: #36648b;">Id</span> ~&gt; <span style="color: #6b8e23;">Id</span>)<span style="color: #00008b;">:</span> (<span style="color: #6b8e23;">B</span>, <span style="color: #6b8e23;">C</span>) <span style="color: #00008b;">=</span>
  (fnk(b), fnk(c))
rank2(<span style="color: #6b8e23;">true</span>, <span style="color: #8b0000;">'a'</span>)(<span style="color: #6b8e23;">FunctionK</span>.id[<span style="color: #6b8e23;">Id</span>])
</pre>
</div>

<ul class="org-ul">
<li>f 在 <code>f True</code> 时类型 <code>Boolean -&gt; Boolean</code> 是符合 <code>forall a. a-&gt;a</code> 的</li>
<li>与此同时 <code>f 'a'</code> 时类型确实是 <code>Char -&gt; Char</code> 但也符合 <code>forall a. a-&gt;a</code></li>
</ul>

<p>
如果是 rank1 类型系统就懵逼了:
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">rank1</span> <span style="color: #b8860b;">::</span> <span style="color: #00008b;">forall</span> a b c <span style="color: #b8860b;">.</span> b <span style="color: #b8860b;">-&gt;</span> c <span style="color: #b8860b;">-&gt;</span> (a <span style="color: #b8860b;">-&gt;</span> a) <span style="color: #b8860b;">-&gt;</span> (b, c)
<span style="color: #6a5acd;">rank1</span> b c f <span style="color: #b8860b;">=</span> (f b, f c)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">def</span> <span style="color: #6a5acd;">rank1</span>[<span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>, <span style="color: #6b8e23;">C</span>](b<span style="color: #00008b;">:</span> <span style="color: #36648b;">B</span>, c<span style="color: #00008b;">:</span> <span style="color: #36648b;">C</span>)(fn<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">A</span>)<span style="color: #00008b;">:</span> (<span style="color: #6b8e23;">B</span>, <span style="color: #6b8e23;">C</span>) <span style="color: #00008b;">=</span>
  (fn(b), fn(c))
</pre>
</div>
<p>
f 在 <code>f True</code> 是确定 a 是 Boolean，在rank1多态是时就确定了 <code>a-&gt;a</code> 的类型一定是 <code>Boolean -&gt; Boolean</code>
</p>

<p>
所以到 <code>f 'a'</code> 类型就挂了。
</p>
</div>
</div>
</div>

<div id="outline-container-org0fb6f6c" class="outline-3">
<h3 id="org0fb6f6c">Kan extensions 看展</h3>
<div class="outline-text-3" id="text-org0fb6f6c">
<p>
说到米田引理, 不得不提到一切概念的根源 <ruby>看展<rt>kan extensions</rt></ruby>
</p>

<div class="epigraph"><blockquote>
<p>
All Concepts Are Kan Extensions
The notion of Kan extensions subsumes all the other fundamental concepts of category theory.
&#x2013; <a href="https://en.wikipedia.org/wiki/Categories_for_the_Working_Mathematician">Categories for the Working Mathematician</a> by Saunders Mac Lane
</p>

</blockquote></div>
<p>
看展有一对(duel), <ruby>左看<rt> Lan</rt></ruby>,和 <ruby>右看<rt> Ran</rt></ruby>, 不如从 右看 开始, 趁着米田共还没凉.
</p>

<p>
右看的大概意思是这样的, 说有:
</p>

<ul class="org-ul">
<li>三个范畴, A, B, C</li>
<li>范畴之间有两个函子, AC 范畴的 <code>X</code> 和 AB 范畴的 <code>F</code></li>
</ul>

<p>
那么就一定一个 BC 的函子 Ran<sub>F</sub>X 和 从 Ran<sub>F</sub>X compose F 到 X 的 自然变换 &mu;
</p>

<p>
文字确实很绕, 让我们看看线图, 就很清楚.
</p>
</div>

<div id="outline-container-org043688b" class="outline-4">
<h4 id="org043688b"><span class="todo TODO">TODO</span> insert diagram</h4>
<div class="outline-text-4" id="text-org043688b">
<p>
还是线图神奇吧, 很明显如果有 X 和 F 和 三个范畴, 那肯定可以找到 Ran<sub>FX</sub> 和 自然变换把图补成这个样子:
</p>
</div>
</div>

<div id="outline-container-org77bbe66" class="outline-4">
<h4 id="org77bbe66"><span class="todo TODO">TODO</span> insert diagram</h4>
<div class="outline-text-4" id="text-org77bbe66">
<p>
那么问题来了, 这货到底是
</p>

<p>
右看还有一个重要的属性是:
</p>

<p>
对于任意 BC 的函子 Z 如果能找到从 Z . F ~&gt; X 的自然变换, 那就存在一个唯一的从 Z ~&gt; Ran<sub>F</sub>X 的自然变换
</p>

<p>
那么表示成代码应该长什么样呢? 既然 Z ~&gt; Ran<sub>F</sub>X 只存在一个自然变换,那么我们找到 Z 不就找到了 Ran<sub>F</sub>X?
</p>

<ul class="org-ul">
<li>Z . F ~&gt; X : <code>forall b. z (f b) -&gt; x b</code></li>
<li>Z ~&gt; Ran<sub>F</sub>X : <code>forall a. z a -&gt; Ran f x a</code></li>
</ul>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">ran</span> <span style="color: #b8860b;">::</span> <span style="color: #00008b;">forall</span> z<span style="color: #b8860b;">.</span> <span style="color: #36648b;">Functor</span> z <span style="color: #b8860b;">=&gt;</span> (<span style="color: #00008b;">forall</span> b<span style="color: #b8860b;">.</span> z (f b) <span style="color: #b8860b;">-&gt;</span> x b) <span style="color: #b8860b;">-&gt;</span> (<span style="color: #00008b;">forall</span> a<span style="color: #b8860b;">.</span> z a <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">Ran</span> f x a)
</pre>
</div>

<p>
如果把 <code>Ran f x a</code> 拿到左边来定义成 data type 那么就有:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">data</span> <span style="color: #36648b;">Ran</span> f x a <span style="color: #b8860b;">=</span> forall z<span style="color: #b8860b;">.</span> <span style="color: #36648b;">Functor</span> z <span style="color: #b8860b;">=&gt;</span> <span style="color: #36648b;">Ran</span> (forall b<span style="color: #b8860b;">.</span> z (f b) <span style="color: #b8860b;">-&gt;</span> x b) (z a)
</pre>
</div>

<p>
读出来很清楚吧, 随便给个函子 z, Ran f x a 就可以从 z . f 到 x 的自然变换 和 z 找到.
</p>

<p>
这个定义有 rank 3, 分别是 a, b 和 z.
但是真正的 Edward Kmett 的 <a href="http://hackage.haskell.org/package/kan-extensions-5.2">看展实现</a> 是简化为 rank 2 type 版本的, 只有 a, b 两 rank, 让我们看下他的定义:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #00008b;">newtype</span> <span style="color: #36648b;">Ran</span> f x a <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Ran</span> { runRan <span style="color: #b8860b;">::</span> <span style="color: #00008b;">forall</span> b<span style="color: #b8860b;">.</span> (a <span style="color: #b8860b;">-&gt;</span> f b) <span style="color: #b8860b;">-&gt;</span> x b }
</pre>
</div>

<p>
先来看看 &mu;
</p>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">toRan</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">Functor</span> z <span style="color: #b8860b;">=&gt;</span> (<span style="color: #00008b;">forall</span> b<span style="color: #b8860b;">.</span> z (f b) <span style="color: #b8860b;">-&gt;</span> x b) <span style="color: #b8860b;">-&gt;</span> (z a <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">Ran</span> f x a)
<span style="color: #6a5acd;">toRan</span> s t <span style="color: #b8860b;">=</span> <span style="color: #36648b;">Ran</span> (s <span style="color: #b8860b;">.</span> flip fmap t)
</pre>
</div>

<p>
这是point free 我们从右边开始走, Ran 里面是个函数 <code>forall b. (a -&gt; f b) -&gt; x b</code> 所以 <code>(s . flip fmap t)</code> 就是这个函数类型
</p>

<p>
让我们试试类型对不对, 如果给这个函数入参 <code>(a -&gt; f b)</code>, t 是 <code>z a</code>, 所以 <code>=flip fmap</code> 完了得到的类型是 <code>z (f b)</code>.
代入 <code>s:: z (f b) -&gt; x b</code> 刚好得到 <code>x b</code>, 类型正确.
</p>

<p>
翻译成人话就是对于 Edward 的 Ran 来说他知道如何从 <code>a -&gt; f b</code> , 如果你提供 <code>z a</code> 因为 z 是函子只要map一下就会得到 <code>z (f b)</code>
因为存在 z . f 到 x 的自然变换最终刚好会得出 x b 来, 所以 Edward 定义 Ran 其实就是输入和输出.
</p>

<p>
反过来, 如果我有个 Ran f x 如何求出这俩自然变换呢?
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">fromRan</span> <span style="color: #b8860b;">::</span> (<span style="color: #00008b;">forall</span> a<span style="color: #b8860b;">.</span> z a <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">Ran</span> f x a) <span style="color: #b8860b;">-&gt;</span> (z (f b) <span style="color: #b8860b;">-&gt;</span> x b)
<span style="color: #6a5acd;">fromRan</span> s <span style="color: #b8860b;">=</span> flip runRan id <span style="color: #b8860b;">.</span> s
</pre>
</div>

<p>
依次展开下类型:
</p>
<ol class="org-ol">
<li><code>ranRa :: forall b. Ran f x a -&gt; (a -&gt; f b) -&gt; x b</code></li>
<li><code>flip ranRan :: forall b. (a -&gt; f b) -&gt; Ran f x a -&gt; x b</code></li>
<li><code>flip ranRan id :: forall b. Ran f x (f b) -&gt; x b</code></li>
<li><code>s :: z (f b) -&gt; Ran f x (f b)</code></li>
<li><code>flip ranRan id . s :: z (f b) -&gt; x b</code></li>
</ol>

<p>
所以这个 rank 2 的 Ran 其实算出来是 a = f b 也就少了一 rank.
</p>
</div>
</div>
</div>


<div id="outline-container-org733f8e7" class="outline-3">
<h3 id="org733f8e7"><i>Kleisli Catergory</i></h3>
<div class="outline-text-3" id="text-org733f8e7">

<figure>
<object type="image/svg+xml" data="images/kleisli.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>

<figcaption><span class="figure-number">Figure 16: </span>注意观察大火箭 &lt;=&lt; 的轨迹（不知道dot为什么会把这根线搞这么又弯又骚的） 和 &gt;&gt;= 。所以 Kleisli 其实就是斜着走的一个范畴，但是 &gt;&gt;= 把它硬生生掰 <del>弯</del> 直了。</figcaption>
</figure>

<p>
<ruby>函子<rt>Functor</rt></ruby> 的范畴叫做 <ruby>函子范畴<rt>Functor Catergory</rt></ruby>, 自然变换是其箭头。那<ruby>单子<rt>Monad</rt></ruby>也可以定义一个范畴吗?<label for="8" class="margin-toggle sidenote-number"></label><input type="checkbox" id="8" class="margin-toggle"/><span class="sidenote">
当然, 单子是自函子，所以也可以是自函子范畴
</span>
</p>

<p>
是的, 这个范畴名字叫做 <del>单子范畴</del><label for="9" class="margin-toggle sidenote-number"></label><input type="checkbox" id="9" class="margin-toggle"/><span class="sidenote">
怎么说也是函数式编程的核心,怎么可以叫的这么low这么直接
</span> <ruby>可莱斯利范畴<rt>Kleisli Catergory</rt></ruby><label for="10" class="margin-toggle sidenote-number"></label><input type="checkbox" id="10" class="margin-toggle"/><span class="sidenote">
这个是我瞎翻译的, 但是读出来就是这么个意思, 真的, 不骗你, 照这么读绝对装的一手好逼, 不会被嘲笑的
</span>，那么 Kleisli 的箭头是什么？
我们看定义，Kleisli Catergory
</p>

<ol class="org-ol">
<li>箭头是 Kleisli 箭头 <code>a -&gt; T b</code></li>
<li>东西就是c范畴中的东西. 因为 a 和 b 都是 c 范畴上的， 由于T是自函子，所以 T b 也是 c 范畴的</li>
</ol>

<p>
看到图上的 <ruby>T f<rt> fmap f</rt></ruby> 和 &mu; 了没？<label for="11" class="margin-toggle sidenote-number"></label><input type="checkbox" id="11" class="margin-toggle"/><span class="sidenote">
(敲黑板) 就是紫色那根嘛!
</span>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #6a5acd;">f</span> <span style="color: #b8860b;">::</span> b <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">T</span> c
<span style="color: #6a5acd;">fmap</span> f <span style="color: #b8860b;">::</span> <span style="color: #36648b;">T</span> b <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">T</span> <span style="color: #36648b;">T</span> c
<span style="color: #6a5acd;">mu</span> <span style="color: #b8860b;">::</span> <span style="color: #36648b;">T</span> <span style="color: #36648b;">T</span> c <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">T</span> c
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">def</span> <span style="color: #6a5acd;">f</span>[<span style="color: #6b8e23;">T</span>[<span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">B</span>, <span style="color: #6b8e23;">C</span>](b<span style="color: #00008b;">:</span> <span style="color: #36648b;">B</span>)<span style="color: #00008b;">:</span> <span style="color: #36648b;">T</span>[<span style="color: #6b8e23;">C</span>]
<span style="color: #00008b;">def</span> <span style="color: #6a5acd;">fmap</span>[<span style="color: #6b8e23;">T</span>[<span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">B</span>, <span style="color: #6b8e23;">C</span>](f<span style="color: #00008b;">:</span> <span style="color: #36648b;">B</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">C</span>)(tb<span style="color: #00008b;">:</span> <span style="color: #36648b;">T</span>[<span style="color: #6b8e23;">B</span>])<span style="color: #00008b;">:</span> <span style="color: #36648b;">T</span>[<span style="color: #6b8e23;">T</span>[<span style="color: #6b8e23;">C</span>]]
<span style="color: #00008b;">def</span> <span style="color: #6a5acd;">mu</span>[<span style="color: #6b8e23;">T</span>[<span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">C</span>](ttc<span style="color: #00008b;">:</span> <span style="color: #36648b;">T</span>[<span style="color: #6b8e23;">T</span>[<span style="color: #6b8e23;">C</span>]])<span style="color: #00008b;">:</span> <span style="color: #36648b;">T</span>[<span style="color: #6b8e23;">C</span>]
</pre>
</div>

<p>
紫色的箭头 <code>T f</code><label for="12" class="margin-toggle sidenote-number"></label><input type="checkbox" id="12" class="margin-toggle"/><span class="sidenote">
即 <code>fmap f</code>
</span> 和紫色的虚线箭头 &mu; 连起来就是 <code>T f'</code>, 那么最出名的 <code>&gt;&gt;=</code> 符号终于出来了:
</p>
<div class="org-src-container">
<pre class="src src-haskell">tb <span style="color: #6a5acd;">&gt;&gt;=</span> f <span style="color: #b8860b;">=</span> (mu <span style="color: #b8860b;">.</span> fmap f) tb
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">def</span> <span style="color: #6a5acd;">flatMap</span>[<span style="color: #6b8e23;">T</span>[<span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">B</span>, <span style="color: #6b8e23;">C</span>](f<span style="color: #00008b;">:</span> <span style="color: #36648b;">B</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">T</span>[<span style="color: #6b8e23;">C</span>])(tb<span style="color: #00008b;">:</span> <span style="color: #36648b;">T</span>[<span style="color: #6b8e23;">B</span>])<span style="color: #00008b;">:</span> <span style="color: #36648b;">T</span>[<span style="color: #6b8e23;">C</span>] <span style="color: #00008b;">=</span> (mu compose fmap(f))(tb)
</pre>
</div>

<p>
下面这个大火箭 <code>&lt;=&lt;</code> 可以把蓝色箭头组合起来.
</p>
<div class="org-src-container">
<pre class="src src-haskell">(f <span style="color: #b8860b;">&lt;=&lt;</span> g) <span style="color: #b8860b;">=</span> mu <span style="color: #b8860b;">.</span> <span style="color: #36648b;">T</span> f <span style="color: #b8860b;">.</span> g <span style="color: #b8860b;">=</span> mu <span style="color: #b8860b;">.</span> fmap f <span style="color: #b8860b;">.</span> g
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00008b;">def</span> <span style="color: #6a5acd;">&lt;=&lt;</span>[<span style="color: #6b8e23;">T</span>[<span style="color: #00008b;">_</span>], <span style="color: #6b8e23;">A</span>, <span style="color: #6b8e23;">B</span>, <span style="color: #6b8e23;">C</span>](f<span style="color: #00008b;">:</span> <span style="color: #36648b;">B</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">T</span>[<span style="color: #6b8e23;">C</span>])(g<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">T</span>[<span style="color: #6b8e23;">B</span>])<span style="color: #00008b;">:</span> <span style="color: #36648b;">A</span> <span style="color: #00008b;">=&gt;</span> <span style="color: #6b8e23;">T</span>[<span style="color: #6b8e23;">C</span>] <span style="color: #00008b;">=</span>
  mu compose fmap(f) compose g
</pre>
</div>

<p>
因此大火箭就是 Kleisli 范畴的 <code>compose</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell">(<span style="color: #6a5acd;">&lt;=&lt;</span>) <span style="color: #b8860b;">::</span> <span style="color: #36648b;">Monad</span> <span style="color: #36648b;">T</span> <span style="color: #b8860b;">=&gt;</span> (b <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">T</span> c) <span style="color: #b8860b;">-&gt;</span> (a <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">T</span> b) <span style="color: #b8860b;">-&gt;</span> (a <span style="color: #b8860b;">-&gt;</span> <span style="color: #36648b;">T</span> c)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc07522e" class="outline-3">
<h3 id="orgc07522e">Summary</h3>
<div class="outline-text-3" id="text-orgc07522e">
<p>
第一部分理论部分都讲完了， 如果你读到这里还没有被这些<ruby>吊炸天<rt>乱七八糟</rt></ruby>的概念搞daze，接下来可以看看它到底跟我们编程有鸟关系呢？第二部分将介绍这些概念产生的一些实用的monad
</p>

<ul class="org-ul">
<li>👉 <a href="./part2.html">第二部分：<ruby>食用猫呢<rt> Practical Monads</rt></ruby></a></li>
<li><a href="./part3.html">第三部分：<ruby>搞基猫呢<rt> Advanced Monads</rt></ruby></a></li>
</ul>

<p>
当然我还没空全部写完，如果有很多人<ruby>预定<rt>只要998</rt></ruby> Gumroad 上的  <script src="https://gumroad.com/js/gumroad.js"></script><a class="gumroad-button" href="https://gum.co/grokking-monad" target="_blank">Grokking Monad</a> 电子书的话，我可能会稍微写得快一些。毕竟，写了也没人感兴趣也怪浪费时间的。不过，我猜也没几个人能看到这一行，就当是自言自语吧，怎么突然觉得自己好分裂。
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
<a href="https://en.wikipedia.org/wiki/Cheshire_Cat">https://en.wikipedia.org/wiki/Cheshire_Cat</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
如果没看就刚好不要看了, 确实有些误导
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
等等, 写前端怎么了? JavaScript 只是我觉得顺手的若干语言之一, JS用户那么多, 写书当然要用 JS 啦, 难道用 Idris 那还能卖得掉吗? <del>当然最后用JS也没怎么卖掉&#x2026;</del>
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
并不是说这两门语言一定在鄙视链顶端, 而是拥有强大类型系统的语言才能体现出范畴论的内容
</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5">5</a></sup> <div class="footpara"><p class="footpara">
这里可以把 Functor 的第一第二个参数消掉, 因为已经知道是在 Hask 范畴了
</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6">6</a></sup> <div class="footpara"><p class="footpara">
别急, 后面马上讲到
</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7">7</a></sup> <div class="footpara"><p class="footpara">
也就不是不变态
</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8">8</a></sup> <div class="footpara"><p class="footpara">
当然, 单子是自函子，所以也可以是自函子范畴
</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9">9</a></sup> <div class="footpara"><p class="footpara">
怎么说也是函数式编程的核心,怎么可以叫的这么low这么直接
</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10">10</a></sup> <div class="footpara"><p class="footpara">
这个是我瞎翻译的, 但是读出来就是这么个意思, 真的, 不骗你, 照这么读绝对装的一手好逼, 不会被嘲笑的
</p></div></div>

<div class="footdef"><sup><a id="fn.11" class="footnum" href="#fnr.11">11</a></sup> <div class="footpara"><p class="footpara">
(敲黑板) 就是紫色那根嘛!
</p></div></div>

<div class="footdef"><sup><a id="fn.12" class="footnum" href="#fnr.12">12</a></sup> <div class="footpara"><p class="footpara">
即 <code>fmap f</code>
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<footer>
  <p>Author: 欧阳继超
    <a class="github-button" href="https://github.com/sponsors/jcouyang" data-icon="octicon-heart" aria-label="Sponsor @jcouyang on GitHub">Sponsor</a>
    <a aria-label="Follow @jcouyang on GitHub" data-count-aria-label="# followers on GitHub" data-count-api="/users/jcouyang#followers" data-count-href="/jcouyang/followers" href="https://github.com/jcouyang" class="github-button">Follow</a>
  </p>
  <p>Created: 2017-02-10 Fri 00:00</p>
  <p>Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.3 (<a href="https://orgmode.org">Org</a> mode 9.3.6) &#215; <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.
  <input type="swiftype" class="st-default-search-input" placeholder="Search"/>
  <a class="gumroad-button" href="https://gum.co/grokking-monad?wanted=true" target="_blank" data-gumroad-single-product="true">范畴论装逼指南，请自觉排队装逼</a>
  <div id="danmaku-comments"></div>
  <div id="disqus_thread"></div>
</footer>
</div>
</body>
</html>
